



<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Team Hub</title>
    <? function include(filename) { return HtmlService.createHtmlOutputFromFile(filename).getContent(); } ?>
    <style>


:root {
  /* choose one primary font family */
  --font-main: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;

  /* color & text smoothing (optional) */
  --text-color: #e6edf3;
}

/* global baseline */
body, button, input, select, textarea {
  font-family: var(--font-main);
  color: var(--text-color);
  font-size: 14px;
  letter-spacing: 0.2px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* unify tab text */
.tab {
  font-family: var(--font-main);
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.3px;
  text-transform: none;
  color: var(--text-color);
}

/* unify filter dropdowns and buttons */
.notes-filters select,
.notes-filters input,
button.apply,
button.clear {
  font-family: var(--font-main);
  font-size: 13px;
  color: var(--text-color);
}

















      :root {
        --bg:#0b0d10; --panel:#14181f; --muted:#79839a; --text:#e9edf6; --accent:#4aa8ff;
        --card:#1b2130; --chip:#232b3d; --border:#2a3448; --ok:#2ecc71; --warn:#ffb020; --bad:#ff5a5f;
        --chart-card-max:360px;
      }
html,body { margin:0; padding:0; background:var(--bg); color:var(--text); font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
.wrap { max-width:1200px; margin:0 auto; padding:24px; }
.wrap-narrow {
  display:none;
  width:100%;
  padding:16px;
  gap:16px;
  box-sizing:border-box;
}

.mobile-tabbar {
  display:none;
  position:sticky;
  bottom:0;
  left:0;
  right:0;
  grid-auto-flow:column;
  grid-auto-columns:1fr;
  gap:6px;
  padding:8px 12px;
  background:rgba(10,13,18,0.92);
  border-top:1px solid rgba(70,100,140,0.35);
  backdrop-filter:blur(12px);
  z-index:900;
}
.mobile-tabbar button {
  border:0;
  background:rgba(26,32,44,0.9);
  color:#cbd8f8;
  border-radius:12px;
  padding:8px 6px;
  font-size:12px;
  letter-spacing:0.3px;
  font-weight:600;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:2px;
}
.mobile-tabbar button span {
  font-size:11px;
  letter-spacing:0.2px;
}
.mobile-tabbar button.active {
  background:linear-gradient(135deg, rgba(74,168,255,0.9), rgba(134,77,255,0.9));
  color:#06142b;
  box-shadow:0 6px 16px rgba(74,168,255,0.35);
}

.panel-mobile-card {
  border:1px solid rgba(70,100,140,0.35);
  border-radius:16px;
  background:rgba(15,19,28,0.92);
  padding:16px;
  box-shadow:0 18px 40px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:12px;
}
.home-panel {
  display:flex;
  flex-direction:column;
  gap:18px;
}
.home-top {
  display:grid;
  gap:18px;
  grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));
  align-items:stretch;
}
.home-panel .card { margin:0; }
.home-chart-card #teamLine {
  width:100%;
  min-height:260px;
}
.chart-player-photo {
  object-position: center top !important; /* Focus on head/face area (top-center) */
}
.home-flags-card .ratingsWrap {
  max-height:360px;
}
.stats-opp-card {
  display:flex;
  flex-direction:column;
  gap:12px;
}
.stats-opp-card select {
  width:100%;
}
.league-scatter-wrap {
  position:relative;
  height:230px;
}
.league-scatter-wrap canvas {
  position:absolute;
  inset:0;
  width:100% !important;
  height:100% !important;
}
.opp-chart-row {
  display:flex;
  flex-wrap:wrap;
  gap:16px;
  justify-content:center;
  align-items:stretch;
}
.opp-chart-row > * {
  flex:1 1 300px;
  max-width:420px;
}
.opp-chart-wrap,
.shot-chart-wrap,
.four-chart-wrap {
  margin:6px 0;
  width:100%;
  min-width:260px;
  max-width:420px;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  position:relative;
  overflow:hidden;
}
.opp-chart-wrap canvas,
.shot-chart-wrap canvas,
.four-chart-wrap canvas {
  width:min(100%, 360px) !important;
  height:auto !important;
  max-height:340px;
  margin:0 auto;
}
.profile-tag-row {
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin:8px 0 12px;
}
.profile-tag {
  display:inline-flex;
  align-items:center;
  padding:4px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.18);
  font-size:11px;
  letter-spacing:0.2px;
  background:rgba(74,168,255,0.14);
  color:#d5e5ff;
}
.profile-tag.featured {
  background:rgba(255,176,32,0.22);
  border-color:rgba(255,176,32,0.35);
  color:#ffe5b5;
}
.opp-insights-grid {
  display:grid;
  gap:12px;
  grid-template-columns:repeat(auto-fit, minmax(220px, 1fr));
}
.opp-insight {
  background:rgba(255,255,255,0.02);
  border:1px solid var(--border);
  border-radius:10px;
  padding:10px;
  font-size:13px;
}
.opp-insight ul {
  margin:4px 0 0;
  padding-left:18px;
}
.opp-insight li {
  margin-bottom:6px;
}
.opp-insight li:last-child {
  margin-bottom:0;
}
.opp-profile-table {
  width:100%;
  border-collapse:collapse;
  font-size:12.5px;
}
.opp-profile-table th,
.opp-profile-table td {
  padding:4px 6px;
  border-bottom:1px solid rgba(255,255,255,0.07);
  text-align:right;
}
.opp-profile-table th:first-child,
.opp-profile-table td:first-child {
  text-align:left;
}
.opp-profile-table tr:last-child td {
  border-bottom:none;
}
.diff-chip {
  display:inline-block;
  margin-left:6px;
  padding:2px 6px;
  border-radius:999px;
  font-size:10.5px;
  font-weight:600;
  letter-spacing:0.1px;
}
.diff-chip.pos {
  background:rgba(46,204,113,0.18);
  color:#45d17b;
}
.diff-chip.neg {
  background:rgba(255,90,95,0.20);
  color:#ff6f76;
}
.diff-chip.neutral {
  background:rgba(255,255,255,0.08);
  color:#cbd6ee;
  font-size:13px;
}
.opp-profile-table th,
.opp-profile-table td {
  padding:6px 4px;
  border-bottom:1px solid var(--border);
  text-align:right;
}
.opp-profile-table th:first-child,
.opp-profile-table td:first-child {
  text-align:left;
}
.diff-chip {
  display:inline-block;
  margin-left:6px;
  padding:2px 6px;
  border-radius:999px;
  font-size:11px;
  font-weight:600;
  letter-spacing:0.1px;
}
.diff-chip.pos {
  background:rgba(46,204,113,0.18);
  color:#45d17b;
}
.diff-chip.neg {
  background:rgba(255,90,95,0.18);
  color:#ff6f76;
}
.diff-chip.neutral {
  background:rgba(255,255,255,0.08);
  color:#cbd6ee;
}
.summary-card-header {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.summary-card-header h2 {
  margin:0;
  font-size:16px;
  letter-spacing:0.3px;
}
.home-session-summary {
  display:flex;
  flex-direction:column;
  gap:16px;
}
.home-session-meta {
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  justify-content:space-between;
  align-items:flex-start;
}
.home-session-title {
  font-size:18px;
  font-weight:600;
  letter-spacing:0.3px;
  color:var(--text,#e6edf3);
}
.home-session-sub {
  font-size:13px;
  color:var(--muted,#8a96b3);
}
.home-session-stats {
  display:grid;
  grid-template-columns:repeat(auto-fit, minmax(150px, 1fr));
  gap:12px;
}
.home-session-stat {
  padding:12px 14px;
  border-radius:14px;
  background:var(--chip,#232b3d);
  border:1px solid rgba(255,255,255,0.07);
  display:flex;
  flex-direction:column;
  gap:6px;
}
.home-session-stat .label {
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.5px;
  color:var(--muted,#8a96b3);
}
.home-session-stat .value {
  font-size:20px;
  font-weight:600;
  color:var(--text,#e6edf3);
}
.home-session-stat .delta {
  font-size:12px;
}
.home-session-coach-table {
  border-radius:14px;
  border:1px solid rgba(255,255,255,0.07);
  background:rgba(15,20,30,0.65);
  padding:12px 14px;
  overflow:auto;
}
.home-session-coach-table table {
  width:100%;
  border-collapse:collapse;
}
.home-session-coach-table th,
.home-session-coach-table td {
  text-align:left;
  padding:8px 10px;
  border-bottom:1px solid rgba(255,255,255,0.06);
  font-size:13px;
  color:var(--text,#e6edf3);
}
.home-session-coach-table th {
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.4px;
  color:var(--muted,#8a96b3);
}
.home-session-coach-table tr:last-child td { border-bottom:none; }
.home-session-notes {
  border-radius:14px;
  border:1px solid rgba(74,168,255,0.25);
  background:rgba(74,168,255,0.05);
  padding:12px 14px;
}
.home-session-notes h3 {
  margin:0 0 8px;
  font-size:14px;
  letter-spacing:0.4px;
}
.home-session-notes-list {
  list-style:none;
  padding:0;
  margin:0;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.home-session-notes-list li {
  border-radius:10px;
  border:1px solid rgba(74,168,255,0.4);
  background:rgba(15,25,36,0.75);
  padding:10px 12px;
}
.home-session-notes-list strong {
  display:block;
  font-size:13px;
  color:var(--text,#e6edf3);
}
.home-session-notes-list .note-meta {
  font-size:11px;
  color:var(--muted,#8a96b3);
  margin-top:4px;
}
.home-session-player-list {
  border-radius:14px;
  border:1px solid rgba(255,255,255,0.07);
  background:rgba(13,18,28,0.7);
  padding:12px 14px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.home-session-player-list h3 {
  margin:0;
  font-size:14px;
  letter-spacing:0.3px;
}
.home-session-player-list ul {
  list-style:none;
  margin:8px 0 0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.home-session-player-list li {
  border:1px solid rgba(74,168,255,0.25);
  border-radius:12px;
  background:rgba(15,24,36,0.75);
  padding:10px 12px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.home-session-player-list .top-row {
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:8px;
}
.home-session-player-list .player-name {
  font-size:14px;
  font-weight:600;
  color:var(--text,#e6edf3);
}
.home-session-player-list .player-avg {
  font-size:18px;
  font-weight:600;
  color:var(--text,#e6edf3);
}
.home-session-player-list .player-coaches {
  font-size:11px;
  color:var(--muted,#8a96b3);
  text-transform:uppercase;
  letter-spacing:0.4px;
}
.home-session-player-list .player-note {
  font-size:12px;
  color:var(--text,#e6edf3);
  line-height:1.4;
}
.home-session-player-list .player-note .note-meta {
  font-size:11px;
  color:var(--muted,#8a96b3);
  margin-top:2px;
}
.home-session-player-list .player-note .note-text {
  margin-top:4px;
}
.home-session-empty {
  font-size:13px;
  color:var(--muted,#8a96b3);
}
.gamestats-controls {
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  align-items:center;
  margin-bottom:16px;
}
.gamestats-controls select,
.gamestats-controls button {
  min-height:32px;
  border-radius:8px;
  border:1px solid rgba(86,105,132,0.6);
  background:rgba(17,23,33,0.9);
  color:var(--text,#e6edf3);
  padding:6px 10px;
  font-size:13px;
}
.gamestats-controls button {
  background:var(--accent,#4aa8ff);
  border:none;
  color:#06142b;
  font-weight:600;
  cursor:pointer;
  transition:opacity 0.2s ease;
}
.gamestats-controls button:disabled {
  opacity:0.6;
  cursor:default;
}
.gamestats-summary {
  display:grid;
  grid-template-columns:repeat(auto-fit, minmax(220px, 1fr));
  gap:16px;
  margin-bottom:18px;
}
.gs-card {
  border:1px solid rgba(70,100,140,0.35);
  border-radius:14px;
  background:rgba(15,19,28,0.92);
  padding:16px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.gs-meta {
  font-size:13px;
  color:var(--muted,#79839a);
  display:flex;
  flex-direction:column;
  gap:4px;
}
.gs-meta strong {
  color:var(--text,#e6edf3);
  font-size:15px;
}
.gs-metric-list {
  list-style:none;
  padding:0;
  margin:0;
  display:flex;
  flex-direction:column;
  gap:6px;
  font-size:13px;
  color:var(--text,#e6edf3);
}
.gs-metric-list li {
  display:flex;
  justify-content:space-between;
  gap:8px;
}
.gs-metric-list li span {
  color:var(--muted,#79839a);
}
.table-wrap {
  overflow:auto;
  border:1px solid rgba(70,100,140,0.25);
  border-radius:12px;
  background:rgba(12,18,28,0.85);
}
.table-wrap table {
  width:100%;
  border-collapse:collapse;
  min-width:680px;
}
.table-wrap thead {
  background:rgba(26,32,44,0.8);
}
.table-wrap th,
.table-wrap td {
  padding:10px 12px;
  font-size:13px;
  text-align:left;
  border-bottom:1px solid rgba(70,100,140,0.25);
}
.table-wrap tbody tr:last-child td {
  border-bottom:none;
}
.table-wrap tbody tr:nth-child(even) {
  background:rgba(28,36,48,0.4);
}
.gamestats-charts {
  display:flex;
  flex-direction:column;
  gap:16px;
  width:100%;
}
.gamestats-section {
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  text-align:center;
  gap:10px;
  padding:16px;
  border-radius:12px;
  background:rgba(20,24,31,0.92);
  border:1px solid rgba(70,100,140,0.35);
  position:relative;
  overflow:hidden;
}
.gamestats-section.chart-span {
  justify-content:center;
}
.gamestats-section canvas {
  display:block;
  margin:0 auto;
}
.gamestats-section.chart-duo canvas {
  width:min(100%, 340px) !important;
  max-width:340px;
}
.gamestats-canvas-wrap {
  position:relative;
  width:100%;
  height:230px;
  overflow:hidden;
}
.gamestats-canvas-wrap canvas {
  position:absolute;
  inset:0;
  width:100% !important;
  height:100% !important;
}
.gs-chart-square {
  max-width:var(--chart-card-max);
  aspect-ratio:1 / 1;
  width:100%;
}

@media (min-width: 640px) {
  .gamestats-charts {
    display:grid;
    grid-template-columns:repeat(2, minmax(0, 1fr));
    gap:24px;
  }
  .gamestats-section.chart-span {
    grid-column:1 / -1;
    align-items:stretch;
  }
  .gamestats-canvas-wrap {
    height:230px;
  }
  .gamestats-section.chart-span .gs-chart-square {
    max-width:100%;
  }
  .gamestats-section.chart-duo canvas {
    width:min(100%, 420px) !important;
    max-width:420px;
  }
.gamestats-section.chart-duo .gs-chart-square {
  max-width:420px;
}
}
.shotmap-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
.shotmap-meta {
  display:flex;
  align-items:center;
  gap:10px;
  color:var(--muted,#79839a);
  font-size:13px;
}
#panel-shotmap {
  gap:18px;
}
#panel-shotmap.panel.active {
  display:flex;
  flex-direction:column;
}
#panel-predictions {
  gap:18px;
}
#panel-predictions.panel.active {
  display:flex;
  flex-direction:column;
}
.shotmap-layout {
  display:grid;
  grid-template-columns:280px minmax(420px, 1fr) 280px;
  gap:18px;
}
@media (max-width: 1200px) {
  .shotmap-layout {
    grid-template-columns:260px minmax(0, 1fr);
  }
  .shotmap-stats {
    grid-column:1 / -1;
    order:3;
  }
}
@media (max-width: 880px) {
  .shotmap-layout {
    grid-template-columns:1fr;
  }
  .shotmap-filter,
  .shotmap-center,
  .shotmap-stats {
    grid-column:1 / -1;
  }
}
.shotmap-filter,
.shotmap-center,
.shotmap-stats {
  background:var(--card,#1b2130);
  border:1px solid var(--border,#2a3448);
  border-radius:14px;
  padding:16px;
  display:flex;
  flex-direction:column;
  gap:14px;
}
.shotmap-filter h3,
.shotmap-stats h3 {
  font-size:15px;
  margin:0;
  font-weight:600;
  color:var(--text,#e9edf6);
}
.shotmap-filter .shotmap-group {
  display:grid;
  gap:10px;
}
.shotmap-filter label {
  display:flex;
  flex-direction:column;
  gap:6px;
  font-size:13px;
  color:var(--muted,#79839a);
}
.shotmap-filter select,
.shotmap-filter input[type="range"] {
  width:100%;
}
.shotmap-filter .shotmap-inline {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.shotmap-filter .shotmap-inline span {
  font-size:12px;
  color:var(--muted,#79839a);
}
.shotmap-filter button {
  width:100%;
}
.shot-stage {
  position:relative;
  width:100%;
  max-width:560px;
  margin:0 auto;
  border-radius:16px;
  background:rgba(10,13,18,0.85);
  border:1px solid rgba(80,100,140,0.35);
  overflow:hidden;
  aspect-ratio:500 / 470;
  min-height:240px;
  box-shadow:0 20px 40px rgba(0,0,0,0.28);
}
.shot-stage-layer {
  position:absolute;
  inset:0;
}
#shot-canvas {
  width:100%;
  height:100%;
}
.shot-badges {
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.shot-badges .badge {
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  background:rgba(20,24,34,0.8);
  border:1px solid rgba(90,120,160,0.35);
  border-radius:999px;
  font-size:12px;
  color:#dce6ff;
}
.shot-legend {
  display:flex;
  flex-wrap:wrap;
  gap:16px;
  align-items:center;
  font-size:12px;
  color:var(--muted,#79839a);
}
.shot-legend .dot,
.shot-legend .ring,
.shot-legend .swatch {
  display:inline-block;
  vertical-align:middle;
}
.shot-legend .dot {
  width:12px;
  height:12px;
  border-radius:50%;
}
.shot-legend .ring {
  width:12px;
  height:12px;
  border-radius:50%;
  border:2px solid #ccd6ff;
  box-sizing:border-box;
}
.shot-legend .swatch {
  width:180px;
  height:12px;
  border-radius:999px;
  border:1px solid rgba(160,180,220,0.4);
}
.shotmap-stats .card-section {
  background:rgba(14,18,26,0.75);
  border:1px solid rgba(80,110,150,0.3);
  border-radius:12px;
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:12px;
}
.shotmap-stats .card-section h4 {
  margin:0;
  font-size:13px;
  font-weight:600;
  color:#dce6ff;
}
#shot-aggKvs {
  display:grid;
  grid-template-columns:1fr auto;
  gap:6px 12px;
  font-size:12px;
}
#shot-aggKvs div:nth-child(2n) {
  text-align:right;
  font-variant-numeric:tabular-nums;
  color:#f2f6ff;
}
.shot-dist-bars {
  display:grid;
  gap:10px;
}
.shot-dist-bar {
  display:grid;
  grid-template-columns:120px 1fr 50px;
  gap:10px;
  align-items:center;
  font-size:12px;
}
.shot-dist-track {
  height:10px;
  border-radius:999px;
  background:rgba(30,38,60,0.8);
  border:1px solid rgba(80,110,150,0.4);
  overflow:hidden;
}
.shot-dist-fill {
  height:100%;
  background:linear-gradient(90deg,#4aa8ff,#8ad5ff);
}
.shot-tip {
  position:fixed;
  z-index:9999;
  pointer-events:none;
  background:rgba(8,12,20,0.92);
  color:#eef6ff;
  font-size:12px;
  line-height:1.3;
  padding:6px 9px;
  border-radius:8px;
  box-shadow:0 12px 30px rgba(0,0,0,0.45);
  transform:translate(-50%,-120%);
  opacity:0;
  transition:opacity .12s ease;
  white-space:nowrap;
}
.home-session-list {
  list-style:none;
  padding:0;
  margin:8px 0 0;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.home-session-list li {
  border-bottom:1px solid rgba(255,255,255,0.06);
  padding-bottom:6px;
}
.home-session-list li:last-child { border-bottom:none; }
.upcoming-list {
  display:flex;
  flex-direction:column;
  gap:10px;
}
.upcoming-item {
  border:1px solid rgba(74,168,255,0.35);
  background:rgba(74,168,255,0.1);
  border-radius:12px;
  padding:10px;
}

#mobileNavOverlay {
  display:none;
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.45);
  z-index:90;
}
body.mobile-nav-open #mobileNavOverlay { display:block; }
@media (min-width: 961px){
  #mobileNavOverlay { display:none !important; }
}

@media (max-width: 960px) {
  body { padding-bottom:72px; }
  #sideNav {
    width:240px;
    transform:translateX(-110%);
    pointer-events:none;
    box-shadow:0 18px 40px rgba(0,0,0,0.45);
    transition:transform .25s ease;
    opacity:0;
  }
  body.mobile-nav-open #sideNav {
    transform:translateX(0);
    pointer-events:auto;
    opacity:1;
  }
  body.mobile-nav-open { overflow:hidden; }
  body.sidebar-enabled .panel,
  body.sidebar-enabled .tabs {
    margin-left:0 !important;
  }
  .panel {
    border-radius:18px;
    padding:16px;
    margin:16px 12px;
    box-shadow:0 16px 32px rgba(0,0,0,0.35);
  }
  .panel:first-of-type { margin-top:18px; }
  .card {
    border-radius:16px;
    padding:14px;
  }
  .ratingsWrap,
  .table-wrap,
  #clipModalFooter {
    overflow:auto;
    -webkit-overflow-scrolling:touch;
  }
  table { min-width:600px; }
  #rtTable { min-width:100%; }
  #teamBox {
    grid-template-columns:1fr !important;
  }
  .grid.g2,
  .grid.g3 {
    grid-template-columns:1fr !important;
  }
  .mobile-tabbar {
    display:grid;
  }
}

@media (max-width: 640px) {
  .panel {
    padding:14px;
    margin:14px 10px;
  }
  .card { padding:12px; }
  h1 { font-size:20px; }
  h2 { font-size:16px; }
  .grid { gap:12px; }
  .chat-thread { height:46vh; }
}

@media (max-width: 500px) {
  .mobile-tabbar button { padding:10px 6px; font-size:16px; }
  .mobile-tabbar button span { display:none; }
}
.wrap-fluid { width:100%; }

/* Tabs */
.tabs { display:flex; gap:8px; margin-bottom:16px; border-bottom:1px solid var(--border); }
.tab { padding:10px 14px; cursor:pointer; border:1px solid var(--border); border-bottom:none; background:var(--panel); color:var(--muted); border-top-left-radius:10px; border-top-right-radius:10px; transition:background .2s ease; }
.tab.active { background:var(--card); color:var(--text); font-weight:600; }
.panel { display:none; background:var(--card); border:1px solid var(--border); border-radius:12px; padding:18px; }
.panel.active { display:block; }

      /* Layout */
      .grid { display:grid; gap:16px; }
      .g2 { grid-template-columns: minmax(0, 320px) minmax(0, 1fr); }
      .grid > * { min-width: 0; }
      .card { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:14px; }

      h1 { font-size:20px; margin:0 0 6px; }
      h2 { font-size:16px; margin:16px 0 8px; }
      .muted { color:var(--muted); }
      .tag { display:inline-block; padding:4px 8px; background:var(--chip); border:1px solid var(--border); border-radius:999px; margin:2px 4px 2px 0; font-size:12px; color:#cbd6ee; }
      .sectionTitle { font-weight:700; margin:16px 0 6px; }

      /* Player sidebar */
      .avatar { width:160px; height:160px; border-radius:12px; object-fit:cover; display:none; box-shadow:0 2px 10px rgba(0,0,0,.35); border:1px solid var(--border); }
      /* Player Library Grid */
      #panel-players {
        padding: 0 !important;
        margin: 0 !important;
        display: none;
        flex-direction: column;
        width: 100%;
        height: calc(100vh);
        min-height: calc(100vh);
        max-width: none !important;
        border-radius: 0 !important;
        border: none !important;
        overflow: hidden;
        background: var(--panel) !important;
        position: relative;
      }
      #panel-players.active {
        display: flex !important;
      }
      .player-library-grid {
        display: grid !important;
        visibility: visible !important;
        opacity: 1 !important;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        padding: 20px 20px 20px calc(var(--sidebar-w) + var(--sidebar-gap) + 20px);
        overflow-y: auto;
        overflow-x: visible;
        flex: 1;
        min-height: 0;
        width: 100% !important;
        box-sizing: border-box;
        background: transparent;
      }
      body.sidebar-collapsed .player-library-grid {
        padding-left: calc(var(--sidebar-w-collapsed) + var(--sidebar-gap) + 20px);
      }
      #panel-players.active .player-library-grid {
        display: grid !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      .player-card {
        background: var(--card);
        border: 2px solid var(--border);
        border-radius: 16px;
        padding: 16px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        position: relative;
      }
      .player-card:hover {
        border-color: rgba(74, 168, 255, 0.6);
        box-shadow: 0 4px 16px rgba(74, 168, 255, 0.2);
        transform: translateY(-2px);
      }
      .player-card-ranking {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(74, 168, 255, 0.9);
        color: white;
        font-weight: 700;
        font-size: 14px;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        z-index: 2;
      }
      .player-card-ranking.top-3 {
        background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
      }
      .player-card-ranking.bottom-3 {
        background: rgba(255, 90, 95, 0.9);
        color: white;
      }
      .player-card-photo {
        width: 140px;
        height: 140px;
        border-radius: 12px;
        object-fit: cover;
        border: 3px solid var(--border);
        background: var(--bg-secondary);
        transition: all 0.3s ease;
      }
      .player-card-no-photo {
        width: 140px;
        height: 140px;
        border-radius: 12px;
        background: var(--bg-secondary);
        border: 3px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 48px;
      }
      .player-card-name {
        font-weight: 600;
        font-size: 16px;
        color: var(--text);
        margin: 0;
        word-break: break-word;
        line-height: 1.3;
      }
      .player-card-game-stats {
        font-size: 11px;
        color: var(--muted);
        margin-top: 6px;
        text-align: center;
        line-height: 1.6;
        display: flex;
        flex-direction: column;
        gap: 3px;
      }
      .player-card-game-stats-item {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }
      .player-card-game-stats-label {
        color: var(--muted);
        font-weight: 500;
      }
      .player-card-game-stats-value {
        font-weight: 600;
        color: var(--text);
      }
      .player-card-traits {
        font-size: 11px;
        color: var(--muted);
        margin-top: 4px;
        text-align: center;
        line-height: 1.5;
      }
      .player-card-traits-item {
        display: inline-block;
        margin: 0 4px;
      }
      .player-card-traits-label {
        color: var(--muted);
        font-weight: 500;
      }
      .player-card-traits-value {
        font-weight: 600;
        color: var(--text);
      }
      .player-card-traits-strongest {
        color: #10b981;
      }
      .player-card-traits-weakest {
        color: #ef4444;
      }
      @media (max-width: 768px) {
        .player-library-grid {
          grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
          gap: 16px;
          padding: 16px;
        }
        .player-card-photo {
          width: 120px;
          height: 120px;
        }
        .player-card-no-photo {
          width: 120px;
          height: 120px;
          font-size: 40px;
        }
      }
      .player-detail-modal {
        animation: fadeIn 0.2s ease;
      }
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .select { width:100%; padding:10px; border-radius:10px; background:#0f131a; color:var(--text); border:1px solid var(--border); }
      .kv { display:grid; grid-template-columns: 120px 1fr; gap:8px 12px; margin-top:10px; }
      .kv div:nth-child(odd){ color:#b8c4dd; }
      ul { margin:6px 0 0 18px; padding:0; }
      li { margin:4px 0; }

      #flagsTable td.num { font-size: 15px; }
      .card { max-width: 100%; overflow: hidden; }
#panel-players .card, #panel-players ul, #panel-players li { word-break: break-word; overflow-wrap: anywhere; }
.player-shot-wrap {
  display:flex;
  flex-direction:column;
  gap:8px;
  padding:10px;
  border-radius:12px;
  background:rgba(12,18,28,0.85);
  border:1px solid rgba(74,168,255,0.2);
  margin-top:10px;
}
#pShotCanvas {
  width:100%;
  height:auto;
  max-width:360px;
  align-self:center;
  border-radius:8px;
  background:#0c121c;
  box-shadow:0 10px 26px rgba(0,0,0,0.25);
}
.trait-modal {
  display:none;
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.78);
  z-index:36000;
  align-items:center;
  justify-content:center;
  padding:24px;
}
.trait-modal.active {
  display:flex;
}
#traitModalCard {
  width:90%;
  max-width:1100px;
  background:#14181f;
  border:1px solid #2a3448;
  border-radius:14px;
  box-shadow:0 28px 60px rgba(0,0,0,0.55);
  display:flex;
  flex-direction:column;
  max-height:90vh;
}
#traitModalHeader {
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:18px 20px;
  border-bottom:1px solid rgba(74,168,255,0.18);
}
#traitModalHeader h2 {
  margin:0;
  font-size:20px;
  font-weight:600;
  letter-spacing:0.3px;
}
#traitModalBody {
  padding:18px 20px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:14px;
}
#traitModalClose {
  border:0;
  background:none;
  color:#f2f6ff;
  font-size:24px;
  cursor:pointer;
  line-height:1;
}

      .embedWrap{
        position:relative;
        width:100%;
        aspect-ratio:16/9;
        background:#0f131a;
        border:1px solid var(--border);
        border-radius:10px;
        overflow:hidden;
      }
      .embedWrap iframe{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        border:0;
      }

      #flagsTable th { text-align: center; }

      /* Clip list */
      .clip { border-bottom:1px dashed var(--border); padding:8px 0; }
      .clip:last-child { border-bottom:none; }
      .clip a { color:var(--accent); text-decoration:none; }
      .clip a:hover { text-decoration:underline; }
      .clipLine { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

      /* Filters row */
      .filters { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px; }
      .filters select, .filters input { padding:8px 10px; border-radius:10px; background:#0f131a; color:var(--text); border:1px solid var(--border); }
      .btn { padding:9px 12px; border-radius:10px; background:var(--accent); color:#051423; border:0; cursor:pointer; font-weight:700; }
      .btn:disabled { opacity:.5; cursor:not-allowed; }

      /* Small progress bars (monospace) */
      .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }

      /* Empty states */
      .empty { color:#9aa6bf; background:#10141c; border:1px dashed var(--border); border-radius:10px; padding:16px; }

      /* Ratings table */
      table { width:100%; border-collapse: collapse; max-width: 100%; }
      #ratingsTable { width: 100%; max-width: 100%; table-layout: auto; }
      th, td { padding:8px; border-bottom:1px solid var(--border); text-align:left; }
      th { position:sticky; top:0; background:var(--panel); z-index:1; }
      .num { text-align:center; font-variant-numeric: tabular-nums; }
      .stickyLeft { position:sticky; left:0; background:var(--panel); z-index:2; }
      .ratingsWrap {
  max-height: 70vh;            /* add this for vertical freeze */
  overflow: auto;
  border: 1px solid var(--border);
  border-radius: 12px;
  width: 100%;
  box-sizing: border-box;
}

      .hero { display:flex; flex-direction:column; align-items:center; justify-content:center; min-height: 50vh; gap: 16px; }
      .hero-logo { width: 160px; height:160px; object-fit:cover; border-radius:16px; border:1px solid var(--border); box-shadow:0 4px 20px rgba(0,0,0,.35); }
      .hero-title { margin:0; font-size:28px; letter-spacing:.5px; }

      .btn-danger {
        padding: 9px 12px;
        border-radius: 10px;
        background: #ff5a5f;
        color: white;
        border: 0;
        cursor: pointer;
        font-weight: 700;
      }
      .btn-danger:disabled { opacity: .5; cursor: not-allowed; }

      #createSummaryModal .grid label { display: flex; flex-direction: column; gap: 6px; width: 100%; }
      #createSummaryModal .grid input, #createSummaryModal .grid select, #createSummaryModal .grid textarea {
        max-width: 100%; box-sizing: border-box;
      }
      #createSummaryModal select { height: 38px; line-height: 1.3; font-size: 14px; }
      #createSummaryModal #sumDescription { grid-column: 1 / span 2; }



  .stat-bullet { display:flex; align-items:center; gap:10px; margin:6px 0; }
  .stat-label  { width:90px; color:var(--muted,#9aa4ad); }
  .stat-track  { position:relative; height:10px; width:260px; border-radius:999px; overflow:hidden; }
  .stat-dot    { position:absolute; top:50%; width:12px; height:12px; border-radius:50%;
                 transform:translate(-50%,-50%); border:1px solid rgba(0,0,0,.25); background:#fff; }
  .stat-tick   { position:absolute; top:50%; width:2px; height:14px; transform:translate(-50%,-50%);
                 background:rgba(255,255,255,.85); border-radius:2px; }
  .stat-meta   { display:flex; gap:10px; margin-left:auto; min-width:160px; justify-content:flex-end; }
  .chip        { padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border,#283241); }


/* Colored result text */
.result-win  { color: var(--ok, #2ecc71); font-weight: 600; }
.result-loss { color: var(--bad, #ff5a5f); font-weight: 600; }
.result-upcoming { color: var(--muted, #79839a); font-style: italic; }

/* Schedule pills */
.sched-pill{
  display:inline-block;
  vertical-align:top;
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:10px;
  padding:8px 10px;
  margin-right:8px;
  min-width: 210px;
  max-width: 260px;
  white-space:normal;
  cursor:pointer;
  transition:transform .08s ease, box-shadow .12s ease;
}
.sched-pill:hover{ transform:translateY(-1px); box-shadow:0 2px 10px rgba(0,0,0,.25); }
.sched-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:12px; color:var(--muted); }
.sched-title{ font-weight:700; margin-top:4px; }
.sched-venue{ font-size:11px; color:var(--muted); }
.sched-badges{ display:flex; gap:6px; margin-top:6px; align-items:center; }
.sched-chip{ font-size:11px; padding:2px 6px; border:1px solid var(--border); border-radius:999px; }
.sched-pppbar{ position:relative; height:4px; border-radius:999px; background:#0f131a; margin-top:8px; overflow:hidden; }
.sched-pppbar > div{ position:absolute; top:0; bottom:0; }
.sched-pill.win { border-color: rgba(46,204,113,.45); }
.sched-pill.loss{ border-color: rgba(255,90,95,.45); }
.sched-pill.next{ outline:2px solid rgba(74,168,255,.45); }

.sched-chip.home { border-color:rgba(74,168,255,.4); }
.sched-chip.away { border-color:rgba(255,176,32,.4); }
.sched-chip.heba { border-color:#4aa8ff44; }
.sched-chip.fiba { border-color:#10b98155; }

/* Detail drawer */
#schedDetail .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
@media (max-width:640px){ #schedDetail .grid{ grid-template-columns:1fr; } }








/* Sidebar presence list */
.sidePresence{
  margin:8px;
  margin-top:12px;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid rgba(70,82,104,0.55);
  background:rgba(12,16,24,0.6);
  display:flex;
  flex-direction:column;
  gap:8px;
}
.sidePresenceHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-size:12px;
  color:#9aa5be;
}
.sidePresenceList{
  max-height:160px;
  overflow:auto;
  display:flex;
  flex-wrap:wrap;
  gap:6px;
}
.presence-badge{
  display:inline-block;
  padding:4px 9px;
  border-radius:999px;
  font-weight:600;
  background:#ff5a5f;
  color:white;
  font-size:12px;
}
.presence-empty{ color:#9aa6bf; font-size:12px; }
.presence-btn{
  background:transparent;
  border:0;
  color:#9aa6bf;
  cursor:pointer;
  font-weight:700;
  font-size:12px;
}


/* Coach notification toast – bottom-right, compact */
#coachNotify {
  position: fixed;
  bottom: 16px;
  right: 16px;

  /* IMPORTANT: prevent stretching */
  top: auto !important;
  left: auto !important;
  width: auto !important;
  max-width: 360px;

  z-index: 10020;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
  padding: 10px 12px;
  display: none;           /* set to block when showing */
}


/* Insights container → responsive grid */
.pl-insights {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* 2–4 per row depending on width */
  gap: 8px;
  margin-top: 6px;
  align-items: stretch;
}

/* Insight cards */
.insight {
  background: #fff;
  border: 1px solid #e5e7eb;
  border-left: 4px solid #60a5fa; /* default = info */
  border-radius: 10px;
  padding: 8px 10px;
  box-shadow: 0 1px 2px rgba(0,0,0,.05);
  box-sizing: border-box;
}

.insight-title {
  font-weight: 600;
  margin-bottom: 4px;
  color: #111827;
  font-size: 13px;
}

.insight-body {
  font-size: 13px;
  line-height: 1.35;
  color: #374151;
}

/* Kinds (match your JS: success|info|warn|error) */
.insight.success { border-left-color: #10b981; } /* green */
.insight.info    { border-left-color: #3b82f6; } /* blue */
.insight.warn    { border-left-color: #f59e0b; } /* amber */
.insight.error   { border-left-color: #ef4444; } /* red */

/* Optional: compact on very small screens */
@media (max-width: 420px) {
  .pl-insights { grid-template-columns: 1fr; }
}


/* ===== Mobile tweaks ===== */
@media (max-width: 820px) {
  .wrap { padding: 16px; }

  /* Tabs: make them scrollable chips across the top */
  .tabs {
    gap: 6px;
    overflow-x: auto;
    white-space: nowrap;
    padding: 0 8px 8px;
    scrollbar-width: none;
  }
  .tabs::-webkit-scrollbar { display: none; }
  .tab {
    padding: 8px 12px;
    font-size: 13px;
    border-radius: 999px;
  }

  /* Panels and cards tighter on mobile */
  .panel { padding: 12px; }
  .card  { padding: 12px; }

  /* Two-column → one column */
  .g2 { grid-template-columns: 1fr; }

  /* Player photo smaller */
  .avatar { width: 120px; height: 120px; }

  /* Ratings tables: allow horizontal scroll */
  .ratingsWrap { overflow: auto; width: 100%; }
  #ratingsTable { width: 100%; min-width: 100%; }
  table { min-width: 680px; } /* keep columns usable; scroll on small */

  /* Filters: stack vertically */
  .filters {
    gap: 6px;
    flex-direction: column;
    align-items: stretch;
  }
  .filters select, .filters input, .filters .btn, .filters .btn-danger {
    width: 100%;
  }

  /* Embed/video: full width & sane height */
  .embedWrap { aspect-ratio: 16/9; }

  /* Coach notify toast: fit width, respect safe areas */
  #coachNotify {
    right: max(12px, env(safe-area-inset-right));
    left: max(12px, env(safe-area-inset-left));
    bottom: max(12px, env(safe-area-inset-bottom));
    max-width: none;
    width: auto;
  }

  /* Login overlay box: fill nicely on phones */
  #loginOverlay > div { max-width: 360px; width: 92%; }
  /* Ensure login overlay is properly hidden */
  #loginOverlay.hidden { display: none !important; visibility: hidden !important; pointer-events: none !important; }
  /* Ensure buttons are always clickable */
  button, .btn { cursor: pointer !important; pointer-events: auto !important; }
  button:disabled, .btn:disabled { cursor: not-allowed !important; opacity: 0.5; }
  /* Ensure sidebar items are clickable */
  #sideNav .sideItem { cursor: pointer !important; pointer-events: auto !important; user-select: none; }
  #mobileTabbar button { cursor: pointer !important; pointer-events: auto !important; }
}

/* Global fixes for button responsiveness */
button, .btn, .btn-danger {
  cursor: pointer !important;
  pointer-events: auto !important;
  position: relative; /* Ensure buttons are in stacking context */
  z-index: 1; /* Ensure buttons are above background elements */
}

button:disabled, .btn:disabled {
  cursor: not-allowed !important;
  opacity: 0.5;
  pointer-events: none !important;
}

/* Ensure sidebar navigation is always clickable */
#sideNav .sideItem {
  cursor: pointer !important;
  pointer-events: auto !important;
  position: relative;
  z-index: 1;
}

#sideNav .sideSectionHeader {
  cursor: pointer !important;
  pointer-events: auto !important;
}

/* Ensure mobile tabbar buttons work */
#mobileTabbar button {
  cursor: pointer !important;
  pointer-events: auto !important;
  position: relative;
  z-index: 1;
}

/* Bigger tap targets (nice on touch) */
button, .btn, .btn-danger, .presence-btn {
  min-height: 38px;
}

/* Prevent accidental zoom on iOS when tapping inputs */
input, select, textarea { font-size: 16px; }



body.player-only .tabs { display: none; }
body.player-only #panel-opponents { display: block; }
body.player-only #presenceWidget,
body.player-only #coachNotify { display: none !important; }


/* Player mode: make Opponents layout tight and centered */
body.player-only .tabs { display: none; }
body.player-only #panel-opponents { display: block; }
body.player-only .wrap { max-width: 900px; }


/* Freeze header row */
#ratingsTable thead th {
  position: sticky;
  top: 0;
  background: var(--panel);
  z-index: 5;          /* above body cells */
}

/* Freeze first column (you already add .stickyLeft in JS) */
#ratingsTable td.stickyLeft {
  position: sticky;
  left: 0;
  background: var(--panel);
  z-index: 4;          /* below header-left cell, above normal cells */
}

/* Top-left corner cell (header + first column) */
#ratingsTable th.stickyLeft {
  left: 0;
  z-index: 6;          /* highest so it sits on top */
}



/* --- Stats table visual cleanup --- */
#statsPlayersTable {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed; /* key for equal cell width */
  font-size: 13px;
}

#statsPlayersTable th,
#statsPlayersTable td {
  padding: 6px 4px;
  text-align: center; /* center all text */
  border-bottom: 1px solid var(--border, #ddd);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Left-align the player name only */
#statsPlayersTable th:first-child,
#statsPlayersTable td:first-child {
  text-align: left;
}

/* Slight background banding */
#statsPlayersTable tr:nth-child(even) {
  background: rgba(0, 0, 0, 0.02);
}

/* Smooth hover highlight */
#statsPlayersTable tr:hover {
  background: rgba(0, 128, 255, 0.08);
  transition: background 0.15s ease;
}

/* Make numeric columns all equal width */
#statsPlayersTable th:not(:first-child),
#statsPlayersTable td:not(:first-child) {
  width: 5.3%; /* tweak this to balance columns on your layout */
}






#alignTable {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
}

#alignTable th, #alignTable td {
  padding: 8px 10px;
  border-bottom: 1px solid var(--border);
  font-size: 13px;
  vertical-align: middle;
}

#alignTable th {
  color: var(--text-muted);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

#alignTable th.left,
#alignTable td.trait {
  text-align: left;
  font-weight: 500;
  color: var(--text);
}

#alignTable th.right,
#alignTable td.num {
  text-align: right;
  font-variant-numeric: tabular-nums;
  color: var(--text);
}

#alignTable td.diff {
  font-weight: 600;
}

#alignTable tr:last-child td {
  border-bottom: none;
}


/* Tiny button style (home header) */
.btn.btn-small { height:28px; padding:0 10px; font-size:12px; border-radius:8px; }

/* Modal shell */
.modal {
  position: fixed; inset: 0;
  background: rgba(0,0,0,.55);
  display: none; align-items: center; justify-content: center;
  z-index: 1000;
}
.modal-card {
  width: min(1000px, 96vw);
  max-height: 88vh;
  overflow: hidden;
  background: var(--bg, #14181f);
  border: 1px solid var(--border, #2a3441);
  border-radius: 14px;
  box-shadow: 0 20px 60px rgba(0,0,0,.6);
  display: flex; flex-direction: column;
}
.modal-card > header {
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 12px; border-bottom:1px solid var(--border);
  font-weight:600;
}
.modal-card > header .icon {
  background: transparent; border: 1px solid var(--border);
  color: var(--text,#e6e6e6); border-radius:10px; padding:4px 8px; cursor:pointer;
}
.modal-body { padding:10px; overflow:auto; }

/* Form strip */
.rate-form {
  display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap: wrap;
}
.rate-form label { display:flex; flex-direction:column; gap:6px; min-width:180px; }
.rate-form label > span { font-size:12px; color: var(--muted,#9aa7b4); }
.rate-form select, .rate-form input[type="date"] {
  height:34px; border-radius:10px; border:1px solid var(--border);
  background: var(--bg2,#161b22); color: var(--text,#e6e6e6); padding:0 10px; font-size:13px;
}
.rate-form .apply { margin-left:auto; }
.rate-form .grow { flex:1 1 auto; }

/* Quick fill */
.rate-quickfill { display:flex; gap:8px; align-items:center; margin:6px 0 10px; }
.rate-quickfill select, .rate-quickfill .btn {
  height:32px; border-radius:10px; border:1px solid var(--border);
  background: var(--bg2,#161b22); color: var(--text,#e6e6e6); padding:0 10px; font-size:13px;
}

/* Ratings table */
.rate-table {
  border:1px solid var(--border);
  border-radius:14px;
  background:linear-gradient(145deg, rgba(27,33,44,.96), rgba(17,21,28,.94));
  box-shadow:0 12px 40px rgba(0,0,0,.45);
  overflow:hidden;
  display:flex;
  flex-direction:column;
}
.rate-table-scroll {
  max-height:55vh;
  overflow:auto;
  position:relative;
}
.rate-table-scroll::-webkit-scrollbar { width:11px; }
.rate-table-scroll::-webkit-scrollbar-track { background:rgba(12,16,22,.6); }
.rate-table-scroll::-webkit-scrollbar-thumb {
  background:rgba(70,104,160,.55);
  border-radius:999px;
}
.rate-table-scroll::-webkit-scrollbar-thumb:hover { background:rgba(90,130,190,.65); }
.rate-table-hint {
  padding:10px 14px;
  border-bottom:1px solid rgba(255,255,255,0.07);
  font-size:12px;
  color:var(--muted,#97a4c0);
  display:flex;
  gap:10px;
  align-items:center;
}
.rate-table-hint svg {
  width:16px; height:16px; flex-shrink:0; fill:var(--muted,#97a4c0);
}
#rtTable {
  width:100%;
  border-collapse:separate;
  border-spacing:0;
  table-layout:fixed;
}
#rtTable thead th,
#rtTable tbody td,
#rtTable tbody th {
  padding:12px 14px;
  border-bottom:1px solid rgba(255,255,255,0.06);
  vertical-align:top;
}
#rtTable thead th {
  position:sticky;
  top:0;
  background:rgba(20,25,34,.97);
  backdrop-filter:blur(6px);
  z-index:4;
  text-transform:uppercase;
  letter-spacing:0.4px;
  font-size:12px;
  font-weight:600;
  color:#cdd8f8;
}
#rtTable thead th[data-tip] {
  cursor:help;
}
#rtTable thead th::after {
  content:'';
  position:absolute;
  left:0;
  right:0;
  bottom:0;
  height:1px;
  background:rgba(0,0,0,0.35);
}
#rtTable thead th.player-col {
  left:0;
  z-index:6;
  min-width:200px;
  box-shadow:inset -1px 0 0 rgba(255,255,255,0.06);
}
#rtTable tbody th.rt-player {
  position:sticky;
  left:0;
  z-index:5;
  background:rgba(20,25,34,.95);
  font-weight:600;
  color:var(--text);
  text-align:left;
  min-width:190px;
  box-shadow:inset -1px 0 0 rgba(255,255,255,0.04);
  font-size:13px;
}
#rtTable tbody tr:nth-child(even) { background:rgba(255,255,255,0.025); }
#rtTable tbody tr:hover { background:rgba(74,168,255,0.08); }
#rtTable tbody tr:last-child td,
#rtTable tbody tr:last-child th { border-bottom:none; }
#rtTable tbody tr.rt-empty td {
  padding:32px 0;
  text-align:center;
  font-size:13px;
  color:var(--muted,#97a4c0);
}
.rt-player-name {
  display:flex;
  align-items:center;
  gap:6px;
  line-height:1.4;
}
.rt-score {
  text-align:center;
  width:82px;
}
.rt-note-cell {
  min-width:360px;
  width:100%;
}
#rtTable select {
  height:34px;
  min-width:60px;
  border-radius:8px;
  border:1px solid rgba(86,105,132,.6);
  background:rgba(17,23,33,.9);
  color:var(--text,#e6e6e6);
  padding:0 10px;
  font-size:13px;
  appearance:none;
  transition:border-color .2s ease, box-shadow .2s ease;
  background-image: linear-gradient(45deg, transparent 50%, #4aa8ff 50%), linear-gradient(135deg, #4aa8ff 50%, transparent 50%);
  background-position: calc(100% - 16px) calc(50% - 4px), calc(100% - 10px) calc(50% - 4px);
  background-size:6px 6px, 6px 6px;
  background-repeat:no-repeat;
}
#rtTable select:focus {
  outline:none;
  border-color:var(--accent,#4aa8ff);
  box-shadow:0 0 0 2px rgba(74,168,255,0.25);
  background-color:rgba(19,26,36,.95);
}
#rtTable textarea {
  width:100%;
  min-height:72px;
  resize:vertical;
  border-radius:10px;
  border:1px solid rgba(86,105,132,.55);
  background:rgba(18,24,33,.92);
  color:var(--text,#e6e6e6);
  padding:8px 10px;
  font-size:13px;
  transition:border-color .2s ease, box-shadow .2s ease;
}
#rtTable textarea::placeholder {
  color:rgba(197,210,234,0.55);
}
#rtTable textarea:focus {
  outline:none;
  border-color:var(--accent,#4aa8ff);
  box-shadow:0 0 0 2px rgba(74,168,255,0.22);
  background:rgba(20,27,38,.96);
}
.trait-tooltip {
  position:fixed;
  max-width:260px;
  background:rgba(23,32,48,0.95);
  color:#eef3ff;
  padding:10px 12px;
  border-radius:10px;
  font-size:12px;
  line-height:1.5;
  box-shadow:0 14px 36px rgba(0,0,0,0.5);
  pointer-events:none;
  opacity:0;
  transform:translate(-50%, -4px) scale(0.96);
  transition:opacity 120ms ease, transform 120ms ease;
  z-index:9999;
}
.trait-tooltip.is-visible {
  opacity:1;
  transform:translate(-50%, -12px) scale(1);
}
.rate-message {
  margin-top:10px;
  font-size:13px;
  min-height:18px;
}

@media (max-width: 720px) {
  .rate-table-scroll { max-height:60vh; }
  #rtTable thead th,
  #rtTable tbody td,
  #rtTable tbody th { padding:10px 12px; }
  #rtTable select { min-width:52px; font-size:12px; }
  #rtTable textarea { font-size:12px; }
}

/* Coach chat */
.chat-shell {
  max-width: 860px;
  margin: 0 auto;
  background: linear-gradient(140deg, rgba(20,24,32,0.92), rgba(12,16,24,0.92));
  border-radius: 18px;
  border: 1px solid rgba(78,106,150,0.35);
  box-shadow: 0 18px 45px rgba(0,0,0,0.55);
  padding: 18px 20px 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.chat-header {
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:14px;
}
.chat-header h2 {
  margin:0;
  font-size:20px;
  letter-spacing:0.6px;
}
.chat-header p {
  margin:4px 0 0;
  color:var(--muted,#99a7c7);
  font-size:13px;
}
.chat-refresh {
  border:1px solid rgba(74,168,255,0.5);
  background:rgba(74,168,255,0.12);
  color:#a7cfff;
  border-radius:10px;
  padding:6px 12px;
  font-weight:600;
  cursor:pointer;
  transition:background .2s ease, transform .1s ease;
}
.chat-refresh:hover {
  background:rgba(74,168,255,0.2);
  transform:translateY(-1px);
}
.chat-controls {
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  align-items:center;
}
.chat-control-group {
  display:flex;
  flex-direction:column;
  gap:4px;
  font-size:11px;
  text-transform:uppercase;
  letter-spacing:0.4px;
  color:var(--muted,#97a4c0);
}
.chat-label {
  font-size:11px;
  letter-spacing:0.4px;
}
.chat-target-select {
  min-width:220px;
  height:38px;
  border-radius:10px;
  border:1px solid rgba(86,105,132,0.6);
  background:rgba(15,19,28,0.95);
  color:var(--text,#e6e6e6);
  padding:0 12px;
  font-size:13px;
  appearance:auto;
  -webkit-appearance:menulist;
  transition:border-color .2s ease, box-shadow .2s ease;
  cursor:pointer;
}
.chat-target-select:focus {
  outline:none;
  border-color:var(--accent,#4aa8ff);
  box-shadow:0 0 0 2px rgba(74,168,255,0.25);
  background:rgba(19,24,34,0.98);
}
.chat-thread {
  height:48vh;
  overflow:auto;
  border-radius:14px;
  padding:18px 18px 14px;
  background:rgba(9,12,20,0.78);
  border:1px solid rgba(60,84,120,0.35);
  display:flex;
  flex-direction:column;
  gap:14px;
  scroll-behavior:smooth;
}
.chat-thread::-webkit-scrollbar { width:12px; }
.chat-thread::-webkit-scrollbar-track { background:rgba(8,11,18,0.85); }
.chat-thread::-webkit-scrollbar-thumb {
  background:rgba(94,128,190,0.55);
  border-radius:999px;
}
.chat-thread::-webkit-scrollbar-thumb:hover {
  background:rgba(118,152,212,0.65);
}
.chat-empty {
  text-align:center;
  color:var(--muted,#96a3c8);
  font-size:13px;
  padding:40px 0;
}
.chat-divider {
  text-align:center;
  font-size:11px;
  color:rgba(177,193,223,0.6);
  letter-spacing:0.4px;
  text-transform:uppercase;
  display:flex;
  align-items:center;
  gap:10px;
}
.chat-divider::before,
.chat-divider::after {
  content:'';
  flex:1;
  height:1px;
  background:rgba(120,140,176,0.25);
}
.chat-row {
  display:flex;
  flex-direction:column;
  gap:6px;
  align-items:flex-start;
}
.chat-row.mine {
  align-items:flex-end;
}
.chat-meta {
  font-size:11px;
  color:rgba(166,183,217,0.7);
}
.chat-bubble {
  max-width:80%;
  padding:12px 14px;
  border-radius:12px;
  background:rgba(24,31,45,0.95);
  border:1px solid rgba(78,106,150,0.35);
  line-height:1.45;
  font-size:13px;
  box-shadow:0 10px 26px rgba(0,0,0,0.35);
  word-break:break-word;
}
.chat-row.mine .chat-bubble {
  background:linear-gradient(135deg, rgba(70,132,255,0.9), rgba(90,170,255,0.9));
  border-color:rgba(120,180,255,0.6);
  color:#06122a;
  box-shadow:0 12px 32px rgba(20,60,120,0.35);
}
.chat-message {
  white-space:pre-wrap;
}
.chat-attachments {
  margin-top:8px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.chat-attach-card {
  border:1px solid rgba(80,110,150,0.35);
  border-radius:12px;
  overflow:hidden;
  background:rgba(12,16,24,0.85);
}
.chat-attach-links {
  font-size:12px;
  color:var(--muted,#97a4c0);
  line-height:1.45;
}
.chat-attach-links a {
  color:#9fc5ff;
  text-decoration:none;
}
.chat-attach-links a:hover { text-decoration:underline; }
.chat-input {
  display:flex;
  gap:10px;
  align-items:flex-end;
  background:rgba(10,14,22,0.9);
  border:1px solid rgba(70,96,140,0.4);
  border-radius:14px;
  padding:12px;
}
.chat-textarea {
  flex:1;
  min-height:80px;
  resize:vertical;
  border-radius:12px;
  border:1px solid rgba(86,105,132,0.6);
  background:rgba(18,24,33,0.95);
  color:var(--text,#e6e6e6);
  padding:10px 12px;
  font-size:13px;
  line-height:1.45;
  transition:border-color .2s ease, box-shadow .2s ease;
}
.chat-textarea:focus {
  outline:none;
  border-color:var(--accent,#4aa8ff);
  box-shadow:0 0 0 2px rgba(74,168,255,0.23);
  background:rgba(21,28,40,0.97);
}
.chat-send {
  border:none;
  background:linear-gradient(135deg, rgba(74,168,255,0.9), rgba(134,77,255,0.9));
  color:white;
  border-radius:12px;
  padding:12px 20px;
  font-weight:700;
  cursor:pointer;
  transition:transform .1s ease, box-shadow .2s ease;
}
.chat-send:hover {
  transform:translateY(-1px);
  box-shadow:0 12px 24px rgba(74,168,255,0.35);
}
.chat-status {
  min-height:18px;
  font-size:12px;
}

@media (max-width: 720px) {
  .chat-shell { padding:16px; }
  .chat-controls { flex-direction:column; align-items:stretch; }
  .chat-target-select { width:100%; min-width:0; }
  .chat-thread { height:44vh; }
  .chat-bubble { max-width:100%; }
  .chat-input { flex-direction:column; }
  .chat-textarea { width:100%; }
  .chat-send { width:100%; }
}

/* Buttons */
.btn.apply {
  background: var(--accent,#4aa8ff); color:#0d1117; font-weight:600; border:1px solid transparent;
}
.btn.apply:hover { background:#3697f7; }
.btn { cursor:pointer; }
.muted { color: var(--muted,#9aa7b4); }

/* Archetype tooltip */
.archetype-badge {
  position: relative;
}
.archetype-badge:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 8px;
  padding: 8px 12px;
  background: rgba(20, 24, 31, 0.98);
  color: #e9edf6;
  font-size: 12px;
  line-height: 1.4;
  white-space: normal;
  width: 280px;
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  z-index: 1000;
  pointer-events: none;
  text-align: left;
}
.archetype-badge:hover::before {
  content: '';
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 2px;
  border: 6px solid transparent;
  border-top-color: var(--border);
  z-index: 1001;
  pointer-events: none;
}




/* Floating toast over the video */
/* Floating toast over the video — centered & larger */
#ytToast{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%, -50%);
  z-index: 9999;

  background: rgba(255, 176, 32, 0.95); /* warm amber */
  color:#051423;
  font-weight:800;
  border:1px solid #c98910;
  border-radius:14px;

  padding:14px 18px;
  font-size:18px;
  line-height:1.2;
  text-align:center;

  box-shadow:0 14px 36px rgba(0,0,0,.45);
  backdrop-filter: blur(4px);

  display:none;
  pointer-events:none;           /* don’t block clicks */
}


/* Team snapshot layout: bullets + compact alignment card side-by-side */
#statsTeamBox .team-snap {
  display: grid;
  grid-template-columns: 1fr minmax(260px, 360px);
  gap: 12px;
  align-items: start;
}

#statsTeamBox .team-bullets .stat-bullet { margin: 4px 0; }
#statsTeamBox .team-bullets .stat-track { width: 220px; height: 8px; }

#statsTeamBox .align-mini {
  padding: 8px 10px;
  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--panel);
  font-size: 12.5px;
}

#statsTeamBox .align-mini table { width:100%; border-collapse: collapse; }
#statsTeamBox .align-mini th,
#statsTeamBox .align-mini td {
  padding: 6px 6px;
  border-bottom: 1px solid var(--border);
}
#statsTeamBox .align-mini th { text-align: right; }
#statsTeamBox .align-mini th:first-child,
#statsTeamBox .align-mini td:first-child { text-align: left; }
#statsTeamBox .align-mini tr:last-child td { border-bottom: none; }

/* Mobile: stack vertically */
@media (max-width: 820px){
  #statsTeamBox .team-snap {
    grid-template-columns: 1fr;
  }
}



/* INSIGHTS: two+ columns, wrap nicely, responsive */
.pl-insights{
  display: grid !important;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 12px;
  align-items: stretch;
}

/* Make sure individual cards don’t expand to full width */
.pl-insights .insight{
  width: auto !important;
  box-sizing: border-box;
  border: 1px solid #e5e7eb;
  border-radius: 10px;
  padding: 10px;
  background: #fff;
  box-shadow: 0 1px 2px rgba(0,0,0,.05);
}

/* Titles & body */
.pl-insights .insight-title{
  font-weight: 600;
  margin-bottom: 6px;
}

.pl-insights .insight-body{
  color: #374151;
  line-height: 1.35;
}

/* Optional color accents by kind */
.pl-insights .insight.info{ border-left: 4px solid #3b82f6; }
.pl-insights .insight.success{ border-left: 4px solid #10b981; }
.pl-insights .insight.warn{ border-left: 4px solid #f59e0b; }
.pl-insights .insight.error{ border-left: 4px solid #ef4444; }







  /* Notes header bar */
  #notesHeader {
    display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    padding:10px; border:1px solid var(--border); border-radius:12px;
    background:rgba(255,255,255,0.03);
    margin-bottom:10px;
  }
  #notesHeader .title {
    font-weight:600; margin-right:auto;
  }
  #notesHeader .select, #notesHeader input[type="date"], #notesHeader input[type="text"] {
    min-width:160px; height:34px;
  }
  #notesHeader .btn {
    height:34px; padding:0 12px; border-radius:10px;
  }

  /* Result cards */
  .note-row {
    padding:10px 0; border-bottom:1px dashed var(--border);
    display:grid; grid-template-columns: 160px 1fr; gap:12px;
  }
  .note-meta { font-size:12px; color:var(--muted); }
  .note-text { white-space:pre-wrap; }
  .filters-line { display:flex; gap:6px; flex-wrap:wrap; margin-top:6px; }



/* --- Notes Filters (dark theme) --- */
.notes-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  margin-bottom: 10px;
}

/* Inputs & selects */
.notes-filters select,
.notes-filters input[type="text"] {
  appearance: none;
  background: var(--bg2, #161b22);
  border: 1px solid var(--border, #2a3441);
  color: var(--text, #e6e6e6);
  border-radius: 10px;
  padding: 6px 34px 6px 10px; /* room for custom caret */
  font-size: 13px;
  height: 32px;
  min-width: 140px;
  line-height: 20px;
  transition: border-color 0.2s ease, background-color 0.2s ease;
}

/* Subtle hover/focus */
.notes-filters select:hover,
.notes-filters input[type="text"]:hover {
  border-color: var(--border-strong, #3a4759);
}
.notes-filters select:focus,
.notes-filters input[type="text"]:focus {
  outline: none;
  border-color: var(--accent, #4aa8ff);
  background: var(--bg, #14181f);
}

/* Dark placeholder */
.notes-filters input[type="text"]::placeholder {
  color: #9aa7b4;
}

/* Custom dropdown caret (light chevron) */
.notes-filters select {
  background-image:
    url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3e%3cpath fill='%23c9d1d9' d='M1.06.94a.75.75 0 0 1 1.06 0L5 3.81 7.88.94a.75.75 0 1 1 1.06 1.06L5.53 5.41a.75.75 0 0 1-1.06 0L1.06 2a.75.75 0 0 1 0-1.06z'/%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 10px center;
  background-size: 10px 6px;
}

/* Hide IE arrow (legacy) */
.notes-filters select::-ms-expand { display: none; }

/* Buttons */
.notes-filters button {
  height: 32px;
  border: 1px solid transparent;
  border-radius: 10px;
  padding: 6px 14px;
  font-size: 13px;
  cursor: pointer;
  transition: background 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
}

/* Primary (Apply) */
.notes-filters button.apply {
  background: var(--accent, #4aa8ff);
  color: #0d1117;
  font-weight: 600;
}
.notes-filters button.apply:hover {
  background: #3697f7;
}

/* Ghost (Clear) */
.notes-filters button.clear {
  background: var(--bg2, #161b22);
  color: var(--text, #e6e6e6);
  border: 1px solid var(--border, #2a3441);
}
.notes-filters button.clear:hover {
  border-color: var(--border-strong, #3a4759);
}

/* Keep the pills looking consistent */
.tag {
  background: rgba(74, 168, 255, 0.15);
  border: 1px solid rgba(74, 168, 255, 0.35);
  color: #cfe8ff;
  border-radius: 999px;
  padding: 2px 8px;
  font-size: 12px;
  text-decoration: none;
}




/* Make inputs/selects reliably dark everywhere (even outside .notes-filters) */
select,
input[type="text"] {
  background: var(--bg2, #161b22);
  color: var(--text, #e6e6e6);
  border: 1px solid var(--border, #2a3441);
}

/* Global primary action button (Apply, Load more, etc.) */
button.apply,
#nMsg button.apply {
  background: var(--accent, #4aa8ff);
  color: #0d1117 !important;
  border: 1px solid #3a7fd6;
  border-radius: 10px;
  padding: 6px 14px;
  font-size: 13px;
  font-weight: 600;
  height: 32px;
  cursor: pointer;
  transition: background .15s ease, border-color .15s ease;
}
button.apply:hover,
#nMsg button.apply:hover {
  background: #3697f7;
  border-color: #2e6ec0;
}

/* Global secondary button (Clear, etc.) */
button.clear,
#nMsg button.clear {
  background: var(--bg2, #161b22);
  color: var(--text, #e6e6e6) !important;
  border: 1px solid var(--border, #2a3441);
  border-radius: 10px;
  padding: 6px 14px;
  font-size: 13px;
  height: 32px;
  cursor: pointer;
  transition: border-color .15s ease, background .15s ease;
}
button.clear:hover,
#nMsg button.clear:hover {
  border-color: var(--border-strong, #3a4759);
}

/* Ensure the footer button sits nicely next to the count */
#nMsg button.apply,
#nMsg button.clear {
  margin-left: 8px;
}



#teamAlignBox { display: none !important; }




/* --- Daily Ratings header layout --- */
#panel-dailyratings {
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  padding: 18px;
}

.ratings-header {
  display:flex;
  align-items:center;
  gap:12px;
  margin-bottom:8px;
  width: 100%;
}

.ratings-header h1 {
  margin:0;
  font-size:20px;
  font-weight:600;
  line-height:1.2;
}


.ratings-table-controls {
  display:flex;
  justify-content:flex-start;
  margin-bottom:8px;
  width: 100%;
}

.ratings-actions {
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}

.ratings-actions .btn.btn-small,
.ratings-header .btn.btn-small {
  height:30px;
  padding:0 12px;
  font-size:13px;
  border-radius:8px;
}

@media (max-width: 640px) {
  .ratings-table-controls {
    justify-content:flex-start;
  }
}




/* Clips grid */
.clips-grid {
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap:16px;
  margin-top:16px;
}
.clip-card {
  background:rgba(20,24,31,0.85);
  border:1px solid rgba(70,82,104,0.55);
  border-radius:14px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  transition:transform .2s ease, box-shadow .2s ease;
}
.clip-card:hover {
  transform:translateY(-4px);
  box-shadow:0 14px 30px rgba(0,0,0,0.35);
}
.clip-card.selected {
  border-color:#4aa8ff;
  box-shadow:0 0 0 2px rgba(74,168,255,0.35);
}
.clip-thumb {
  position:relative;
  padding-top:56.25%;
  background:#0f131a;
  cursor:pointer;
}
.clip-thumb img {
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
}
.clip-thumb--empty{
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(80,90,120,0.25);
  color:#9aa5be;
  font-size:12px;
  font-weight:600;
}
.clip-actions {
  position:absolute;
  inset:0;
  display:flex;
  flex-direction:column;
  gap:8px;
  align-items:center;
  justify-content:center;
  background:rgba(5,12,20,0.65);
  opacity:0;
  transition:opacity .2s ease;
  pointer-events:none;
}
.clip-actions .btn {
  pointer-events:auto;
  padding:6px 12px;
  font-size:12px;
}
.clip-card:hover .clip-actions,
.clip-card:focus-within .clip-actions {
  opacity:1;
}
.clip-body {
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.clip-title {
  font-weight:600;
  font-size:14px;
}
.clip-meta {
  font-size:12px;
  color:#9aa5be;
}
.clip-note {
  font-size:12px;
  color:#cfe3ff;
}
.clip-selection-count {
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(74,168,255,0.18);
  color:#cfe8ff;
  font-size:12px;
  margin-left:auto;
}
@media (max-width: 720px) {
  .clips-grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
  .clip-selection-count { margin-left: 0; }
}


/* === Sidebar (single source of truth) === */
:root{
  --sidebar-w: 220px;          /* expanded width */
  --sidebar-w-collapsed: 60px; /* collapsed rail width */
  --sidebar-gap: 8px;          /* space between sidebar and content */
}

/* Sidebar */
#sideNav{
  position: fixed; top:0; left:0; bottom:0;
  width: var(--sidebar-w);
  background: #14181f;
  border-right: 1px solid #2a3441;
  display:flex; flex-direction:column;
  z-index:100;
  transition: width .25s ease;
}
#sideNav .sideHeader{
  position: sticky; top:0;
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 10px;
  border-bottom:1px solid #2a3441;
  background: inherit;
  z-index: 2;
}
#sideNav .sideLogo{ width:30px; height:30px; border-radius:6px; object-fit:contain; }
#sideNav .sideTitle{ color:#e6e6e6; font-weight:600; font-size:14px; }
#sideNav .collapseBtn{ border:0; background:none; color:#4aa8ff; font-size:16px; cursor:pointer; padding:0 4px; }

#sideNav .sideList{ flex:1; overflow-y:auto; padding:10px 0; }
#sideNav .sideSection{
  margin:6px;
  border:1px solid rgba(70,82,104,0.55);
  border-radius:10px;
  background:rgba(12,16,24,0.6);
  overflow:hidden;
}
#sideNav .sideSectionHeader{
  width:100%;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:6px;
  padding:8px 12px;
  font-size:12px;
  color:#9aa5be;
  background:none;
  border:0;
  cursor:pointer;
}
#sideNav .sideSectionChevron{ transition: transform .2s ease; transform:rotate(0deg); }
#sideNav .sideSectionBody{ padding:4px 0 8px; }
#sideNav .sideSectionBody .sideItem{ margin:2px 6px; }
#sideNav .sideSection.collapsed .sideSectionBody{ display:none; }
#sideNav .sideSection.collapsed .sideSectionChevron{ transform:rotate(-90deg); }
#sideNav .sideSectionHeader:focus-visible{ outline:2px solid #4aa8ff; outline-offset:2px; }
#sideNav .sideItem{
  padding:8px 14px; margin:2px 6px; border-radius:8px;
  color:#e6e6e6; cursor:pointer; transition:background .2s ease;
  white-space:nowrap; font-size:13px;
}
#sideNav .sideItem:hover{ background:rgba(255,255,255,.08); }
#sideNav .sideItem.active{ background:rgba(74,168,255,.18); color:#cfe8ff; font-weight:600; }

/* Only shift PANELS (and top tabs if present) — no extra margins anywhere else */
body.sidebar-enabled .panel,
body.sidebar-enabled .tabs{
  margin-left: calc(var(--sidebar-w) + var(--sidebar-gap));
  transition: margin-left .25s ease;
}

/* Collapsed mode: shrink bar, hide list (keep logo + arrow) */
#sideNav.collapsed{ width: var(--sidebar-w-collapsed); }
#sideNav.collapsed .sideTitle{ display:none; }
#sideNav.collapsed .sideList{ display:none; }

/* Content shift when collapsed */
body.sidebar-enabled.sidebar-collapsed .panel,
body.sidebar-enabled.sidebar-collapsed .tabs{
  margin-left: calc(var(--sidebar-w-collapsed) + var(--sidebar-gap));
}

/* Mobile: minimal shift */
@media (max-width: 900px){
  body.sidebar-enabled .panel,
  body.sidebar-enabled .tabs{
    margin-left: calc(var(--sidebar-w-collapsed) + 8px);
  }
  
  /* Make opponent report modal stack on smaller screens */
  #opponentReportModal > div > div[style*="grid-template-columns"] {
    grid-template-columns: 1fr !important;
  }
  #opponentReportModal > div {
    max-width: 95% !important;
    width: 95% !important;
  }
}





    </style>
  </head>

  <body class="sidebar-enabled desktop">
    <!-- Clip Modal -->
    <div id="clipModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:40000; align-items:center; justify-content:center;">
      <div id="clipModalCard" style="position:relative; width:90%; max-width:980px; background:#14181f; border:1px solid #2a3448; border-radius:12px; overflow:hidden;">






        <!-- Close -->
        <button onclick="console.log('[CLOSE BTN] Inline onclick called'); if(typeof window.closeClipModal === 'function'){console.log('[CLOSE BTN] Calling closeClipModal'); window.closeClipModal();}else{console.error('[CLOSE BTN] closeClipModal not found!');}" style="position:absolute; top:10px; right:10px; z-index:3; background:#ff5a5f; border:0; color:white; font-weight:700; padding:6px 10px; border-radius:8px; cursor:pointer;">Close</button>

        <!-- Prev / Next -->
        <button onclick="prevClip()" class="btn" style="position:absolute; left:10px; top:50%; transform:translateY(-50%); z-index:2;">⏮ Prev</button>
        <button onclick="nextClip()" class="btn" style="position:absolute; right:10px; top:50%; transform:translateY(-50%); z-index:2;">Next ⏭</button>

        <!-- Video -->
        <iframe id="clipFrame" src="" style="width:100%; height:560px; border:0;"
                allow="autoplay; encrypted-media" allowfullscreen
                referrerpolicy="no-referrer-when-downgrade"></iframe>


<div id="ytToast" role="status" aria-live="polite"></div>


        <!-- Footer: select toggle + notes input + Save + hint -->
        <div id="clipModalFooter" style="padding:10px; border-top:1px solid var(--border); background:#0f131a; display:flex; gap:8px; align-items:center;">
          <button id="clipSelectBtn" class="btn" onclick="toggleSelectCurrentClip()">Select clip</button>
          <span id="clipSelectedBadge" class="tag" style="display:none;">Selected</span>

          <input id="clipNoteInput" type="text" placeholder="Add a note (optional)"
                 class="select" style="flex:1; min-height:38px;" oninput="onClipNoteInput(event)">

         <button id="clipNoteSaveBtn" class="btn" type="button" onclick="saveClipNoteFromFooter()">Save note</button>
         <button class="btn" type="button" onclick="discussClip(encodeURIComponent(getCurrentClipUrl()))">Discuss in Chat</button>
<span id="clipNoteMsg" class="muted" style="min-width:110px; text-align:right;"></span>

          <span id="clipSelHint" class="muted" style="min-width:110px; text-align:right;"></span>
        </div>
      </div>
    </div>

    <div id="traitModal" class="trait-modal" aria-hidden="true">
      <div id="traitModalCard">
        <div id="traitModalHeader">
          <h2>Trait Ratings — Heat Map</h2>
          <button id="traitModalClose" type="button" aria-label="Close">×</button>
        </div>
        <div id="traitModalBody">
          <div id="traitModalMessage" class="muted">Loading…</div>
          <div class="ratingsWrap">
            <table id="traitTable"><thead></thead><tbody></tbody></table>
          </div>
          <div id="traitLegend" class="muted" style="margin-top:4px;"></div>
        </div>
      </div>
    </div>




<!-- Report Viewer Modal -->
<div id="reportModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.8); z-index:30010; align-items:center; justify-content:center;">
  <div style="position:relative; width:92%; max-width:1000px; background:#14181f; border:1px solid #2a3448; border-radius:12px; overflow:hidden;">
    <button onclick="closeReportModal()" style="position:absolute; top:10px; right:10px; z-index:3; background:#ff5a5f; border:0; color:white; font-weight:700; padding:6px 10px; border-radius:8px; cursor:pointer;">Close</button>
    <iframe id="reportFrame" src="" style="width:100%; height:78vh; border:0;" allow="autoplay; encrypted-media" referrerpolicy="no-referrer-when-downgrade"></iframe>
  </div>
</div>







<!-- Login overlay (unchanged wrapper) -->
<div id="loginOverlay" style="position:fixed;inset:0; background:#0b0d10; display:flex;align-items:center;justify-content:center; z-index:9999; overflow:hidden;">
  <img src="https://www.peristeribc.gr/wp-content/uploads/2025/07/Peristeri-Logo-plain-1.png"
       style="position:absolute;inset:0;margin:auto;opacity:0.08;width:90%;height:90%;object-fit:contain;pointer-events:none;" />
  <div style="background:rgba(20,24,31,0.95);padding:28px;border-radius:16px;text-align:center;z-index:1;max-width:320px; width:90%;">
    <h2 style="margin-bottom:16px;">Enter Password</h2>
    <input id="pwInput" type="password"
           style="padding:10px;width:100%;border-radius:8px;border:1px solid #2a3448;background:#0f131a;color:#e9edf6;" />
    <div style="height:12px;"></div>
    <button onclick="unlockAndStart()" style="padding:10px 14px;width:100%;border-radius:8px;border:0;background:#4aa8ff;color:#051423;font-weight:700;">
      Unlock
    </button>
    <div id="pwMsg" style="margin-top:10px;color:#ff5a5f;"></div>
  </div>
</div>

<!-- Hide the old top tab bar (kept for compatibility/rollback) -->
<style>.tabs { display:none !important; }</style>

<!-- SIDEBAR NAVIGATION -->
<nav id="sideNav">
  <div class="sideHeader">
    <img src="https://www.peristeribc.gr/wp-content/uploads/2025/07/Peristeri-Logo-plain-1.png" class="sideLogo">
    <span class="sideTitle">Peristeri BC</span>
    <button id="collapseNav" class="collapseBtn">⟨</button>
  </div>
  <div class="sideList">
    <div class="sideItem active" data-tab="home">🏠 Home</div>
    <div class="sideItem" data-tab="admin" id="adminTabItem" style="display:none;">⚙️ Admin Portal</div>
    <div class="sideSection" data-section="feedback">
      <button class="sideSectionHeader" type="button" aria-expanded="true">
        <span class="sideSectionLabel">Feedback</span>
        <span class="sideSectionChevron">⌃</span>
      </button>
      <div class="sideSectionBody">
        <div class="sideItem" data-tab="dailyratings">📊 Daily Ratings</div>
        <div class="sideItem" data-tab="notes">📝 Notes</div>
        <div class="sideItem" data-tab="spiralfeedback">🔄 Spiral Feedback</div>
      </div>
    </div>
    <div class="sideSection" data-section="scouting">
      <button class="sideSectionHeader" type="button" aria-expanded="true">
        <span class="sideSectionLabel">Scouting</span>
        <span class="sideSectionChevron">⌃</span>
      </button>
      <div class="sideSectionBody">
        <div class="sideItem" data-tab="players">🏀 Players</div>
        <div class="sideItem" data-tab="opponents">📅 Schedule</div>
      </div>
    </div>
    <div class="sideSection" data-section="analytics">
      <button class="sideSectionHeader" type="button" aria-expanded="true">
        <span class="sideSectionLabel">Analytics</span>
        <span class="sideSectionChevron">⌃</span>
      </button>
      <div class="sideSectionBody">
        <div class="sideItem" data-tab="stats">📈 Stats</div>
        <div class="sideItem" data-tab="gamestats">📊 Game Stats</div>
        <div class="sideItem" data-tab="shotmap">🎯 Shot Map</div>
        <div class="sideItem" data-tab="predictions">🔮 Predictions</div>
      </div>
    </div>
    <div class="sideSection" data-section="media">
      <button class="sideSectionHeader" type="button" aria-expanded="true">
        <span class="sideSectionLabel">Media</span>
        <span class="sideSectionChevron">⌃</span>
      </button>
      <div class="sideSectionBody">
        <div class="sideItem" data-tab="clips">🎬 Clips</div>
        <div class="sideItem" data-tab="summaries">📹 Video Summaries</div>
      </div>
    </div>
    <div class="sideSection" data-section="operations">
      <button class="sideSectionHeader" type="button" aria-expanded="true">
        <span class="sideSectionLabel">Operations</span>
        <span class="sideSectionChevron">⌃</span>
      </button>
      <div class="sideSectionBody">
        <div class="sideItem" data-tab="strength">💪 Practice Load</div>
        <div class="sideItem" data-tab="chat">💬 Chat</div>
      </div>
    </div>
    <div class="sidePresence" id="presenceWidget">
      <div class="sidePresenceHeader">
        <span>Online now</span>
        <button class="presence-btn" type="button" title="Refresh" onclick="refreshPresenceWidget()">↻</button>
      </div>
      <div class="sidePresenceList" id="presenceWidgetList">
        <div class="presence-empty">Loading…</div>
      </div>
    </div>
  </div>
</nav>

<div id="mobileNavOverlay"></div>

<!-- Mobile tab bar -->
<div class="mobile-tabbar" id="mobileTabbar">
  <button type="button" data-mobile-nav="toggle" aria-label="Menu">☰<span>Menu</span></button>
  <button type="button" data-tab="home" class="active" aria-label="Home">🏠<span>Home</span></button>
  <button type="button" data-tab="players" aria-label="Players">🏀<span>Players</span></button>
  <button type="button" data-tab="clips" aria-label="Clips">🎬<span>Clips</span></button>
  <button type="button" data-tab="notes" aria-label="Notes">📝<span>Notes</span></button>
  <button type="button" data-tab="chat" aria-label="Chat">💬<span>Chat</span></button>
  <button type="button" data-tab="gamestats" aria-label="Game Stats">📊<span>Game Stats</span></button>
  <button type="button" data-tab="shotmap" aria-label="Shot Map">🎯<span>Shot Map</span></button>
</div>

<!-- HOME -->
<div id="panel-home" class="panel active home-panel">
  <div class="home-top">
    <div class="card" id="homeSessionCard">
      <div class="summary-card-header">
        <h2>Latest Session</h2>
        <button class="btn btn-small" type="button" onclick="loadHomeSummary(true)">Refresh</button>
      </div>
      <div id="homeSummaryTimestamp" class="muted" style="font-size:12px;"></div>
      <div id="homeSessionBody" class="muted">Loading…</div>
    </div>

    <div class="card" id="homePracticeTimeCard">
      <div class="summary-card-header"><h2>Practice Time Breakdown</h2></div>
      <div id="practiceTimeChart" style="width: 100%; height: 300px;">Loading…</div>
      <div id="practiceTimeDetails" class="muted" style="font-size:12px; margin-top:8px;"></div>
    </div>
  </div>

  <div class="card home-chart-card">
    <div class="sectionTitle" style="margin-bottom:6px; text-align:center;">Team Rating (avg of all players)</div>
    <div id="teamLineWrap" style="overflow:auto;">
      <svg id="teamLine"></svg>
    </div>
    <div id="teamLineNote" class="muted" style="margin-top:6px; text-align:center;"></div>
  </div>

  <div class="card" id="homeInsightsCard" style="display:none;">
    <div class="summary-card-header"><h2>💡 AI Coaching Insights</h2></div>
    <div id="homeInsightsContent" class="muted">Loading insights…</div>
  </div>

  <div class="card home-flags-card">
    <div class="sectionTitle">Team — 3-Day Flags</div>
    <div class="ratingsWrap">
      <table id="flagsTable"><thead></thead><tbody></tbody></table>
    </div>
    <div id="flagsMsg" class="muted" style="margin-top:8px;"></div>
  </div>
</div>

<div id="panel-team" class="panel">
  <h1>Team — Last 7 Days</h1>

  <div id="teamBox" class="grid" style="grid-template-columns:1fr 1fr; gap:18px;"></div>


  <!-- Theme Frequency card (STAYS inside panel-team) -->
  <div id="teamClipThemes" class="card" style="margin-top:16px;">
    <div class="sectionTitle">Theme Frequency (last 7 days)</div>
    <div id="themeChips"></div>
  </div>
</div> <!-- close panel-team once -->

<!-- DAILY RATINGS -->
<div id="panel-dailyratings" class="panel">
  <div class="ratings-header">
    <h1>Daily Ratings — Heat Map</h1>
  </div>

  <div class="ratingsWrap">
    <div class="ratings-table-controls">
      <div class="ratings-actions">
        <button id="openRatingsBtn" class="btn btn-small">Rate session</button>
        <button id="openTraitBtn" class="btn btn-small" type="button">Trait ratings</button>
      </div>
    </div>
    <table id="ratingsTable"><thead></thead><tbody></tbody></table>
  </div>

  <div id="ratingsLegend" class="muted" style="margin-top:8px;"></div>

  <!-- Player Rating Chart Section -->
  <div class="sectionTitle" style="margin-top:24px; margin-bottom:12px;">Player Rating History</div>
  <div style="background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:20px; margin-bottom:16px;">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:16px;">
      <!-- Comparison Mode -->
      <label style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:13px; color:var(--muted); font-weight:600;">Compare:</span>
        <select id="ratingChartMode" class="select" style="min-width:150px;">
          <option value="player">Players</option>
          <option value="position">Positions</option>
        </select>
      </label>
      
      <!-- Player Mode Controls -->
      <div id="ratingChartPlayerMode" style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <label style="display:flex; align-items:center; gap:8px;">
          <span style="font-size:13px; color:var(--muted);">Player 1:</span>
          <select id="ratingChartPlayer1" class="select" style="min-width:180px;">
            <option value="">Select player...</option>
          </select>
        </label>
        <label style="display:flex; align-items:center; gap:8px;">
          <span style="font-size:13px; color:var(--muted);">Player 2 (optional):</span>
          <select id="ratingChartPlayer2" class="select" style="min-width:180px;">
            <option value="">None (no comparison)</option>
          </select>
        </label>
      </div>
      
      <!-- Position Mode Controls -->
      <div id="ratingChartPositionMode" style="display:none; gap:12px; align-items:center; flex-wrap:wrap;">
        <label style="display:flex; align-items:center; gap:8px;">
          <span style="font-size:13px; color:var(--muted);">Position 1:</span>
          <select id="ratingChartPosition1" class="select" style="min-width:150px;">
            <option value="">Select position...</option>
            <option value="PG">PG (Point Guard)</option>
            <option value="SG">SG (Shooting Guard)</option>
            <option value="SF">SF (Small Forward)</option>
            <option value="PF">PF (Power Forward)</option>
            <option value="C">C (Center)</option>
          </select>
        </label>
        <label style="display:flex; align-items:center; gap:8px;">
          <span style="font-size:13px; color:var(--muted);">Position 2:</span>
          <select id="ratingChartPosition2" class="select" style="min-width:150px;">
            <option value="">Select position...</option>
            <option value="PG">PG (Point Guard)</option>
            <option value="SG">SG (Shooting Guard)</option>
            <option value="SF">SF (Small Forward)</option>
            <option value="PF">PF (Power Forward)</option>
            <option value="C">C (Center)</option>
          </select>
        </label>
      </div>
      
      <!-- Session Filter (applies to both modes) -->
      <label style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:13px; color:var(--muted);">Filter:</span>
        <select id="ratingChartFilter" class="select" style="min-width:150px;">
          <option value="all">All sessions</option>
          <option value="games">Games (GBL & EC)</option>
          <option value="practices">Practices</option>
        </select>
      </label>
      
      <button id="ratingChartLoadBtn" class="btn btn-small" type="button">Load Chart</button>
    </div>
    <div id="ratingChartContainer" style="background:var(--bg-secondary); border:1px solid var(--border); border-radius:8px; padding:16px; min-height:360px; display:none; width:100%;">
      <svg id="ratingChartSVG" width="100%" height="340" style="width:100%; height:auto; display:block;"></svg>
    </div>
    <div id="ratingChartNote" style="text-align:center; color:var(--muted); font-size:12px; margin-top:12px;"></div>
  </div>
</div>

<div id="panel-gamestats" class="panel">
  <h1>Game Stats</h1>
  <div class="gamestats-controls">
    <select id="gsGame">
      <option value="">Select game</option>
    </select>
    <button id="gsLoadBtn" type="button">Load</button>
  </div>
  <div class="gamestats-summary">
    <div class="gs-card">
      <div class="gs-meta" id="gsGameMeta">
        <strong>No game loaded</strong>
        <span>Select a game to view details.</span>
      </div>
    </div>
    <div class="gs-card">
      <h3 style="margin:0;">Advanced Snapshot</h3>
      <ul id="gsAdvancedMetrics" class="gs-metric-list"></ul>
    </div>
    <div class="gs-card">
      <h3 style="margin:0;">Key Notes</h3>
      <ul id="gsInsights" class="gs-metric-list"></ul>
    </div>
  </div>
  <div class="gamestats-charts">
    <div class="gamestats-section chart-duo">
      <h2>Four Factors</h2>
      <canvas id="gsFourChart" class="gs-chart-square"></canvas>
    </div>
    <div class="gamestats-section chart-duo">
      <h2>Shot Profile</h2>
      <canvas id="gsShotChart" class="gs-chart-square"></canvas>
    </div>
    <div class="gamestats-section chart-span">
      <h2>Game Flow</h2>
      <div class="gamestats-canvas-wrap">
        <canvas id="gsFlowChart"></canvas>
      </div>
    </div>
    <div class="gamestats-section chart-span">
      <h2>Usage vs Efficiency</h2>
      <div class="gamestats-canvas-wrap">
        <canvas id="gsUsageChart"></canvas>
      </div>
    </div>
  </div>
  <div id="gsMessage" class="muted" style="margin-top:8px;"></div>
</div>

<div id="panel-shotmap" class="panel">
  <div class="shotmap-header">
    <h1 style="margin:0;font-size:22px;">Shot Map — Hex Heatmap</h1>
    <div class="shotmap-meta">
      <span id="shot-meta">Loading…</span>
      <button id="shot-exportBtn" type="button" class="btn btn-small">Export PNG</button>
    </div>
  </div>

  <div class="shotmap-layout">
    <aside class="shotmap-filter">
      <h3>Filters</h3>
      <div class="shotmap-group">
        <label>
          <span>Team</span>
          <select id="shot-team">
            <option value="">All teams</option>
            <option value="1" selected>Peristeri BC</option>
            <option value="2">Opponent</option>
          </select>
        </label>
        <label>
          <span>Game</span>
          <select id="shot-game">
            <option value="">All games</option>
          </select>
        </label>
        <label>
          <span>Player</span>
          <select id="shot-player"></select>
        </label>
        <label>
          <span>Opponent</span>
          <select id="shot-opponent"></select>
        </label>
        <label>
          <span>Period</span>
          <select id="shot-period"></select>
        </label>
        <label>
          <span>Type</span>
          <select id="shot-type">
            <option value="">All types</option>
            <option value="2pt">2pt</option>
            <option value="3pt">3pt</option>
          </select>
        </label>
        <label>
          <span>Result</span>
          <select id="shot-result">
            <option value="">All results</option>
            <option value="1">Made</option>
            <option value="0">Miss</option>
          </select>
        </label>
        <label>
          <span>Clock Time</span>
          <select id="shot-clock">
            <option value="">All</option>
            <option value="quick">Quick (22-18s)</option>
            <option value="middle">Middle (18-10s)</option>
            <option value="late">Late (under 5s)</option>
          </select>
        </label>
        <label>
          <span>Score Differential</span>
          <select id="shot-scoreDiff">
            <option value="">All situations</option>
            <option value="trailing-5plus">Trailing by 5+</option>
            <option value="trailing-close">Trailing by 3-4</option>
            <option value="tied-close">Tied/Close (±3)</option>
            <option value="leading-close">Leading by 3-4</option>
            <option value="leading-5plus">Leading by 5+</option>
          </select>
        </label>
      </div>

      <h3>Render</h3>
      <div class="shotmap-group">
        <label>
          <span>Mode</span>
          <select id="shot-render">
            <option value="dots">Dots</option>
            <option value="hex" selected>Hex heatmap</option>
          </select>
        </label>
        <label>
          <span>Color by</span>
          <select id="shot-colorBy">
            <option value="fg" selected>FG%</option>
            <option value="xfg">xFG% (smoothed)</option>
            <option value="ep">EP (Expected Points)</option>
            <option value="density">Shot density</option>
          </select>
        </label>
      </div>

      <button id="shot-resetBtn" type="button" class="btn btn-small">Reset</button>
    </aside>

    <section class="shotmap-center">
      <div id="shot-stage" class="shot-stage">
        <div id="shot-courtBg" class="shot-stage-layer"></div>
        <div id="shot-courtShade" class="shot-stage-layer" aria-hidden="true"></div>
        <canvas id="shot-canvas" class="shot-stage-layer"></canvas>
      </div>

      <div class="shot-badges">
        <span class="badge" id="shot-totalBadge">0 shots</span>
        <span class="badge" id="shot-madeBadge">0 made</span>
        <span class="badge" id="shot-pctBadge">0%</span>
        <span class="badge" id="shot-legendUnit">Color: xFG% (0→100)</span>
        <span class="badge" id="shot-baselines">2PT • — | 3PT • —</span>
      </div>

      <div class="shot-legend">
        <span><span class="dot" style="background:#12b886;border:1px solid #0c8c68;"></span>Made</span>
        <span><span class="dot" style="background:#fa5252;border:1px solid #d63333;"></span>Miss</span>
        <span><span class="ring"></span>3PT ring</span>
        <span class="muted">Hex opacity follows volume (density mode uses color scale)</span>
        <span class="swatch" id="shot-swatch" style="background:linear-gradient(90deg,#ff4040,#ffd000,#00dc82)"></span>
        <span class="muted" id="shot-swatchLabel">Low → High</span>
      </div>
    </section>

    <aside class="shotmap-stats">
      <div class="card-section">
        <h4>Filter Summary</h4>
        <div id="shot-filterSummary" style="font-size:13px;color:#d7e1ff;">Loading…</div>
      </div>
      <div class="card-section">
        <h4>Aggregate Stats</h4>
        <div id="shot-aggKvs"></div>
      </div>
      <div class="card-section">
        <h4>Shot Distribution</h4>
        <div class="shot-dist-bars" id="shot-distBars"></div>
      </div>
      <div class="card-section">
        <h4>Additional Stats</h4>
        <div class="shot-dist-bars" id="shot-addlStats"></div>
      </div>
    </aside>
  </div>
  <div id="shot-tip" class="shot-tip"></div>
</div>

<!-- PREDICTIONS -->
<div id="panel-predictions" class="panel">
  <div class="sectionTitle" style="margin-top:0;">🔮 Predictions</div>
  
  <div id="predictionMsg" class="muted" style="margin-bottom:8px;">Click "Generate Prediction" to analyze next game.</div>
  
  <div style="margin-bottom:24px;">
    <button id="loadPredictionBtn" class="btn" type="button">Generate Prediction</button>
  </div>
  
  <div id="predictionContent" style="display:none;">
    <!-- Game Info -->
    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="muted" style="font-size:11px; margin-bottom:8px;">Next Game</div>
      <div id="predOpponent" style="font-size:24px; font-weight:700; margin-bottom:4px;">—</div>
      <div id="predDate" class="muted" style="font-size:14px;">—</div>
    </div>
    
    <!-- How it Works -->
    <div style="margin-bottom:16px; padding:12px; background:var(--accent-light); border-radius:8px; border-left:3px solid var(--accent);">
      <div style="font-weight:600; font-size:13px; margin-bottom:6px; color:var(--accent);">💡 How This Works</div>
      <div class="muted" style="font-size:12px; line-height:1.6;">
        Predictions are based on <strong>recent practice ratings</strong> and <strong>historical game performance</strong>. 
        The model analyzes your last 3 practice sessions' average ratings and compares them with shooting efficiency in recent games. 
        <br><br>
        <strong>Points range</strong> (e.g., 82-88) shows the expected scoring based on historical variance. 
        <strong>Quarter breakdown</strong> predicts performance by period using recent game patterns.
      </div>
    </div>
    
    <!-- Predictions Grid -->
    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Shooting Efficiency</div>
      <div style="display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:16px;">
        <div>
          <div class="muted" style="font-size:12px;">Total FG%</div>
          <div id="predFG" style="font-size:28px; font-weight:700; color:var(--accent);">—%</div>
          <div id="predConfidence" class="muted" style="font-size:12px; margin-top:4px;">—</div>
        </div>
        <div>
          <div class="muted" style="font-size:12px;">2-Point FG%</div>
          <div id="predFG2" style="font-size:24px; font-weight:600;">—%</div>
        </div>
        <div>
          <div class="muted" style="font-size:12px;">3-Point FG%</div>
          <div id="predFG3" style="font-size:24px; font-weight:600;">—%</div>
        </div>
      </div>
    </div>
    
    <!-- Game Outcome -->
    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Expected Outcome</div>
      <div style="display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:16px;">
        <div>
          <div class="muted" style="font-size:12px;">Points Scored</div>
          <div id="predPoints" style="font-size:28px; font-weight:700; color:var(--accent);">—</div>
          <div class="muted" style="font-size:12px; margin-top:4px;">points</div>
        </div>
        <div>
          <div class="muted" style="font-size:12px;">Result</div>
          <div id="predWinLoss" style="font-size:28px; font-weight:700;">—</div>
          <div id="predWinProb" class="muted" style="font-size:12px; margin-top:4px;">—</div>
        </div>
      </div>
    </div>
    
    <!-- Quarter-by-Quarter Breakdown -->
    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px; display:none;" id="predQuartersCard">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Quarter-by-Quarter Breakdown</div>
      
      <div style="margin-bottom:16px;">
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:8px;">
          <div style="padding:8px; background:var(--bg-secondary); border-radius:6px;">
            <div class="muted" style="font-size:11px;">1st Half</div>
            <div id="predHalf1" style="font-size:18px; font-weight:600;">—</div>
          </div>
          <div style="padding:8px; background:var(--bg-secondary); border-radius:6px;">
            <div class="muted" style="font-size:11px;">2nd Half</div>
            <div id="predHalf2" style="font-size:18px; font-weight:600;">—</div>
          </div>
        </div>
      </div>
      
      <div style="display:grid; grid-template-columns:repeat(4, 1fr); gap:8px;">
        <div style="padding:8px; background:var(--bg-secondary); border-radius:6px; text-align:center;">
          <div class="muted" style="font-size:11px;">Q1</div>
          <div id="predQ1" style="font-size:16px; font-weight:600;">—</div>
        </div>
        <div style="padding:8px; background:var(--bg-secondary); border-radius:6px; text-align:center;">
          <div class="muted" style="font-size:11px;">Q2</div>
          <div id="predQ2" style="font-size:16px; font-weight:600;">—</div>
        </div>
        <div style="padding:8px; background:var(--bg-secondary); border-radius:6px; text-align:center;">
          <div class="muted" style="font-size:11px;">Q3</div>
          <div id="predQ3" style="font-size:16px; font-weight:600;">—</div>
        </div>
        <div style="padding:8px; background:var(--bg-secondary); border-radius:6px; text-align:center;">
          <div class="muted" style="font-size:11px;">Q4</div>
          <div id="predQ4" style="font-size:16px; font-weight:600;">—</div>
        </div>
      </div>
    </div>
    
    <!-- Historical Accuracy -->
    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px; display:none;" id="predAccuracyCard">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Historical Accuracy</div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
        <div>
          <div class="muted" style="font-size:12px;">Avg Prediction Error</div>
          <div id="predAvgError" style="font-size:20px; font-weight:600;">—</div>
          <div class="muted" style="font-size:11px; margin-top:4px;">± points</div>
        </div>
        <div>
          <div class="muted" style="font-size:12px;">Games Analyzed</div>
          <div id="predGamesCount" style="font-size:20px; font-weight:600;">—</div>
        </div>
      </div>
    </div>
    
    <!-- Breakdown -->
    <div id="predBreakdown" style="margin-top:12px;"></div>
  </div>
  
  <!-- Past Games History -->
  <div id="predPastGames" class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px; display:none;"></div>
</div>

<!-- PLAYERS -->
<div id="panel-players" class="panel">
  <div id="playerLibraryGrid" class="player-library-grid">
    <!-- Player cards will be inserted here -->
  </div>
  
  <!-- Player Detail Modal -->
  <div id="playerDetailModal" class="player-detail-modal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; overflow-y:auto; padding:20px;">
    <div style="max-width:1200px; margin:0 auto; background:var(--panel); border-radius:12px; padding:24px; border:1px solid var(--border);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h2 id="playerModalTitle" style="margin:0; font-size:24px;">Player Details</h2>
        <button id="playerModalClose" type="button" style="background:transparent; border:1px solid var(--border); color:var(--text); padding:8px 16px; border-radius:6px; cursor:pointer; font-size:14px;" onclick="closePlayerDetailModal()">✕ Close</button>
      </div>
      
      <div class="grid g2">
        <div class="card">
          <div id="playerModalPhotoWrap" style="margin-bottom:16px; text-align:center;">
            <img id="playerModalPhoto" class="avatar" alt="Player photo" style="width:120px; height:120px; margin:0 auto;" />
          </div>
          <div class="kv">
            <div>Overall delta</div><div id="pOverall" class="mono">—</div>
          </div>
          <div class="sectionTitle">3-Day Flags</div>
          <div id="pFlags" class="mono muted">—</div>
          <div class="sectionTitle">Ratings by Coach</div>
          <div id="pCoachRatings" class="mono muted">—</div>
        </div>

        <div class="card">
          <h2>Strengths</h2>
          <ul id="pStrengths"></ul>
          <h2>Areas to Improve</h2>
          <ul id="pWeaknesses"></ul>
          <h2>Suggested Focus</h2>
          <ul id="pFocus"></ul>

          <div class="sectionTitle">Shot Chart</div>
          <div id="pShotChartWrap" class="player-shot-wrap">
            <canvas id="pShotCanvas" width="320" height="300"></canvas>
            <div id="pShotSummary" class="muted" style="font-size:12px;">No shot data.</div>
          </div>

          <div class="sectionTitle">Clips (newest)</div>
          <div id="pClips"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- stats -->
<section id="panel-stats" class="panel">
  <div class="sectionTitle" style="margin-top:0;">Stats</div>

  <div id="statsMsg" class="muted" style="margin-bottom:8px;">Loading…</div>

  <!-- League scatter -->
  <div id="statsTeamBox" class="card" style="padding:10px;margin-bottom:12px; border:1px solid var(--border); border-radius:12px;">
    <div style="font-weight:600; margin-bottom:6px;">League ORtg vs DRtg</div>
    <div class="muted" data-role="league-note" style="font-size:12px; margin-bottom:6px;">Bubble size reflects net rating (eDiff). Look for top-right bubbles (high ORtg, low DRtg) to spot elite teams.</div>
    <div class="league-scatter-wrap"><canvas id="statsLeagueChart"></canvas></div>
  </div>

  <!-- Opponent profiler -->
  <div class="card stats-opp-card" style="margin-bottom:12px; border:1px solid var(--border); border-radius:12px;">
    <div style="font-weight:600; display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
      <span>Opponent profile vs league & Peristeri</span>
      <div style="display:flex; align-items:center; gap:6px;">
        <label for="statsOpponentSelect" class="muted" style="font-size:12px;">Opponent</label>
        <select id="statsOpponentSelect" class="select" style="width:200px;"></select>
      </div>
    </div>
    <div id="statsOpponentProfile" class="muted" style="font-size:13px;">
      Pick a team to compare key metrics against league averages and Peristeri BC.
    </div>
  </div>

  <!-- Players table -->
  <div class="sectionTitle">Player insights</div>
  <div class="muted" style="margin-bottom:6px;">Derived per-40, shot profile, advanced join + flags</div>
  <div style="overflow:auto;">
    <table id="statsPlayersTable" class="table">
      <thead>
        <tr>
          <th>Player</th><th>MPG</th><th>PPG</th><th>FGA</th><th>3PM</th><th>3PA</th><th>3PAr</th><th>FTr</th>
          <th>PPS</th><th>TS%</th><th>USG%</th><th>TOV%</th><th>ORtg</th><th>eDiff</th><th>PER</th>
          <th>Per40 PTS</th>
<th>Per40 REB</th>
<th>Per40 AST</th>
<th>Per40 Stocks</th>
          
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Leaderboards -->
  <div class="sectionTitle">Leaderboards</div>
  <div id="statsLeaders" class="grid" style="display:grid; grid-template-columns: repeat(auto-fit,minmax(240px,1fr)); gap:10px;"></div>

  <!-- Practice-to-Game Correlation -->
  <div class="card" style="margin-top:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <div class="sectionTitle" style="margin:0;">Practice-to-Game Performance</div>
      <button id="loadPracticeGameBtn" class="btn btn-small" type="button">Load Analysis</button>
    </div>
        <div class="muted" style="font-size:13px; margin-bottom:12px;">
          Correlation: Average of last 3 practice ratings → Team FG% in games. Also shows game day rating for comparison.
        </div>
        <div id="practiceGameMsg" class="muted" style="margin-bottom:8px;">Click "Load Analysis" to generate report.</div>
    <div id="practiceGameSummary" style="display:none; margin-bottom:16px; padding:12px; background:var(--bg-secondary); border-radius:8px;">
      <div style="display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:12px;">
        <div>
          <div class="muted" style="font-size:12px;">Total Games</div>
          <div id="pgTotalGames" style="font-size:20px; font-weight:600;">—</div>
        </div>
        <div>
          <div class="muted" style="font-size:12px;">Practice → Game FG% Corr</div>
          <div id="pgCorrelation" style="font-size:20px; font-weight:600;">—</div>
        </div>
      </div>
    </div>
    <div id="practiceGameContent"></div>
  </div>
</section>








<!-- CLIPS -->
<div id="panel-clips" class="panel">
  <div class="filters">
    <select id="fPlayer"></select>
    <select id="fTheme"></select>
    <select id="fSub"></select>
    <input id="fSearch" type="text" placeholder="Search text…" />
    <button class="btn" onclick="loadClips()">Search</button>
    <button class="btn-danger" onclick="openFeedbackModal()">Email Feedback</button>
    <button class="btn" onclick="openCreateSummaryModal()">Create indiv. Summary</button>
    <button class="btn" onclick="discussSelectedClips()">Discuss Selected</button>
    <button class="btn" onclick="deselectAllClips()">Deselect All</button>
    <span id="clipSelectionCount" class="clip-selection-count">Selected: 0</span>
  </div>
  <div id="clipsList" class="clips-grid"></div>
</div>

<!-- Feedback Compose Modal -->
<div id="feedbackModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.75); z-index:10001; align-items:center; justify-content:center;">
  <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:90%; max-width:680px; padding:16px; position:relative;">
    <button id="fbCloseBtn" style="position:absolute; right:12px; top:12px; border:0; background:#ff5a5f; color:white; font-weight:700; padding:6px 10px; border-radius:8px; cursor:pointer;">Close</button>

    <h2 style="margin-top:0;">Email feedback</h2>

        <div style="display:grid; gap:10px;">
          <label>Player
            <select id="fbPlayer" class="select"></select>
          </label>

          <label>Message to player
            <textarea id="fbText" rows="6" style="width:100%; padding:10px; border-radius:10px; background:#0f131a; color:var(--text); border:1px solid var(--border);"></textarea>
          </label>

          <div class="muted" id="fbSelectedCount">No clips selected.</div>

          <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
            <button class="btn" id="fbSendBtn" type="button">Send</button>
          </div>

          <div id="fbMsg" class="muted"></div>
        </div>
      </div>
    </div>

    <!-- Create Summary Modal -->
    <div id="createSummaryModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.75); z-index:10003; align-items:center; justify-content:center;">
      <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:92%; max-width:820px; padding:16px; position:relative; max-height:92vh; overflow:auto;">
        <button onclick="closeCreateSummaryModal()" style="position:absolute; right:12px; top:12px; border:0; background:#ff5a5f; color:white; font-weight:700; padding:6px 10px; border-radius:8px; cursor:pointer;">Close</button>

        <h2 style="margin-top:0;">Create Summary</h2>

        <div class="grid" style="grid-template-columns:1fr 1fr; gap:12px;">
          <label>Title
            <input id="sumTitle" type="text" class="select" placeholder="e.g., 12 Feb — Transition Defense" />
          </label>
          <label>Audience type
            <select id="sumAudienceType" class="select" onchange="onSumAudienceTypeChange()">
              <option value="player">Player</option>
              <option value="team">Team</option>
              <option value="group">Group</option>
            </select>
          </label>
          <label id="sumAudienceNameWrap">Audience name
            <select id="sumAudienceName" class="select"></select>
          </label>
          <label>Description
            <textarea id="sumDescription" rows="3" style="width:100%; padding:10px; border-radius:10px; background:#0f131a; color:var(--text); border:1px solid var(--border);" placeholder="Optional context for the reel"></textarea>
          </label>
        </div>

        <div class="sectionTitle" style="margin-top:12px;">Selected Clips & Captions</div>
        <div class="ratingsWrap">
          <table id="sumClipsTable">
            <thead><tr><th style="text-align:center;">#</th><th>Clip</th><th>Caption (optional)</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="sumMsg" class="muted" style="margin-top:8px;"></div>

        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;">
          <button class="btn" id="sumSaveBtn" type="button">Save Summary</button>
        </div>
      </div>
    </div>

    <!-- Summary View Modal -->
    <div id="summaryViewModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.75); z-index:10002; align-items:center; justify-content:center;">
      <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:92%; max-width:820px; padding:16px; position:relative; max-height:92vh; overflow:auto;">
        <button onclick="closeSummaryModal()" style="position:absolute; right:12px; top:12px; border:0; background:#ff5a5f; color:white; font-weight:700; padding:6px 10px; border-radius:8px; cursor:pointer;">Close</button>
        <h2 id="svTitle" style="margin-top:0;">Summary</h2>
        <div class="muted" id="svMeta"></div>
        <p id="svDesc" style="white-space:pre-wrap;"></p>

        <div class="ratingsWrap">
          <table id="svClipsTable">
            <thead>
              <tr><th style="text-align:center;">#</th><th>Clip</th><th>Caption</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="svMsg" class="muted" style="margin-top:8px;"></div>
      </div>
    </div>

<!-- SUMMARIES -->
<div id="panel-summaries" class="panel">
  <h1>Summaries</h1>
  <div class="ratingsWrap">
    <table id="sumListTable">
      <thead>
        <tr>
          <th style="text-align:center;">Date</th>
          <th>Title</th>
          <th>Audience</th>
          <th style="text-align:center;">Open</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <div id="sumListMsg" class="muted" style="margin-top:8px;"></div>
</div>

 






<div id="panel-chat" class="panel">
  <div class="chat-shell">
    <div class="chat-header">
      <div>
        <h2>Coach Chat</h2>
        <p>Share quick updates, reminders, and links with the staff.</p>
      </div>
      <button class="chat-refresh" type="button" onclick="refreshChat()">↻ Refresh</button>
    </div>

    <div class="chat-controls">
      <div class="chat-control-group">
        <span class="chat-label">Send to</span>
        <select id="chatTo" class="chat-target-select">
          <option value="All">All coaches</option>
        </select>
      </div>
    </div>

    <div id="chatList" class="chat-thread">
      <div class="chat-empty">No messages yet.</div>
    </div>

    <div class="chat-input">
      <textarea id="chatText" rows="3" class="chat-textarea" placeholder="Write a note to this coach (or All coaches)…"></textarea>
      <button class="chat-send" type="button" onclick="sendChat()">Send</button>
    </div>

    <div class="chat-status muted" id="chatMsg"></div>
  </div>
</div>


<div id="opponentReportModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:10050; align-items:center; justify-content:center; overflow:auto; padding:20px;">
  <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:95%; max-width:1200px; padding:16px; position:relative; display:flex; flex-direction:column; gap:12px; max-height:90vh; overflow:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
      <div>
    <h2 style="margin:0;">Opponent Statistical Report</h2>
        <div class="muted" style="font-size:12px; margin-top:4px;">Copy and share the generated report with staff.</div>
      </div>
      <button onclick="closeOpponentReport()" style="border:0; background:#ff5a5f; color:white; font-weight:700; padding:8px 16px; border-radius:8px; cursor:pointer; flex-shrink:0;">Close</button>
    </div>
    <div style="display:grid; grid-template-columns:1.5fr 1fr; gap:12px; align-items:start;">
      <div style="display:flex; flex-direction:column; gap:8px;">
        <textarea id="opponentReportText" style="width:100%; height:400px; max-height:60vh; background:#0b0d10; color:#dce5ff; border:1px solid #2a3448; border-radius:8px; padding:10px; font-size:13px; line-height:1.5; white-space:pre-wrap; resize:vertical; font-family:monospace;"></textarea>
    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button class="btn" type="button" onclick="copyOpponentReport(this)">Copy to clipboard</button>
    </div>
      </div>
      <div id="opponentReportRanks" style="background:#0f131a; border:1px solid #2a3448; border-radius:10px; padding:12px; overflow:auto; max-height:60vh;">
      <div class="muted" style="font-size:12px;">Load an opponent to view league ranking table.</div>
      </div>
    </div>
  </div>
</div>








<div id="notesTooltip" style="
  position: fixed;
  z-index: 100000;
  display: none;
  max-width: 360px;
  background: rgba(20,24,31,0.98);
  color: #e9edf6;
  border: 1px solid #2a3448;
  border-radius: 10px;
  padding: 10px;
  box-shadow: 0 8px 24px rgba(0,0,0,.4);
  pointer-events: none;
  font-size: 13px;
  line-height: 1.35;
"></div>




<div id="panel-opponents" class="panel">
  <h1>Shedule</h1>
  <div class="card" id="oppScheduleCard">
    <div class="sectionTitle">Upcoming & Past Games</div>
    <div id="oppScheduleList">Loading…</div>
  </div>
</div>

<!-- ADMIN PORTAL -->
<div id="panel-admin" class="panel" style="background:#0f131a; color:#e9edf6;">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
    <h1 style="margin:0; color:#e9edf6;">Admin Portal</h1>
    <button onclick="loadAdminStats()" class="btn" style="flex-shrink:0;">Refresh</button>
  </div>

  <div id="adminSummary" class="card" style="margin-bottom:20px; padding:16px; border:1px solid var(--border); border-radius:12px; background:#14181f;">
    <div class="sectionTitle" style="margin-top:0; color:#e9edf6;">Summary</div>
    <div id="adminSummaryContent" class="muted" style="color:#a0a8b8;">Loading...</div>
  </div>

  <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
    <div class="card" style="padding:16px; border:1px solid var(--border); border-radius:12px; background:#14181f;">
      <div class="sectionTitle" style="margin-top:0; color:#e9edf6;">Coach Leaderboard</div>
      <div id="adminLeaderboard" class="muted" style="color:#a0a8b8;">Loading...</div>
    </div>

    <div class="card" style="padding:16px; border:1px solid var(--border); border-radius:12px; background:#14181f;">
      <div class="sectionTitle" style="margin-top:0; color:#e9edf6;">Feature Usage</div>
      <div id="adminFeatureUsage" class="muted" style="color:#a0a8b8;">Loading...</div>
    </div>
  </div>

  <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
    <div class="card" style="padding:16px; border:1px solid var(--border); border-radius:12px; background:#14181f;">
      <div class="sectionTitle" style="margin-top:0; color:#e9edf6;">Player Coverage</div>
      <div id="adminPlayerCoverage" class="muted" style="color:#a0a8b8; max-height:400px; overflow:auto;">Loading...</div>
    </div>

    <div class="card" style="padding:16px; border:1px solid var(--border); border-radius:12px; background:#14181f;">
      <div class="sectionTitle" style="margin-top:0; color:#e9edf6;">Recent Activity Log</div>
      <div id="adminRecentActivity" class="muted" style="max-height:400px; overflow:auto; color:#a0a8b8;">Loading...</div>
    </div>
  </div>

  <div class="card" style="padding:16px; border:1px solid var(--border); border-radius:12px; background:#14181f;">
    <div class="sectionTitle" style="margin-top:0; color:#e9edf6;">Login/Logout History</div>
    <div id="adminSessions" class="muted" style="max-height:400px; overflow:auto; color:#a0a8b8;">Loading...</div>
  </div>
</div>

<!-- User Detail Modal -->
<div id="userDetailModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:10060; align-items:center; justify-content:center; overflow:auto; padding:20px;">
  <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:95%; max-width:900px; padding:16px; position:relative; display:flex; flex-direction:column; gap:12px; max-height:90vh; overflow:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
      <h2 style="margin:0; color:#e9edf6;" id="userDetailName">User Details</h2>
      <button onclick="closeUserDetail()" style="border:0; background:#ff5a5f; color:white; font-weight:700; padding:8px 16px; border-radius:8px; cursor:pointer; flex-shrink:0;">Close</button>
    </div>
    <div id="userDetailContent" style="color:#a0a8b8;">Loading...</div>
  </div>
</div>

<!-- STRENGTH / PRACTICE LOAD -->
<div id="panel-strength" class="panel">
  <h1>Practice Load</h1>

  <div class="ratingsWrap">
    <table id="plListTable">
      <thead>
        <tr>
          <th style="text-align:center;">Date</th>
          <th>Title</th>
          <th>Audience</th>
          <th style="text-align:center;">Open</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <div id="plListMsg" class="muted" style="margin-top:8px;"></div>
</div>
<!-- Practice Load View Modal -->
<div id="plViewModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.75); z-index:10005; align-items:center; justify-content:center;">
  <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:92%; max-width:860px; padding:16px; position:relative; max-height:92vh; overflow:auto;">
    <button onclick="closePLModal()" style="position:absolute; right:12px; top:12px; border:0; background:#ff5a5f; color:white; font-weight:700; padding:6px 10px; border-radius:8px; cursor:pointer;">Close</button>

    <h2 id="plTitle" style="margin-top:0;">Practice Load</h2>
    <div id="plMeta" class="muted" style="margin-bottom:8px;"></div>
    <p id="plDesc" style="white-space:pre-wrap;"></p>
    <div id="plFacts" class="pl-facts"></div>

    <!-- 4 metrics only inside this grid -->
    <div class="grid" style="grid-template-columns: repeat(4, minmax(0, 1fr)); gap:12px; margin:12px 0;">
      <div class="card"><div class="muted">Session Load</div><div id="plM_load" class="mono" style="font-size:18px;">—</div></div>
      <div class="card"><div class="muted">ACWR</div><div id="plM_acwr" class="mono" style="font-size:18px;">—</div></div>
      <div class="card"><div class="muted">Monotony</div><div id="plM_mono" class="mono" style="font-size:18px;">—</div></div>
      <div class="card"><div class="muted">Strain</div><div id="plM_strain" class="mono" style="font-size:18px;">—</div></div>
    </div>

    <!-- Insights OUTSIDE the metrics grid -->
    <h4 class="mt-8">Insights</h4>
    <div id="plInsights" class="pl-insights"></div>

    <div class="card" style="margin-top:12px;">
      <div class="sectionTitle">14-Day Trend</div>
      <canvas id="plChart" height="160"></canvas>
      <div id="plChartNote" class="muted" style="margin-top:6px;"></div>
    </div>

    <div class="grid g2" style="margin-top:12px;">
      <div class="card">
        <div class="sectionTitle">Positives</div>
        <ul id="plPos"><li class="muted">—</li></ul>
      </div>
      <div class="card">
        <div class="sectionTitle">Suggestions</div>
        <ul id="plSug"><li class="muted">—</li></ul>
      </div>
    </div>
  </div>
</div>










<!-- note library -->
<div id="panel-notes" class="panel">
  <h1>Notes Library</h1>

<div class="notes-filters">
  <div class="filter-block">
    <label for="nPlayer">Player</label>
    <select id="nPlayer"></select>
  </div>

  <div class="filter-block">
    <label for="nCoach">Coach</label>
    <select id="nCoach"></select>
  </div>

  <div class="filter-block">
    <label for="nSession">Session</label>
    <select id="nSession"></select>
  </div>

  <div class="filter-block">
    <label for="nScore">Score</label>
    <select id="nScore">
      <option value="">All</option>
      <option value="bad">Bad (&lt;3.0)</option>
      <option value="ok">OK (3.0–3.99)</option>
      <option value="good">Good (≥4.0)</option>
    </select>
  </div>

  <div class="filter-block">
    <label for="nQ">Search</label>
    <input type="text" id="nQ" placeholder="Search notes…">
  </div>

  <div class="filter-buttons">
    <button id="nApply" class="apply">Apply</button>
    <button id="nClear" class="clear">Clear</button>
  </div>
</div>

  <!-- Message area -->
  <div id="nMsg" class="muted" style="margin:6px 0;"></div>

  <!-- Notes list -->
  <div class="card" style="padding:10px; border:1px solid var(--border); border-radius:12px;">
    <div class="sectionTitle" style="margin-top:0;">Notes</div>
    <div id="notesList"></div>
  </div>
</div>













<!-- SPIRAL FEEDBACK -->
<div id="panel-spiralfeedback" class="panel">
  <div style="margin-bottom:24px; display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:12px;">
    <div>
      <h1 style="margin:0 0 8px 0;">Spiral Feedback Dashboard</h1>
      <p class="muted" style="font-size:13px; margin:0;">Track development patterns: Baseline → Dip → Recovery → Exceed</p>
    </div>
    <button id="spiralRefreshAllBtn" class="btn btn-small" onclick="loadSpiralDashboard(true)">↻ Refresh</button>
  </div>

  <div id="spiralDashboardMessage" class="muted" style="font-size:12px; margin-bottom:16px;"></div>

  <!-- Team Summary Card (Hidden - content moved to modal) -->
  <div id="spiralTeamSummary" class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px; display:none;">
    <div id="spiralTeamSummaryContent" style="display:none;"></div>
    <div style="margin-top:24px;">
      <div class="sectionTitle" style="margin:0 0 8px 0;">Team Development Timeline</div>
      <div style="margin-bottom:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button onclick="openCyclesGuideModal()" style="padding:6px 12px; background:rgba(74,168,255,0.1); border:1px solid rgba(74,168,255,0.3); border-radius:6px; color:#4aa8ff; font-size:11px; cursor:pointer; font-weight:500;">ℹ️ How to read cycles</button>
        <button onclick="openTeamOverviewModal()" style="padding:6px 12px; background:rgba(155,89,182,0.1); border:1px solid rgba(155,89,182,0.3); border-radius:6px; color:#9b59b6; font-size:11px; cursor:pointer; font-weight:500;">📊 Team Overview (Last 7 Days)</button>
        <button onclick="openTeamArchetypeModal()" style="padding:6px 12px; background:rgba(74,168,255,0.1); border:1px solid rgba(74,168,255,0.3); border-radius:6px; color:#4aa8ff; font-size:11px; cursor:pointer; font-weight:500;">🎯 Team Development Archetype</button>
      </div>
      <div style="position:relative; height:350px;">
        <canvas id="spiralTeamChart"></canvas>
      </div>
    </div>
  </div>

  <!-- Dashboard Table (Hidden - replaced by cluster chart) -->
  <div class="card" style="padding:16px; border:1px solid var(--border); border-radius:12px; overflow-x:auto; display:none;">
    <div class="sectionTitle" style="margin:0 0 16px 0;">Individual Players</div>
    <div id="spiralDashboardTable">
      <div class="muted" style="text-align:center; padding:40px;">Loading player data...</div>
    </div>
  </div>
  
  <!-- Archetype Visualizations -->
  <div id="spiralArchetypeViz" class="card" style="display:none; margin-top:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
    <!-- Will be populated by renderArchetypeVisualizations -->
  </div>

  <!-- Team Overview Modal -->
  <div id="spiralTeamOverviewModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:10000; align-items:center; justify-content:center; overflow:auto; padding:20px;">
    <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:95%; max-width:700px; padding:24px; position:relative; max-height:90vh; overflow:auto;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h2 style="margin:0; color:#e9edf6; font-size:20px;">📊 Team Overview (Last 7 Days)</h2>
        <button onclick="closeTeamOverviewModal()" style="background:transparent; border:none; color:#9aa5be; font-size:24px; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:6px; transition:background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">×</button>
      </div>
      
      <!-- Team Summary Content -->
      <div id="teamOverviewModalContent" style="display:grid; gap:16px;">
        <div class="muted" style="text-align:center; padding:20px;">Loading...</div>
      </div>
      
      <!-- Theme Frequency -->
      <div id="teamOverviewModalThemes" class="card" style="margin-top:16px;">
        <div class="sectionTitle">Clip Theme Frequency</div>
        <div id="teamOverviewThemeChips"></div>
      </div>
    </div>
  </div>

  <!-- Team Development Archetype Modal -->
  <div id="spiralTeamArchetypeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:10000; align-items:center; justify-content:center; overflow:auto; padding:20px;">
    <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:95%; max-width:700px; padding:24px; position:relative; max-height:90vh; overflow:auto;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h2 style="margin:0; color:#e9edf6; font-size:20px;">🎯 Team Development Archetype</h2>
        <button onclick="closeTeamArchetypeModal()" style="background:transparent; border:none; color:#9aa5be; font-size:24px; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:6px; transition:background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">×</button>
      </div>
      <div id="teamArchetypeModalContent">
        <div class="muted" style="text-align:center; padding:20px;">Loading...</div>
      </div>
    </div>
  </div>

  <!-- Cycles Guide Modal -->
  <div id="spiralCyclesGuideModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:10000; align-items:center; justify-content:center; overflow:auto; padding:20px;">
    <div style="background:#14181f; border:1px solid #2a3448; border-radius:12px; width:95%; max-width:600px; padding:24px; position:relative; max-height:90vh; overflow:auto;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h2 style="margin:0; color:#e9edf6; font-size:20px;">How to Read Cycles</h2>
        <button onclick="closeCyclesGuideModal()" style="background:transparent; border:none; color:#9aa5be; font-size:24px; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:6px; transition:background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">×</button>
      </div>
      <div class="muted" style="font-size:13px; line-height:1.7; color:#cbd6ee;">
        
        <!-- Main Rating Line -->
        <div style="margin-bottom:20px; padding:12px; background:rgba(74,168,255,0.08); border-radius:8px; border-left:3px solid #4aa8ff;">
          <strong style="color:#4aa8ff; display:block; margin-bottom:8px; font-size:14px;">📈 Main Rating Line</strong>
          <div style="padding-left:4px;">
            <div style="margin-bottom:4px;">• <span style="color:#4aa8ff;">Blue line</span> shows the rating over time</div>
            <div style="font-size:12px; margin-top:6px; color:#9aa5be;">This is the primary performance indicator. Follow it to see how ratings change across sessions.</div>
          </div>
        </div>
        
        <!-- Baselines -->
        <div style="margin-bottom:20px; padding:12px; background:rgba(121,131,154,0.08); border-radius:8px; border-left:3px solid #79839a;">
          <strong style="color:#79839a; display:block; margin-bottom:8px; font-size:14px;">📊 Baselines (Line 1)</strong>
          <div style="padding-left:4px;">
            <div style="margin-bottom:4px;">• <span style="color:#79839a;">Gray dashed lines</span> = Stable performance periods</div>
            <div style="font-size:12px; margin-top:6px; color:#9aa5be;">These show periods where performance is consistent and stable. No significant improvement or decline.</div>
          </div>
        </div>
        
        <!-- Flat Periods -->
        <div style="margin-bottom:20px; padding:12px; background:rgba(121,131,154,0.08); border-radius:8px; border-left:3px solid #79839a;">
          <strong style="color:#79839a; display:block; margin-bottom:8px; font-size:14px;">➖ Flat Periods</strong>
          <div style="padding-left:4px;">
            <div style="margin-bottom:4px;">• <span style="color:#79839a;">Gray shaded areas</span> = Stable but not improving</div>
            <div style="font-size:12px; margin-top:6px; color:#9aa5be;">Performance is stable (consistent) but shows no improvement compared to previous baseline. These are plateau periods that may need intervention to restart growth.</div>
          </div>
        </div>
        
        <!-- Dips -->
        <div style="margin-bottom:20px; padding:12px; background:rgba(255,176,32,0.08); border-radius:8px; border-left:3px solid #ffb020;">
          <strong style="color:#ffb020; display:block; margin-bottom:8px; font-size:14px;">📉 Dips (Line 2)</strong>
          <div style="padding-left:4px;">
            <div style="margin-bottom:6px;">• <span style="color:#ffb020;">Yellow shaded areas</span> = Productive dips (learning)</div>
            <div style="font-size:12px; margin-bottom:8px; color:#9aa5be; padding-left:8px;">Performance drops temporarily while learning new skills or adapting to challenges. This is normal and expected during growth.</div>
            <div style="margin-bottom:6px;">• <span style="color:#ff5a5f;">Red shaded areas</span> = Dangerous dips (concern)</div>
            <div style="font-size:12px; margin-top:4px; color:#9aa5be; padding-left:8px;">Performance drops with concerning patterns (injury, effort, attitude). These require immediate attention and intervention.</div>
          </div>
        </div>
        
        <!-- Inconsistent Performance -->
        <div style="margin-bottom:20px; padding:12px; background:rgba(0,212,255,0.08); border-radius:8px; border-left:3px solid #00d4ff;">
          <strong style="color:#00d4ff; display:block; margin-bottom:8px; font-size:14px;">⚠️ Inconsistent Performance</strong>
          <div style="padding-left:4px;">
            <div style="margin-bottom:4px;">• <span style="color:#00d4ff;">Cyan striped areas</span> = High variability periods</div>
            <div style="font-size:12px; margin-top:6px; color:#9aa5be;">Ratings alternate between highs and lows, showing inconsistent performance. Average may be okay, but consistency is poor. These periods don't qualify as dips but indicate instability.</div>
          </div>
        </div>
        
        <!-- Recoveries -->
        <div style="margin-bottom:20px; padding:12px; background:rgba(46,204,113,0.08); border-radius:8px; border-left:3px solid #2ecc71;">
          <strong style="color:#2ecc71; display:block; margin-bottom:8px; font-size:14px;">📈 Recoveries</strong>
          <div style="padding-left:4px;">
            <div style="margin-bottom:6px;">• <span style="color:#2ecc71;">Green triangle dots</span> = Recovery exceeding baseline (Line 4 - Spiral!)</div>
            <div style="font-size:12px; margin-bottom:8px; color:#9aa5be; padding-left:8px;">Performance recovers and exceeds the previous baseline. This is the goal - true growth and evolution.</div>
            <div style="margin-bottom:6px;">• <span style="color:#ff5a5f;">Red triangle dots</span> = Recovery returning to baseline (Line 3)</div>
            <div style="font-size:12px; margin-top:4px; color:#9aa5be; padding-left:8px;">Performance recovers but only returns to the previous level. No evolution - just maintenance.</div>
          </div>
        </div>
        
        <!-- Other Elements -->
        <div style="margin-bottom:20px; padding:12px; background:rgba(155,89,182,0.08); border-radius:8px; border-left:3px solid #9b59b6;">
          <strong style="color:#9b59b6; display:block; margin-bottom:8px; font-size:14px;">🔮 Projections & Clips</strong>
          <div style="padding-left:4px;">
            <div style="margin-bottom:6px;">• <span style="color:#9b59b6;">Purple dashed line</span> = Projected trajectory (next 3 sessions)</div>
            <div style="font-size:12px; margin-bottom:8px; color:#9aa5be; padding-left:8px;">Forecast based on historical patterns. Shows where performance is likely heading.</div>
            <div style="margin-bottom:4px;">• ▶️ <strong>Play buttons (at top)</strong> = Video clips available</div>
            <div style="font-size:12px; margin-top:4px; color:#9aa5be; padding-left:8px;">Click to view video evidence for that session date.</div>
          </div>
        </div>
        
        <!-- What is a Cycle -->
        <div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px; border-left:3px solid #4aa8ff;">
          <strong style="color:#4aa8ff; display:block; margin-bottom:8px; font-size:14px;">🔄 What is a Cycle?</strong>
          <div style="margin-bottom:6px;"><strong>One cycle = Baseline → Dip → Recovery</strong></div>
          <div style="font-size:12px; margin-top:8px; color:#9aa5be;">Follow the blue line through these phases to understand the learning pattern. A complete cycle shows how a player or team responds to challenges and recovers. The goal is to achieve <strong>Line 4</strong> - recovery that exceeds the previous baseline, creating an upward spiral.</div>
        </div>
      </div>
    </div>
    
    <!-- Prediction Validation Panel -->
    <div class="card" style="margin-top:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:16px;">
        <div class="sectionTitle" style="margin:0;">🔮 Predictions & Accuracy</div>
        <button class="btn btn-small" onclick="loadPredictions()" style="font-size:12px;">Refresh</button>
      </div>
      <div id="predictionsPanel">
        <div class="muted" style="text-align:center; padding:20px;">Loading predictions...</div>
      </div>
    </div>
  </div>

  <!-- Detailed View (hidden by default, shown when player clicked) -->
  <div id="spiralDetailView" style="display:none; margin-top:24px;">
    <div style="margin-bottom:16px;">
      <button class="btn btn-small" onclick="closeSpiralDetail()">← Back to Dashboard</button>
      <div style="margin:16px 0; display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
        <h2 id="spiralDetailPlayerName" style="margin:0;"></h2>
        <div style="flex:1; min-width:200px;">
          <label style="font-size:12px; color:#9aa5be; margin-bottom:4px; display:block;">Switch Player:</label>
          <select id="spiralPlayerSelector" onchange="switchSpiralPlayer(this.value)" style="width:100%; padding:8px 12px; background:rgba(74,168,255,0.1); border:1px solid rgba(74,168,255,0.3); border-radius:6px; color:#e9edf6; font-size:14px;">
            <option value="">Select a player...</option>
          </select>
        </div>
      </div>
    </div>

    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="sectionTitle" style="margin:0 0 8px 0;">Development Timeline</div>
      <div class="muted" style="font-size:11px; margin-bottom:12px; line-height:1.5;">
        <strong>How to read:</strong> Blue line = rating over time. Gray dashed lines = stable baselines. 
        Yellow/red shaded areas = dips (learning periods). Green dots = recovery exceeding baseline (Line 4 - Spiral). 
        Red dots = recovery returning to baseline (Line 3). Purple dashed line = projected trajectory (next 3 sessions). 
        ▶️ Play buttons (at top of chart) = clips available (click to view). 
        Each complete cycle = Baseline → Dip → Recovery.
      </div>
      <div style="position:relative; height:400px;">
        <canvas id="spiralPlayerChart"></canvas>
      </div>
    </div>

    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Current Status</div>
      <div id="spiralCurrentStatus"></div>
    </div>

    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Spiral Metrics</div>
      <div id="spiralMetrics"></div>
    </div>

    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Development Cycles</div>
      <div id="spiralCycles"></div>
    </div>

    <div class="card" style="margin-bottom:24px; padding:16px; border:1px solid var(--border); border-radius:12px;">
      <div class="sectionTitle" style="margin:0 0 16px 0;">Baseline History</div>
      <div id="spiralBaselines"></div>
    </div>

  </div>
</div>

<!-- Coach Notifications Popup -->
<div id="coachNotify"
     style="position:fixed; bottom:20px; right:20px; z-index:20010; display:none;
            background:#1e2530; color:#e9edf6; border:1px solid #2a3448; border-left:3px solid #4aa8ff;
            padding:8px 10px; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); max-width:220px; width:220px;
            transition:opacity 0.3s ease, transform 0.3s ease;">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
    <div id="coachNotifyProgress" style="font-size:10px; color:#a0a8b8; font-weight:500;"></div>
    <div style="display:flex; gap:3px;">
      <button id="coachNotifyMute" class="presence-btn" style="padding:3px 6px; font-size:11px; min-width:24px; min-height:24px;" title="Mute notifications">🔇</button>
      <button id="coachNotifyRefresh" class="presence-btn" style="padding:3px 6px; font-size:11px; min-width:24px; min-height:24px;" title="Refresh notifications">↻</button>
    </div>
  </div>
  <div id="coachNotifyTitle" style="font-weight:700; margin-bottom:3px; font-size:12px; color:#e9edf6; line-height:1.3;"></div>
  <div id="coachNotifyText" style="font-size:11px; line-height:1.35; color:#c8d0e0; margin-bottom:6px;"></div>

  <div id="coachNotifyActions" style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:6px;"></div>

  <div style="display:flex; gap:4px; justify-content:flex-end; align-items:center; padding-top:5px; border-top:1px solid #2a3448;">
    <button id="coachNotifyPrev" class="presence-btn" style="padding:4px 8px; font-size:12px; min-width:28px; min-height:24px;" title="Previous (←)">◂</button>
    <button id="coachNotifyNext" class="presence-btn" style="padding:4px 8px; font-size:12px; min-width:28px; min-height:24px;" title="Next (→)">▸</button>
    <button id="coachNotifyClose" class="presence-btn" style="padding:4px 8px; font-size:12px; min-width:28px; min-height:24px;" title="Close (Esc)">✕</button>
  </div>
</div>


<!-- Ratings Modal -->
<div id="ratingsModal" class="modal" style="display:none;">
  <div class="modal-card">
    <header>
      <div>Coach Ratings</div>
      <button class="icon" onclick="closeRatingsModal()" title="Close">✕</button>
    </header>

    <div class="modal-body">
      <!-- Form line -->
      <div class="rate-form">
        <label>
          <span>Coach</span>
          <select id="rtCoach"></select>
        </label>
        <label>
          <span>Session</span>
          <select id="rtSession"></select>
        </label>
        <label>
          <span>Date</span>
          <input type="date" id="rtDate">
        </label>
        <div class="grow"></div>
        <button class="btn apply" id="rtSaveBtn" onclick="saveRatings()">Save</button>
      </div>

      <!-- Quick fill row -->
      <div class="rate-quickfill">
        <span>Set all to:</span>
        <select id="rtAllVal">
          <option value="">—</option>
          <option>5</option><option>4</option><option>3</option><option>2</option><option>1</option>
        </select>
        <button class="btn" onclick="applyAll()">Apply to all traits</button>
      </div>

      <!-- Players table -->
      <div class="rate-table">
        <div class="rate-table-hint">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20zm.75 15h-1.5v-6h1.5v6zm0-7.8h-1.5V7h1.5v2.2z"/>
          </svg>
          <span>Scroll to review each player. Headers and names stay pinned so you always know what you are editing.</span>
        </div>
        <div class="rate-table-scroll">
          <table id="rtTable">
            <thead>
              <tr>
                <th class="player-col">Player</th>
                <th data-trait="exec">Exec</th>
                <th data-trait="energy">Energy</th>
                <th data-trait="comm">Comm</th>
                <th data-trait="adapt">Adapt</th>
                <th data-trait="resilience">Resilience</th>
                <th data-trait="impact">Impact</th>
                <th style="min-width:300px;">Notes</th>
              </tr>
            </thead>
            <tbody><!-- rows injected --></tbody>
          </table>
        </div>
      </div>

      <div id="rtMsg" class="muted rate-message"></div>
    </div>
  </div>
</div>




    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
(function(){
  function decodeBase64Utf8(data) {
    if (!data) return '';
    const binary = atob(data);
    try {
      if (typeof TextDecoder === 'function') {
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return new TextDecoder('utf-8').decode(bytes);
      }
    } catch (err) {
      console.warn('TextDecoder failed; falling back to escape/decodeURIComponent.', err);
    }
    return decodeURIComponent(escape(binary));
  }

  function bootstrapScript() {
    try {
      const base64 = `<?!= include('tmp_script_base64'); ?>`;
      if (!base64 || base64.trim() === '') {
        console.error('Failed to bootstrap client bundle - base64 is empty');
        return;
      }
      const raw = decodeBase64Utf8(base64);
      if (!raw || raw.trim() === '') {
        console.error('Failed to bootstrap client bundle - decoded script is empty');
        return;
      }
      // Wrap in try-catch to handle any errors during execution
      try {
        new Function(raw)();
        console.log('Client bundle bootstrapped successfully');
        // Test if stats function is available - wait a bit for functions to be exposed
        setTimeout(function() {
          if (typeof window.loadStats === 'function') {
            console.log('✓ loadStats function is available');
          } else {
            console.warn('✗ loadStats function NOT found');
            console.warn('Available window functions:', Object.keys(window).filter(k => k.includes('load')).join(', '));
          }
          if (typeof window.tabLoaders === 'object' && window.tabLoaders && typeof window.tabLoaders.stats === 'function') {
            console.log('✓ tabLoaders.stats function is available');
          } else {
            console.warn('✗ tabLoaders.stats function NOT found');
            console.warn('window.tabLoaders type:', typeof window.tabLoaders);
            if (window.tabLoaders) {
              console.warn('tabLoaders keys:', Object.keys(window.tabLoaders));
            }
          }
        }, 500); // Increased delay to 500ms
      } catch (execErr) {
        console.error('Error executing client bundle:', execErr);
        console.error('This might be a syntax error or missing dependency');
        console.error('Error details:', execErr.message, execErr.stack);
        // Don't fail completely - the app might still work with some features
      }
    } catch (err) {
      console.error('Failed to bootstrap client bundle', err);
      console.error('Error details:', err.message, err.stack);
    }
  }
  
  // Wait for DOM to be ready before bootstrapping
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bootstrapScript);
  } else {
    // DOM is already ready, but wait a bit to ensure all elements are parsed
    setTimeout(bootstrapScript, 0);
  }
})();
    </script>

    <script>
// Fix button responsiveness issues
(function(){
  // Ensure login overlay is properly hidden
  function ensureLoginOverlayHidden() {
    const overlay = document.getElementById('loginOverlay');
    if (!overlay) return;
    
    // If user is logged in, force hide overlay
    if (window.CURRENT_USER_NAME) {
      const isHidden = overlay.style.display === 'none' || 
                       overlay.classList.contains('hidden') ||
                       overlay.style.visibility === 'hidden';
      if (!isHidden) {
        console.log('Login overlay still visible after login, hiding...');
        overlay.style.display = 'none';
        overlay.style.visibility = 'hidden';
        overlay.style.pointerEvents = 'none';
        overlay.classList.add('hidden');
      }
    }
  }
  
  // Check periodically and on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureLoginOverlayHidden);
  } else {
    ensureLoginOverlayHidden();
  }
  
  // One follow-up check after page load
  setTimeout(ensureLoginOverlayHidden, 500);
  
  // Removed aggressive polling for user name changes; rely on click handlers and one-off checks
  
  // Ensure buttons with onclick handlers have proper cursor styling
  document.addEventListener('DOMContentLoaded', function() {
    const buttons = document.querySelectorAll('button[onclick], .btn[onclick], button.btn');
    buttons.forEach(function(btn) {
      if (!btn.style.cursor) {
        btn.style.cursor = 'pointer';
      }
    });
  });
  
  // Ensure all button onclick handlers work properly
  function ensureButtonHandlers() {
    // Find all buttons with onclick attributes
    const buttons = document.querySelectorAll('button[onclick]');
    buttons.forEach(function(button) {
      // Ensure button is clickable
      if (button.style.pointerEvents === 'none') {
        button.style.pointerEvents = 'auto';
      }
      if (button.style.cursor === 'none' || !button.style.cursor) {
        button.style.cursor = 'pointer';
      }
      
      // Double-check onclick handler exists
      const onclick = button.getAttribute('onclick');
      if (onclick && onclick.trim()) {
        // Try to validate the handler exists
        try {
          // If onclick references a function, check if it exists
          const fnMatch = onclick.match(/(\w+)\(/);
          if (fnMatch && fnMatch[1]) {
            const fnName = fnMatch[1];
            // Check if function exists globally
            if (typeof window[fnName] !== 'function' && typeof eval(fnName) !== 'function') {
              console.warn('Button onclick handler function not found:', fnName, button);
            }
          }
        } catch (e) {
          // Ignore errors in validation
        }
      }
    });
  }
  
  // Run on DOM ready and after a delay to catch dynamically added buttons
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureButtonHandlers);
  } else {
    ensureButtonHandlers();
  }
  setTimeout(ensureButtonHandlers, 500);
  
  // Add click event delegation for buttons that might not be working
  document.addEventListener('click', function(e) {
    // Check if click was on a button or inside a button
    const button = e.target.closest('button');
    if (!button) return;
    
    // If button is disabled, don't do anything
    if (button.disabled) return;
    
    // IMPORTANT: Allow clicks on buttons INSIDE the login overlay (like the "Unlock" button)
    const loginOverlay = document.getElementById('loginOverlay');
    if (loginOverlay && loginOverlay.contains(button)) {
      // This button is inside the login overlay - always allow it to work
      return; // Don't block login buttons!
    }
    
    // IMPORTANT: Allow clicks on buttons INSIDE modals (like summary modal, feedback modal, etc.)
    const modals = ['createSummaryModal', 'summaryViewModal', 'feedbackModal', 'clipModal', 'reportModal', 'playerDetailModal', 'ratingsModal'];
    for (const modalId of modals) {
      const modal = document.getElementById(modalId);
      if (modal && modal.contains(button)) {
        // This button is inside a modal - always allow it to work
        return; // Don't block modal buttons!
      }
    }
    
    // Check if there's a login overlay blocking OTHER buttons (not inside the overlay)
    if (loginOverlay) {
      // Check if overlay is actually visible
      const isVisible = loginOverlay.style.display !== 'none' && 
                       loginOverlay.style.display !== '' &&
                       loginOverlay.style.visibility !== 'hidden' &&
                       !loginOverlay.classList.contains('hidden') &&
                       window.getComputedStyle(loginOverlay).display !== 'none' &&
                       window.getComputedStyle(loginOverlay).visibility !== 'hidden';
      
      // If user is logged in but overlay is visible, hide it and allow click
      if (window.CURRENT_USER_NAME && isVisible) {
        console.log('Forcing login overlay to hide - user is logged in');
        loginOverlay.style.display = 'none';
        loginOverlay.style.visibility = 'hidden';
        loginOverlay.style.pointerEvents = 'none';
        loginOverlay.classList.add('hidden');
        // Don't block the click - allow it to proceed
      } else if (isVisible && !window.CURRENT_USER_NAME) {
        // User is not logged in and overlay is visible - block clicks on buttons OUTSIDE the overlay
        // But we already checked above that this button is NOT inside the overlay
        e.stopPropagation();
        e.preventDefault();
        return false;
      }
    }
    
    // Check if button has onclick attribute
    const onclick = button.getAttribute('onclick');
    if (onclick) {
      // Ensure onclick handler will execute by checking overlay isn't blocking
      console.log('Button clicked:', button.textContent || button.innerText, 'onclick:', onclick);
    }
  }, true); // Use capture phase to catch before other handlers
})();

// Ensure openClipModal is accessible from player modal and provide fallback
(function(){
  // Helper function to parse time strings
  function parseTime(timeStr) {
    if (!timeStr) return 0;
    const str = String(timeStr);
    if (/^\d+$/.test(str)) return parseInt(str, 10);
    if (/^(\d+)m(\d+)s$/i.test(str)) {
      const match = str.match(/^(\d+)m(\d+)s$/i);
      return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
    }
    return 0;
  }
  
  // Fallback implementation if main function isn't loaded yet
  function fallbackOpenClipModal(url) {
    console.log('[FALLBACK] openClipModal called with:', url ? url.substring(0, 50) : 'no url');
    
    const modal = document.getElementById('clipModal');
    const frame = document.getElementById('clipFrame');
    if (!modal || !frame) {
      console.error('[FALLBACK] Clip modal elements not found');
      return;
    }
    
    // Clear previous video
    if (frame.src && frame.src !== '' && frame.src !== 'about:blank') {
      frame.src = 'about:blank';
    }
    
    // Simple URL normalization for common video platforms
    function normalizeUrl(u) {
      u = String(u || '').trim();
      if (!u) return '';
      
      var embedUrl = '';
      var videoId = '';
      var startParam = '';
      
      // YouTube
      if (/youtu\.be\/([a-zA-Z0-9_-]+)/i.test(u)) {
        var match = u.match(/youtu\.be\/([a-zA-Z0-9_-]+)/i);
        videoId = match[1];
        var params = new URLSearchParams(u.split('?')[1] || '');
        var start = params.get('t') || params.get('start') || '';
        startParam = start ? '?start=' + parseTime(start) + '&autoplay=1' : '?autoplay=1';
        embedUrl = 'https://www.youtube.com/embed/' + videoId + startParam;
      } else if (/youtube\.com\/watch/i.test(u)) {
        try {
          var urlObj = new URL(u);
          videoId = urlObj.searchParams.get('v') || '';
          var start = urlObj.searchParams.get('t') || urlObj.searchParams.get('start') || '';
          startParam = start ? '?start=' + parseTime(start) + '&autoplay=1' : '?autoplay=1';
          embedUrl = 'https://www.youtube.com/embed/' + videoId + startParam;
        } catch(e) {
          embedUrl = u;
        }
      } else if (/vimeo\.com\/(\d+)/i.test(u)) {
        // Vimeo
        var match = u.match(/vimeo\.com\/(\d+)/i);
        videoId = match[1];
        embedUrl = 'https://player.vimeo.com/video/' + videoId + '?autoplay=1';
      } else if (/drive\.google\.com/i.test(u)) {
        // Google Drive
        embedUrl = u;
      } else {
        embedUrl = u;
      }
      
      return embedUrl;
    }
    
    // Lock scroll
    console.log('[FALLBACK] Locking scroll');
    if (typeof window.lockBodyScroll === 'function') {
      window.lockBodyScroll();
    } else {
      document.body.style.overflow = 'hidden';
    }
    
    // Show modal
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.pointerEvents = 'auto';
    
    // Load video in next frame
    requestAnimationFrame(function() {
    const embedUrl = normalizeUrl(url);
      console.log('[FALLBACK] Loading video:', embedUrl ? embedUrl.substring(0, 50) : 'no embed url');
    frame.src = embedUrl;
    });
    
    console.log('[FALLBACK] openClipModal complete');
  }
  
  function fallbackCloseClipModal() {
    console.log('[FALLBACK] closeClipModal called');
    
    const modal = document.getElementById('clipModal');
    const frame = document.getElementById('clipFrame');
    
    // CRITICAL: Hide modal FIRST
    if (modal) {
      modal.style.display = 'none';
      modal.style.visibility = 'hidden';
      modal.style.pointerEvents = 'none';
      console.log('[FALLBACK] Modal hidden');
    }
    
    // Stop video
    if (frame) {
      if (frame.src && frame.src !== '' && frame.src !== 'about:blank') {
        console.log('[FALLBACK] Stopping video');
        frame.src = 'about:blank';
      }
    }
    
    // Unlock scroll
    console.log('[FALLBACK] Unlocking scroll');
    if (typeof window.unlockBodyScroll === 'function') {
      window.unlockBodyScroll();
    } else {
    document.body.style.overflow = '';
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      document.body.style.overflowY = '';
    }
    
    // Final cleanup
    setTimeout(function() {
      if (frame && frame.src !== '') {
        frame.src = '';
        console.log('[FALLBACK] Final cleanup done');
      }
    }, 100);
    
    console.log('[FALLBACK] closeClipModal complete');
  }
  
  // Set up fallback functions on window
  window.openClipModal = window.openClipModal || fallbackOpenClipModal;
  window.closeClipModal = window.closeClipModal || fallbackCloseClipModal;
  
  // This ensures the functions from tmp_script.html override fallbacks when loaded
  function ensureClipModalAccess() {
    // The function should be available from tmp_script.html, but ensure it's on window
    if (typeof openClipModal === 'function') {
      window.openClipModal = openClipModal;
    }
    if (typeof closeClipModal === 'function') {
      window.closeClipModal = closeClipModal;
    }
    if (typeof discussClip === 'function' && !window.discussClip) {
      window.discussClip = discussClip;
    }
  }
  
  // Try to ensure access on DOM ready and periodically
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureClipModalAccess);
  } else {
    ensureClipModalAccess();
  }
  
  // Also ensure after a short delay to catch if tmp_script loads slightly later
  setTimeout(ensureClipModalAccess, 500);
  
  // Add event delegation for clip links in player modal
  document.addEventListener('click', function(e) {
    const pClips = document.getElementById('pClips');
    if (!pClips) return;
    
    // Check if click is within player clips container
    if (pClips.contains(e.target)) {
      const link = e.target.closest('a[data-url]');
      if (link && link.dataset.url) {
        e.preventDefault();
        e.stopPropagation();
        const url = link.dataset.url;
        
        // Call openClipModal - fallback is already set up
        if (typeof window.openClipModal === 'function') {
          window.openClipModal(url);
        } else {
          console.error('openClipModal not available');
        }
        return false;
      }
      
      // Handle discuss clip link
      const discussLink = e.target.closest('a');
      if (discussLink) {
        const onclick = discussLink.getAttribute('onclick');
        if (onclick && onclick.includes('discussClip')) {
          e.preventDefault();
          e.stopPropagation();
          const match = onclick.match(/discussClip\('([^']+)'\)/);
          if (match && match[1]) {
            const encodedUrl = match[1];
            if (typeof window.discussClip === 'function') {
              window.discussClip(encodedUrl);
            } else if (typeof discussClip === 'function') {
              discussClip(encodedUrl);
            }
          }
          return false;
        }
      }
    }
  }, true);
  
  // Also close modal on background click or Escape key
  document.addEventListener('click', function(e) {
    const modal = document.getElementById('clipModal');
    if (modal && modal.style.display !== 'none' && e.target === modal) {
      console.log('[EVENT] Background click detected, calling closeClipModal');
      if (typeof window.closeClipModal === 'function') {
      window.closeClipModal();
      } else {
        console.error('[EVENT] closeClipModal function not found!');
      }
    }
  });
  
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      const modal = document.getElementById('clipModal');
      if (modal && modal.style.display !== 'none') {
        console.log('[EVENT] ESC key detected, calling closeClipModal');
        if (typeof window.closeClipModal === 'function') {
        window.closeClipModal();
        } else {
          console.error('[EVENT] closeClipModal function not found!');
        }
      }
    }
  });
})();

// Player Library Grid View
(function(){
  let playerPhotosCache = new Map();
  window.playerPhotosCache = playerPhotosCache; // Expose globally for clip thumbnails
  let currentModalPlayer = null;
  
  function updatePlayerPhotoForModal(url) {
    const img = document.getElementById('playerModalPhoto');
    if (!img) return;
    if (url) {
      if (img.src !== url) img.src = url;
      img.style.display = 'block';
    } else {
      img.removeAttribute('src');
      img.style.display = 'none';
    }
  }
  
  function openPlayerDetailModal(playerName) {
    const modal = document.getElementById('playerDetailModal');
    const title = document.getElementById('playerModalTitle');
    if (!modal || !title) return;
    
    currentModalPlayer = playerName;
    title.textContent = playerName;
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // Update modal photo immediately if cached
    const cachedUrl = playerPhotosCache.get(playerName);
    if (cachedUrl) {
      updatePlayerPhotoForModal(cachedUrl);
    } else {
      // Load photo immediately
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(function(bundle) {
            if (bundle && bundle.ok && bundle.photoUrl) {
              playerPhotosCache.set(playerName, bundle.photoUrl);
              if (currentModalPlayer === playerName) {
                updatePlayerPhotoForModal(bundle.photoUrl);
              }
            }
          })
          .getPlayerBundle(playerName, 0);
      }
    }
    
    // Load player data if onPlayerChange exists
    if (typeof onPlayerChange === 'function') {
      onPlayerChange(playerName);
    }
  }
  
  function closePlayerDetailModal() {
    const modal = document.getElementById('playerDetailModal');
    if (!modal) return;
    modal.style.display = 'none';
    document.body.style.overflow = '';
    currentModalPlayer = null;
  }
  
  window.openPlayerDetailModal = openPlayerDetailModal;
  window.closePlayerDetailModal = closePlayerDetailModal;
  
  // Override updatePlayerPhoto to also update modal photo if modal is open
  const originalUpdatePhoto = window.updatePlayerPhoto;
  if (originalUpdatePhoto) {
    window.updatePlayerPhoto = function(url) {
      originalUpdatePhoto(url);
      // If modal is open, update modal photo
      if (currentModalPlayer && url) {
        playerPhotosCache.set(currentModalPlayer, url);
        updatePlayerPhotoForModal(url);
      }
    };
  } else {
    window.updatePlayerPhoto = function(url) {
      const img = document.getElementById('playerPhoto');
      const modalImg = document.getElementById('playerModalPhoto');
      if (img) {
        if (url) {
          img.src = url;
          img.style.display = 'block';
        } else {
          img.style.display = 'none';
        }
      }
      // If modal is open, update modal photo
      if (currentModalPlayer && modalImg) {
        if (url) {
          playerPhotosCache.set(currentModalPlayer, url);
          modalImg.src = url;
          modalImg.style.display = 'block';
        } else {
          modalImg.style.display = 'none';
        }
      }
    };
  }
  
  // Trait ratings cache for rankings
  let traitRatingsCache = null;
  let playerRankings = new Map();
  let playerCards = [];
  
  // Game ratings cache
  let gameRatingsCache = null; // { playerName: { avg: number, games: number } }
  
  // Fetch game ratings from Log sheet (GBL/EC games only)
  function fetchGameRatings() {
    if (gameRatingsCache) return Promise.resolve(gameRatingsCache);
    
    return new Promise(function(resolve, reject) {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(function(data) {
            if (data && data.ok && data.players) {
              gameRatingsCache = data.players;
              resolve(data.players);
            } else {
              gameRatingsCache = {};
              resolve({});
            }
          })
          .withFailureHandler(function(err) {
            gameRatingsCache = {};
            resolve({});
          })
          .getGameRatings();
      } else {
        gameRatingsCache = {};
        resolve({});
      }
    });
  }
  
  function getPlayerGameStats(playerName) {
    if (!gameRatingsCache) return null;
    return gameRatingsCache[playerName] || null;
  }
  
  function getPlayerOverallAvg(playerName) {
    if (!traitRatingsCache || !traitRatingsCache.rows) return null;
    
    let overallAvg = null;
    traitRatingsCache.rows.forEach(function(traitRow) {
      const name = String(traitRow[0] || '').trim();
      if (name === playerName) {
        // Extract trait scores (indices 2-7: Exec, Energy, Comm, Adapt, Resilience, Impact)
        const traits = traitRow.slice(2, 8).map(function(val) {
          if (val == null || val === '') return null;
          if (typeof val === 'number') return val;
          const str = String(val).trim();
          if (!str) return null;
          const cleaned = str.replace(',', '.').replace(/[^\d.-]/g, '');
          const num = parseFloat(cleaned);
          return !isNaN(num) && num > 0 ? num : null;
        }).filter(function(v) { return v !== null; });
        
        if (traits.length > 0) {
          overallAvg = traits.reduce(function(a, b) { return a + b; }, 0) / traits.length;
        }
      }
    });
    
    return overallAvg;
  }
  
  function getPlayerTraits(playerName) {
    if (!traitRatingsCache || !traitRatingsCache.rows) return null;
    
    // Headers: ["Player","n","Exec","Energy","Comm","Adapt","Resilience","Impact"]
    const traitNames = ['Exec', 'Energy', 'Comm', 'Adapt', 'Resilience', 'Impact'];
    
    let traitsData = null;
    traitRatingsCache.rows.forEach(function(traitRow) {
      const name = String(traitRow[0] || '').trim();
      if (name === playerName) {
        // Extract trait scores (indices 2-7: Exec, Energy, Comm, Adapt, Resilience, Impact)
        const traits = [];
        for (let i = 2; i < 8; i++) {
          const val = traitRow[i];
          let num = null;
          if (val == null || val === '') {
            num = null;
          } else if (typeof val === 'number') {
            num = val;
          } else {
            const str = String(val).trim();
            if (!str) {
              num = null;
            } else {
              const cleaned = str.replace(',', '.').replace(/[^\d.-]/g, '');
              num = parseFloat(cleaned);
              if (isNaN(num) || num <= 0) num = null;
            }
          }
          
          if (num !== null) {
            traits.push({
              name: traitNames[i - 2],
              value: num
            });
          }
        }
        
        if (traits.length > 0) {
          // Find highest and lowest
          let highest = traits[0];
          let lowest = traits[0];
          
          traits.forEach(function(trait) {
            if (trait.value > highest.value) {
              highest = trait;
            }
            if (trait.value < lowest.value) {
              lowest = trait;
            }
          });
          
          traitsData = {
            highest: highest,
            lowest: lowest,
            all: traits
          };
        }
      }
    });
    
    return traitsData;
  }
  
  function addTraitsStats(card, playerName) {
    const traitsData = getPlayerTraits(playerName);
    
    // Remove existing traits stats if any
    const existing = card.querySelector('.player-card-traits');
    if (existing) existing.remove();
    
    if (!traitsData || !traitsData.highest || !traitsData.lowest) {
      return;
    }
    
    const traitsDiv = document.createElement('div');
    traitsDiv.className = 'player-card-traits';
    
    // Strongest trait
    const strongestSpan = document.createElement('span');
    strongestSpan.className = 'player-card-traits-item';
    const strongestLabel = document.createElement('span');
    strongestLabel.className = 'player-card-traits-label';
    strongestLabel.textContent = 'Strongest: ';
    strongestSpan.appendChild(strongestLabel);
    const strongestValue = document.createElement('span');
    strongestValue.className = 'player-card-traits-value player-card-traits-strongest';
    strongestValue.textContent = traitsData.highest.name + ' (' + traitsData.highest.value.toFixed(1) + ')';
    strongestSpan.appendChild(strongestValue);
    traitsDiv.appendChild(strongestSpan);
    
    // Separator
    const separator = document.createElement('span');
    separator.className = 'player-card-traits-item';
    separator.textContent = ' | ';
    separator.style.margin = '0 4px';
    traitsDiv.appendChild(separator);
    
    // Weakest trait
    const weakestSpan = document.createElement('span');
    weakestSpan.className = 'player-card-traits-item';
    const weakestLabel = document.createElement('span');
    weakestLabel.className = 'player-card-traits-label';
    weakestLabel.textContent = 'Weakest: ';
    weakestSpan.appendChild(weakestLabel);
    const weakestValue = document.createElement('span');
    weakestValue.className = 'player-card-traits-value player-card-traits-weakest';
    weakestValue.textContent = traitsData.lowest.name + ' (' + traitsData.lowest.value.toFixed(1) + ')';
    weakestSpan.appendChild(weakestValue);
    traitsDiv.appendChild(weakestSpan);
    
    card.appendChild(traitsDiv);
  }
  
  function addGameStats(card, playerName) {
    const stats = getPlayerGameStats(playerName);
    const overallAvg = getPlayerOverallAvg(playerName);
    
    // Remove existing stats if any
    const existing = card.querySelector('.player-card-game-stats');
    if (existing) existing.remove();
    
    // Only show if we have game stats
    if (!stats || stats.games === 0) {
      return;
    }
    
    const statsDiv = document.createElement('div');
    statsDiv.className = 'player-card-game-stats';
    
    // Average game rating
    const gameItem = document.createElement('div');
    gameItem.className = 'player-card-game-stats-item';
    
    const gameLabel = document.createElement('span');
    gameLabel.className = 'player-card-game-stats-label';
    gameLabel.textContent = 'Avg game rating:';
    gameItem.appendChild(gameLabel);
    
    const gameValue = document.createElement('span');
    gameValue.className = 'player-card-game-stats-value';
    gameValue.textContent = stats.avg.toFixed(1) + ' (' + stats.games + ' ' + (stats.games === 1 ? 'game' : 'games') + ')';
    gameItem.appendChild(gameValue);
    
    statsDiv.appendChild(gameItem);
    
    // Overall average rating (if available)
    if (overallAvg !== null) {
      const overallItem = document.createElement('div');
      overallItem.className = 'player-card-game-stats-item';
      
      const overallLabel = document.createElement('span');
      overallLabel.className = 'player-card-game-stats-label';
      overallLabel.textContent = 'Avg overall rating:';
      overallItem.appendChild(overallLabel);
      
      const overallValue = document.createElement('span');
      overallValue.className = 'player-card-game-stats-value';
      overallValue.textContent = overallAvg.toFixed(1);
      overallItem.appendChild(overallValue);
      
      statsDiv.appendChild(overallItem);
    }
    
    card.appendChild(statsDiv);
  }
  
  // Fetch trait ratings and calculate rankings
  function fetchTraitRatingsAndRank() {
    if (traitRatingsCache) return Promise.resolve(traitRatingsCache);
    
    return new Promise(function(resolve, reject) {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(function(data) {
            if (data && data.ok && data.headers && data.rows) {
              traitRatingsCache = data;
              
              // Calculate total avg rating for each player and rank them
              const playersWithRatings = [];
              const headers = data.headers; // ["Player","n","Exec","Energy","Comm","Adapt","Resilience","Impact"]
              
              data.rows.forEach(function(row) {
                const playerName = String(row[0] || '').trim();
                if (!playerName) return;
                
                // Extract trait scores (indices 2-7: Exec, Energy, Comm, Adapt, Resilience, Impact)
                const traits = row.slice(2, 8).map(function(val) {
                  const num = parseFloat(String(val || '').replace(',', '.'));
                  return isNaN(num) ? null : num;
                }).filter(function(v) { return v !== null; });
                
                // Calculate average
                const avgRating = traits.length > 0 
                  ? traits.reduce(function(a, b) { return a + b; }, 0) / traits.length 
                  : null;
                
                if (avgRating !== null) {
                  playersWithRatings.push({
                    player: playerName,
                    avgRating: avgRating
                  });
                }
              });
              
              // Sort by avgRating descending
              playersWithRatings.sort(function(a, b) {
                return b.avgRating - a.avgRating;
              });
              
              // Assign rankings
              playersWithRatings.forEach(function(item, index) {
                playerRankings.set(item.player, index + 1);
              });
              
              resolve(data);
            } else {
              resolve(null);
            }
          })
          .withFailureHandler(function(err) {
            console.error('Failed to load trait ratings:', err);
            resolve(null);
          })
          .getTraitRatingsGrid();
      } else {
        resolve(null);
      }
    });
  }
  
  function getPlayerRank(playerName) {
    return playerRankings.get(playerName) || null;
  }
  
  function getTotalRankedPlayers() {
    return playerRankings.size;
  }
  
  function addRankingBadge(card, playerName) {
    const rank = getPlayerRank(playerName);
    if (rank !== null) {
      // Remove existing badge if any
      const existingBadge = card.querySelector('.player-card-ranking');
      if (existingBadge) existingBadge.remove();
      
      const totalRanked = getTotalRankedPlayers();
      const rankBadge = document.createElement('div');
      rankBadge.className = 'player-card-ranking';
      
      // Top 3 get gold, last 3 get red
      if (rank <= 3) {
        rankBadge.classList.add('top-3');
      } else if (totalRanked >= 3 && rank > totalRanked - 3) {
        rankBadge.classList.add('bottom-3');
      }
      
      rankBadge.textContent = rank;
      card.appendChild(rankBadge);
    }
  }
  
  let isRenderingPlayerGrid = false;
  
  function renderPlayerLibraryGrid(players) {
    const grid = document.getElementById('playerLibraryGrid');
    if (!grid) {
      console.error('playerLibraryGrid element not found');
      return;
    }
    
    if (!Array.isArray(players)) {
      console.error('Invalid players array:', players);
      return;
    }
    
    // Prevent overlapping renders
    if (isRenderingPlayerGrid) {
      console.log('Already rendering player grid, skipping duplicate call');
      return;
    }
    isRenderingPlayerGrid = true;
    
    // Ensure grid is visible
    grid.style.display = 'grid';
    grid.style.visibility = 'visible';
    grid.style.opacity = '1';
    
    grid.innerHTML = '';
    playerCards = [];
    
    console.log('Rendering player grid with', players.length, 'players:', players);
    
    if (players.length === 0) {
      console.warn('No players to render');
      grid.innerHTML = '<div style="padding:40px; text-align:center; color:var(--muted);">No players found</div>';
      isRenderingPlayerGrid = false;
      return;
    }
    
    // Fetch trait ratings first to sort players by rating
    // Also fetch game ratings in parallel
    Promise.all([
      fetchTraitRatingsAndRank(),
      fetchGameRatings()
    ]).then(function() {
      // Sort players by ranking (highest to lowest)
      const sortedPlayers = players.slice().sort(function(a, b) {
        const rankA = getPlayerRank(a) || 9999; // Players without ranking go to end
        const rankB = getPlayerRank(b) || 9999;
        return rankA - rankB; // Lower rank number = higher rating
      });
      
      // Render players in sorted order
      renderPlayersInGrid(sortedPlayers);
      isRenderingPlayerGrid = false;
    }).catch(function(err) {
      // Render unsorted if ratings fail
      renderPlayersInGrid(players);
      isRenderingPlayerGrid = false;
    });
  }
  
  function renderPlayersInGrid(players) {
    const grid = document.getElementById('playerLibraryGrid');
    if (!grid) return;
    
    // Clear the grid to prevent duplicates
    grid.innerHTML = '';
    playerCards = [];
    
    players.forEach(function(playerName, index) {
      // More explicit filtering - only skip if null, undefined, or empty string
      if (playerName == null || String(playerName).trim() === '') {
        console.warn('Skipping invalid player at index', index, ':', playerName);
        return;
      }
      
      const card = document.createElement('div');
      card.className = 'player-card';
      card.dataset.playerName = playerName;
      card.dataset.index = index;
      
      // Open modal on click
      card.onclick = function() {
        openPlayerDetailModal(playerName);
      };
      
      // Add ranking badge if available (will be updated when trait ratings load)
      addRankingBadge(card, playerName);
      
      // Try to get photo from cache or load it
      const cachedUrl = playerPhotosCache.get(playerName);
      const photoUrl = cachedUrl || '';
      
      if (photoUrl) {
        const img = document.createElement('img');
        img.className = 'player-card-photo';
        img.src = photoUrl;
        img.alt = playerName;
        img.onerror = function() {
          this.style.display = 'none';
          const placeholder = card.querySelector('.player-card-no-photo');
          if (placeholder) placeholder.style.display = 'flex';
        };
        card.appendChild(img);
        
        const noPhoto = document.createElement('div');
        noPhoto.className = 'player-card-no-photo';
        noPhoto.style.display = 'none';
        noPhoto.textContent = '🏀';
        card.appendChild(noPhoto);
      } else {
        const noPhoto = document.createElement('div');
        noPhoto.className = 'player-card-no-photo';
        noPhoto.textContent = '🏀';
        card.appendChild(noPhoto);
        
                 // Load photo asynchronously
                 if (typeof google !== 'undefined' && google.script && google.script.run) {
                   google.script.run
                     .withSuccessHandler(function(bundle) {
                       if (bundle && bundle.ok && bundle.photoUrl) {
                         playerPhotosCache.set(playerName, bundle.photoUrl);
                         const img = card.querySelector('img');
                         const placeholder = card.querySelector('.player-card-no-photo');
                         if (img) {
                           img.src = bundle.photoUrl;
                           img.style.display = 'block';
                           if (placeholder) placeholder.style.display = 'none';
                         } else if (placeholder) {
                           placeholder.style.display = 'none';
                           const newImg = document.createElement('img');
                           newImg.className = 'player-card-photo';
                           newImg.src = bundle.photoUrl;
                           newImg.alt = playerName;
                           newImg.onerror = function() {
                             this.style.display = 'none';
                             if (placeholder) placeholder.style.display = 'flex';
                           };
                           card.insertBefore(newImg, placeholder);
                         }
                       } else {
                         // If bundle doesn't have photo, check if placeholder should show
                         const placeholder = card.querySelector('.player-card-no-photo');
                         if (placeholder && placeholder.style.display === 'none') {
                           placeholder.style.display = 'flex';
                         }
                       }
                     })
                     .withFailureHandler(function(err) {
                       // If photo load fails, ensure placeholder is visible
                       const placeholder = card.querySelector('.player-card-no-photo');
                       const img = card.querySelector('img');
                       if (img) img.style.display = 'none';
                       if (placeholder) placeholder.style.display = 'flex';
                     })
                     .getPlayerBundle(playerName, 0);
                 }
      }
      
      const nameDiv = document.createElement('div');
      nameDiv.className = 'player-card-name';
      nameDiv.textContent = playerName;
      card.appendChild(nameDiv);
      
      // Add game stats placeholder (will be updated when game ratings load)
      
      grid.appendChild(card);
      playerCards.push(card);
    });
    
    // Update all cards with rankings and game stats
    // Note: Ratings were already fetched in renderPlayerLibraryGrid, so we just update the UI
    if (playerCards.length > 0) {
      playerCards.forEach(function(card) {
        const playerName = card.dataset.playerName;
        if (playerName) {
          addRankingBadge(card, playerName);
          addGameStats(card, playerName);
          addTraitsStats(card, playerName);
        }
      });
    }
  }
  
  // Override loadPlayers to render grid instead
  const originalLoadPlayers = window.loadPlayers;
  if (originalLoadPlayers) {
    window.loadPlayers = function(force) {
      const cached = Array.isArray(window.dataCache && window.dataCache.playersList) ? window.dataCache.playersList : null;
      if (!force && cached && cached.length) {
        renderPlayerLibraryGrid(cached);
        return;
      }
      
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(function(list) {
            // Don't filter - get all players including empty strings (will be filtered in renderPlayerLibraryGrid)
            const arr = Array.isArray(list) ? list : [];
            // Filter out only null, undefined, and empty strings
            const filtered = arr.filter(function(name) {
              return name != null && String(name).trim() !== '';
            });
            if (window.dataCache) window.dataCache.playersList = filtered;
            console.log('Loaded players:', filtered.length, filtered);
            renderPlayerLibraryGrid(filtered);
          })
          .withFailureHandler(function(err) {
            console.error('getPlayers error:', err);
            renderPlayerLibraryGrid([]);
          })
          .getPlayers();
      }
    };
  } else {
    window.loadPlayers = function(force) {
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            google.script.run
              .withSuccessHandler(function(list) {
                // Don't filter - get all players including empty strings (will be filtered in renderPlayerLibraryGrid)
                const arr = Array.isArray(list) ? list : [];
                // Filter out only null, undefined, and empty strings
                const filtered = arr.filter(function(name) {
                  return name != null && String(name).trim() !== '';
                });
                console.log('Loaded players:', filtered.length, filtered);
                renderPlayerLibraryGrid(filtered);
              })
              .withFailureHandler(function(err) {
                console.error('getPlayers error:', err);
                renderPlayerLibraryGrid([]);
              })
              .getPlayers();
          }
    };
  }
  
  // Close modal on background click
  document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('playerDetailModal');
    if (modal) {
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          closePlayerDetailModal();
        }
      });
    }
    
    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        const modal = document.getElementById('playerDetailModal');
        if (modal && modal.style.display !== 'none') {
          closePlayerDetailModal();
        }
      }
    });
  });
})();

// Admin Portal Functions
function loadAdminStats() {
  console.log('loadAdminStats called');
  const summaryEl = document.getElementById('adminSummaryContent');
  const userStatsEl = document.getElementById('adminUserStats');
  const recentActivityEl = document.getElementById('adminRecentActivity');
  const sessionsEl = document.getElementById('adminSessions');
  
  console.log('Elements found:', {
    summary: !!summaryEl,
    userStats: !!userStatsEl,
    recentActivity: !!recentActivityEl,
    sessions: !!sessionsEl
  });
  
  const allEls = [summaryEl, document.getElementById('adminLeaderboard'), document.getElementById('adminFeatureUsage'), document.getElementById('adminPlayerCoverage'), recentActivityEl, sessionsEl];
  allEls.forEach(el => {
    if (el) {
      el.style.color = '#a0a8b8';
      el.textContent = 'Loading...';
    }
  });

  google.script.run
    .withSuccessHandler(function(res) {
      console.log('Admin stats response received:', res);
      
      // Handle case where res is null/undefined
      if (res === null || res === undefined) {
        console.error('Received null/undefined response');
        const allElements = [summaryEl, document.getElementById('adminLeaderboard'), document.getElementById('adminFeatureUsage'), document.getElementById('adminPlayerCoverage'), document.getElementById('adminRecentActivity'), document.getElementById('adminSessions')];
        allElements.forEach(el => {
          if (el) el.innerHTML = '<div class="muted" style="color:#ff5a5f;">Server returned no data. Please check console for errors.</div>';
        });
        return;
      }
      
      const allElements = [summaryEl, document.getElementById('adminLeaderboard'), document.getElementById('adminFeatureUsage'), document.getElementById('adminPlayerCoverage'), document.getElementById('adminRecentActivity'), document.getElementById('adminSessions')];
      
      if (!res) {
        const msg = 'No response from server. Please try refreshing.';
        allElements.forEach(el => {
          if (el) el.innerHTML = '<div class="muted" style="color:#ff5a5f;">' + msg + '</div>';
        });
        return;
      }
      
      if (!res.ok) {
        const msg = (res && res.error) || 'Failed to load admin stats.';
        allElements.forEach(el => {
          if (el) el.innerHTML = '<div class="muted" style="color:#ff5a5f;">' + escapeHtml(msg) + '</div>';
        });
        // Even on error, try to show what we have
        if (res.summary) {
          renderSummary(summaryEl, res.summary);
        }
        return;
      }

      // Helper function to render summary
      function renderSummary(el, s) {
        if (!el) return;
        if (!s) {
          el.innerHTML = '<div class="muted">No summary data available yet. Data will appear as users interact with the app.</div>';
          return;
        }
        el.innerHTML = `
          <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:16px;">
            <div>
              <div style="font-size:24px; font-weight:700;">${s.totalUsers || 0}</div>
              <div class="muted" style="font-size:12px;">Total Users</div>
            </div>
            <div>
              <div style="font-size:24px; font-weight:700;">${s.totalLogins || 0}</div>
              <div class="muted" style="font-size:12px;">Total Logins</div>
            </div>
            <div>
              <div style="font-size:24px; font-weight:700;">${s.totalRatings || 0}</div>
              <div class="muted" style="font-size:12px;">Total Ratings</div>
            </div>
            <div>
              <div style="font-size:24px; font-weight:700;">${s.totalNotes || 0}</div>
              <div class="muted" style="font-size:12px;">Total Notes</div>
            </div>
          </div>
        `;
      }
      
      // Summary - always render, even if empty
      renderSummary(summaryEl, res.summary);

      // Leaderboard (sorted by engagement score, Dimitris first)
      const leaderboardEl = document.getElementById('adminLeaderboard');
      console.log('User stats count:', res.userStats ? res.userStats.length : 0);
      console.log('Sessions count:', res.sessions ? res.sessions.length : 0);
      if (leaderboardEl && res.userStats && res.userStats.length > 0) {
        leaderboardEl.innerHTML = res.userStats.map((u, index) => {
          const hours = Math.floor((u.totalMinutes || 0) / 60);
          const mins = Math.round((u.totalMinutes || 0) % 60);
          // Display last login - ALWAYS use original date string from sheet to avoid timezone issues
          let lastLogin = 'Never';
          
          // First try to use lastLoginString from userStats (most direct - pre-calculated)
          if (u.lastLoginString && String(u.lastLoginString).trim()) {
            lastLogin = String(u.lastLoginString).trim();
          } 
          // Then try to get from sessions array
          else if (res && res.sessions && Array.isArray(res.sessions)) {
            const userLogins = res.sessions.filter(s => s.name === u.name && s.event === 'login');
            if (userLogins.length > 0) {
              // Sort by timestamp and get most recent
              const recentLogin = userLogins.sort((a, b) => {
                const tsA = typeof a.timestamp === 'number' ? a.timestamp : 0;
                const tsB = typeof b.timestamp === 'number' ? b.timestamp : 0;
                return tsB - tsA;
              })[0];
              
              if (recentLogin && recentLogin.timestampString && String(recentLogin.timestampString).trim()) {
                lastLogin = String(recentLogin.timestampString).trim();
              }
            }
          }
          const medal = index === 0 && u.name !== 'Dimitris' ? '🥇' : index === 1 && u.name !== 'Dimitris' ? '🥈' : index === 2 && u.name !== 'Dimitris' ? '🥉' : '';
          const streakEmoji = u.streak >= 7 ? '🔥' : u.streak >= 3 ? '⚡' : '';
          return `
            <div style="padding:12px; margin-bottom:8px; background:#0f131a; border-radius:8px; border:1px solid var(--border); cursor:pointer;" onclick="showUserDetail('${escapeHtml(u.name)}')">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                <div style="font-weight:600;">${medal} ${escapeHtml(u.name)}</div>
                <div style="font-size:11px; color:#4CAF50; font-weight:600;">Score: ${u.engagementScore || 0}</div>
              </div>
              <div style="font-size:12px; color:#a0a8b8;">
                <div>📊 ${u.ratingsCount} ratings • 📝 ${u.notesCount} notes</div>
                <div>🔐 ${u.logins} logins • ⏱️ ${hours}h ${mins}m</div>
                <div>${streakEmoji} ${u.streak || 0}-day streak • 🕐 ${lastLogin}</div>
              </div>
            </div>
          `;
        }).join('');
      } else if (leaderboardEl) {
        leaderboardEl.innerHTML = '<div class="muted">No user statistics yet. Statistics will appear after users log in and use the app.</div>';
      }

      // Feature Usage
      const featureUsageEl = document.getElementById('adminFeatureUsage');
      if (featureUsageEl && res.featureUsage) {
        const features = Object.entries(res.featureUsage)
          .map(([name, count]) => ({ name, count }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 15);
        
        if (features.length > 0) {
          featureUsageEl.innerHTML = features.map(f => `
            <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px; display:flex; justify-content:space-between;">
              <span>${escapeHtml(f.name)}</span>
              <span style="font-weight:600; color:#4CAF50;">${f.count}</span>
            </div>
          `).join('');
        } else {
          featureUsageEl.innerHTML = '<div class="muted">No feature usage data yet. Feature tracking starts when users switch tabs.</div>';
        }
      }

      // Player Coverage
      const playerCoverageEl = document.getElementById('adminPlayerCoverage');
      if (playerCoverageEl && res.playerCoverage && res.playerCoverage.length > 0) {
        playerCoverageEl.innerHTML = res.playerCoverage.map((p, index) => {
          const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '';
          return `
            <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                <span style="font-weight:600;">${medal} ${escapeHtml(p.player)}</span>
                <span style="color:#4CAF50;">${p.ratings} ratings</span>
              </div>
              ${p.notes > 0 ? `<div style="font-size:11px; color:#a0a8b8;">📝 ${p.notes} notes</div>` : ''}
            </div>
          `;
        }).join('');
      } else if (playerCoverageEl) {
        playerCoverageEl.innerHTML = '<div class="muted">No player coverage data yet. Data will appear as coaches rate players.</div>';
      }

      // Recent Activity
      if (recentActivityEl && res.recentActivities) {
        if (res.recentActivities.length === 0) {
          recentActivityEl.innerHTML = '<div class="muted">No recent activity</div>';
        } else {
          // Debug: log first activity to see what we're receiving
          if (res.recentActivities.length > 0) {
            console.log('First activity from server:', JSON.stringify(res.recentActivities[0]));
          }
          recentActivityEl.innerHTML = res.recentActivities.slice(0, 30).map(act => {
            // Use timestampString directly from sheet to avoid timezone conversion
            let time = 'Unknown';
            if (act.timestampString && String(act.timestampString).trim()) {
              time = String(act.timestampString).trim();
              console.log('Activity time from timestampString:', time);
            } else {
              console.log('Activity missing timestampString, act:', act);
            }
            const details = act.details || {};
            let detailText = '';
            if (act.action === 'rating') {
              detailText = `${details.rowsSaved || 0} ratings saved`;
            } else if (act.action === 'login') {
              detailText = 'Logged in';
            } else if (act.action === 'logout') {
              detailText = details.durationMinutes ? `Logged out (${details.durationMinutes} min session)` : 'Logged out';
            }
            return `
              <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px; border-left:3px solid var(--border);">
                <div><strong>${escapeHtml(act.user)}</strong> • ${escapeHtml(act.action)} • ${escapeHtml(detailText)}</div>
                <div class="muted" style="font-size:11px; margin-top:2px;">${escapeHtml(time)}</div>
              </div>
            `;
          }).join('');
        }
      }

      // Sessions
      if (sessionsEl && res.sessions) {
        if (res.sessions.length === 0) {
          sessionsEl.innerHTML = '<div class="muted">No session history</div>';
        } else {
          sessionsEl.innerHTML = res.sessions.slice(-50).reverse().map(sess => {
            // Use timestampString directly from sheet to avoid timezone conversion
            let time = 'Unknown';
            if (sess.timestampString && String(sess.timestampString).trim()) {
              time = String(sess.timestampString).trim();
            }
            const eventType = sess.event === 'login' ? '🟢' : '🔴';
            return `
              <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px; display:flex; justify-content:space-between; align-items:center; border-left:3px solid ${sess.event === 'login' ? '#4CAF50' : '#f44336'};">
                <div>
                  <strong>${escapeHtml(sess.name)}</strong> ${eventType} ${escapeHtml(sess.event)}
                </div>
                <div class="muted" style="font-size:11px;">${escapeHtml(time)}</div>
              </div>
            `;
          }).join('');
        }
      }
    })
    .withFailureHandler(function(err) {
      console.error('Admin stats failure handler called:', err);
      const errMsg = err && err.message ? err.message : String(err || 'Unknown error');
      const msg = 'Failed to load admin stats: ' + errMsg;
      console.error('Full error:', err);
      const allElements = [summaryEl, document.getElementById('adminLeaderboard'), document.getElementById('adminFeatureUsage'), document.getElementById('adminPlayerCoverage'), document.getElementById('adminRecentActivity'), document.getElementById('adminSessions')];
      allElements.forEach(el => {
        if (el) el.innerHTML = '<div class="muted" style="color:#ff5a5f;">' + escapeHtml(msg) + '<br><small>Check browser console (F12) for details.</small></div>';
      });
    })
    .getAdminStats();
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Track tab/feature usage for admin analytics
function trackTabView(tabName) {
  if (!window.CURRENT_USER_NAME || window.CURRENT_USER_NAME === 'Visitor') return;
  
  try {
    google.script.run
      .withSuccessHandler(function() {})
      .withFailureHandler(function(err) { console.error('Tab tracking failed:', err); })
      ._logUserActivity(window.CURRENT_USER_NAME, 'tab_view', { feature: tabName });
  } catch (e) {
    console.error('Tab tracking error:', e);
  }
}

// Show/hide admin tab based on user
function updateAdminTabVisibility() {
  const adminTabItem = document.getElementById('adminTabItem');
  const adminPanel = document.getElementById('panel-admin');
  
  // Only show admin tab for Dimitris
  const isAdmin = window.CURRENT_USER_NAME === 'Dimitris';
  
  if (adminTabItem) {
    adminTabItem.style.display = isAdmin ? '' : 'none';
  }
  
  // If admin panel is active but user is not admin, hide it and show home instead
  if (adminPanel && adminPanel.classList.contains('active') && !isAdmin) {
    adminPanel.classList.remove('active');
    const homePanel = document.getElementById('panel-home');
    if (homePanel) {
      homePanel.classList.add('active');
      // Also update the active tab in sidebar
      document.querySelectorAll('.sideItem').forEach(item => {
        item.classList.remove('active');
        if (item.getAttribute('data-tab') === 'home') {
          item.classList.add('active');
        }
      });
      // Trigger the showPanel function if it exists
      if (typeof showPanel === 'function') {
        showPanel('home');
      }
    }
  }
}

// Auto-load admin stats when admin panel is opened
document.addEventListener('DOMContentLoaded', function() {
  // Check admin visibility on load
  updateAdminTabVisibility();
  
  // Listen for admin tab clicks - use event delegation since tab switching might be handled elsewhere
  document.addEventListener('click', function(e) {
    const adminTab = e.target.closest('[data-tab="admin"]');
    if (adminTab) {
      console.log('Admin tab clicked');
      setTimeout(function() {
        const adminPanel = document.getElementById('panel-admin');
        const isActive = adminPanel && adminPanel.classList.contains('active');
        console.log('Admin panel:', adminPanel, 'Active:', isActive);
        if (adminPanel && isActive) {
          console.log('Panel is active, loading admin stats...');
          if (typeof loadAdminStats === 'function') {
            loadAdminStats();
          } else {
            console.error('loadAdminStats function not found!');
          }
        }
      }, 200);
    }
  });

  // Also watch for panel visibility changes using the 'active' class (how panels are shown/hidden)
  const adminPanel = document.getElementById('panel-admin');
  if (adminPanel) {
    let wasVisible = adminPanel.classList.contains('active');
    
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const isVisible = adminPanel.classList.contains('active');
          console.log('Panel visibility changed (active class):', isVisible, 'was:', wasVisible);
          if (isVisible && !wasVisible && typeof loadAdminStats === 'function') {
            console.log('Panel just became active, loading stats...');
            setTimeout(loadAdminStats, 100);
          }
          wasVisible = isVisible;
        }
      });
    });
    observer.observe(adminPanel, { attributes: true, attributeFilter: ['class'] });
    
    // Avoid extra polling; rely on MutationObserver above
  }
  
  // Throttle user change checks to reduce overhead
  let lastUserName = window.CURRENT_USER_NAME || '';
  setInterval(function() {
    const currentUserName = window.CURRENT_USER_NAME || '';
    if (currentUserName !== lastUserName) {
      lastUserName = currentUserName;
      updateAdminTabVisibility();
    }
  }, 3000);
  
  // Track tab views by intercepting showPanel if it exists
  if (typeof showPanel !== 'undefined') {
    const originalShowPanel = window.showPanel;
    window.showPanel = function(tabName) {
      if (originalShowPanel) originalShowPanel(tabName);
      if (typeof trackTabView === 'function') {
        trackTabView(tabName);
      }
    };
  }
  
  // Also track via sidebar clicks
  document.addEventListener('click', function(e) {
    const sideItem = e.target.closest('#sideNav .sideItem[data-tab]');
    if (sideItem) {
      const tabName = sideItem.getAttribute('data-tab');
      if (tabName && typeof trackTabView === 'function') {
        setTimeout(function() { trackTabView(tabName); }, 100);
      }
    }
  });
});

// User Detail Functions
function showUserDetail(userName) {
  const modal = document.getElementById('userDetailModal');
  const nameEl = document.getElementById('userDetailName');
  const contentEl = document.getElementById('userDetailContent');
  
  if (!modal || !nameEl || !contentEl) return;
  
  nameEl.textContent = userName + ' - Detailed Stats';
  contentEl.textContent = 'Loading...';
  modal.style.display = 'flex';
  
  google.script.run
    .withSuccessHandler(function(res) {
      console.log('getUserDetailStats response:', res);
      if (!res || !res.ok) {
        const errorMsg = res && res.error ? res.error : 'Unknown error';
        console.error('getUserDetailStats failed:', errorMsg);
        contentEl.innerHTML = '<div style="color:#ff5a5f;">Failed to load user details: ' + escapeHtml(errorMsg) + '</div>';
        return;
      }
      
      const stats = res.stats || {};
      const hours = Math.floor((stats.totalTimeMinutes || 0) / 60);
      const mins = Math.round((stats.totalTimeMinutes || 0) % 60);
      
      let html = `
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:16px; margin-bottom:20px;">
          <div style="padding:12px; background:#0f131a; border-radius:8px;">
            <div style="font-size:24px; font-weight:700; color:#e9edf6;">${stats.logins || 0}</div>
            <div class="muted" style="font-size:12px;">Total Logins</div>
          </div>
          <div style="padding:12px; background:#0f131a; border-radius:8px;">
            <div style="font-size:24px; font-weight:700; color:#e9edf6;">${stats.ratings || 0}</div>
            <div class="muted" style="font-size:12px;">Ratings</div>
          </div>
          <div style="padding:12px; background:#0f131a; border-radius:8px;">
            <div style="font-size:24px; font-weight:700; color:#e9edf6;">${stats.notes || 0}</div>
            <div class="muted" style="font-size:12px;">Notes</div>
          </div>
          <div style="padding:12px; background:#0f131a; border-radius:8px;">
            <div style="font-size:24px; font-weight:700; color:#e9edf6;">${hours}h ${mins}m</div>
            <div class="muted" style="font-size:12px;">Total Time</div>
          </div>
        </div>
      `;
      
      // Top Players
      if (res.stats && res.stats.topPlayers && res.stats.topPlayers.length > 0) {
        html += `
          <div style="margin-bottom:20px;">
            <div class="sectionTitle" style="color:#e9edf6; margin-bottom:8px;">Most Rated Players</div>
            ${res.stats.topPlayers.map(p => `
              <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px; display:flex; justify-content:space-between;">
                <span>${escapeHtml(p.player)}</span>
                <span style="font-weight:600; color:#4CAF50;">${p.count} ratings</span>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      // Feature/Tab Usage
      if (res.tabUsage && Object.keys(res.tabUsage).length > 0) {
        const tabs = Object.entries(res.tabUsage)
          .map(([name, count]) => ({ name, count }))
          .sort((a, b) => b.count - a.count);
        html += `
          <div style="margin-bottom:20px;">
            <div class="sectionTitle" style="color:#e9edf6; margin-bottom:8px;">Feature Usage</div>
            ${tabs.map(t => `
              <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px; display:flex; justify-content:space-between;">
                <span>${escapeHtml(t.name)}</span>
                <span style="font-weight:600; color:#4CAF50;">${t.count}</span>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      // Recent Activity Timeline
      if (res.activities && res.activities.length > 0) {
        html += `
          <div style="margin-bottom:20px;">
            <div class="sectionTitle" style="color:#e9edf6; margin-bottom:8px;">Recent Activity Timeline</div>
            <div style="max-height:300px; overflow:auto;">
              ${res.activities.slice(0, 30).map(act => {
                // Use original date string from sheet - no timezone conversion
                let time = 'Unknown';
                if (act.timestampString && act.timestampString.trim()) {
                  time = String(act.timestampString).trim();
                }
                const details = act.details || {};
                let detailText = '';
                if (act.action === 'rating') {
                  detailText = `${details.rowsSaved || 0} ratings saved`;
                } else if (act.action === 'tab_view') {
                  detailText = `Viewed: ${details.feature || act.action}`;
                } else if (act.action === 'login') {
                  detailText = 'Logged in';
                } else if (act.action === 'logout') {
                  detailText = `Logged out (${details.durationMinutes || 0} min)`;
                } else {
                  detailText = JSON.stringify(details);
                }
                return `
                  <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px; border-left:3px solid var(--border);">
                    <div><strong>${escapeHtml(act.action)}</strong> • ${escapeHtml(detailText)}</div>
                    <div class="muted" style="font-size:11px; margin-top:2px;">${time}</div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }
      
      // Recent Sessions
      if (res.sessions && res.sessions.length > 0) {
        html += `
          <div>
            <div class="sectionTitle" style="color:#e9edf6; margin-bottom:8px;">Recent Sessions</div>
            <div style="max-height:300px; overflow:auto;">
              ${res.sessions.slice(0, 20).map(sess => {
                // ALWAYS use original date string from sheet - no timezone conversion
                let time = 'Unknown';
                if (sess.timestampString && sess.timestampString.trim()) {
                  time = String(sess.timestampString).trim();
                }
                const eventColor = sess.event === 'login' ? '#4CAF50' : '#f44336';
                return `
                  <div style="padding:8px; margin-bottom:4px; background:#0f131a; border-radius:6px; font-size:12px; display:flex; justify-content:space-between; border-left:3px solid ${eventColor};">
                    <span><strong>${escapeHtml(sess.event)}</strong></span>
                    <span class="muted" style="font-size:11px;">${escapeHtml(time)}</span>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }
      
      if (html === '') {
        html = '<div class="muted">No detailed data available yet.</div>';
      }
      
      contentEl.innerHTML = html;
    })
    .withFailureHandler(function(err) {
      console.error('getUserDetailStats failure:', err);
      const errorMsg = err && err.message ? err.message : String(err || 'Unknown error');
      contentEl.innerHTML = '<div style="color:#ff5a5f;">Error loading user details: ' + escapeHtml(errorMsg) + '<br><small>Check browser console (F12) for details.</small></div>';
    })
    .getUserDetailStats(userName);
}

function closeUserDetail() {
  const modal = document.getElementById('userDetailModal');
  if (modal) modal.style.display = 'none';
}

// Practice Time Chart Functions
function loadHomeSummary(force) {
  const opts = force ? { force: true } : {};
  google.script.run
    .withSuccessHandler(function(res) {
      if (res && res.ok) {
        renderHomeSummary(res);
        // Also load team ratings chart (calls renderTeamLine from tmp_script.html)
        if (typeof loadTeamRatings === 'function') {
          loadTeamRatings(force);
        }
      } else {
        console.error('Failed to load home summary:', res);
      }
    })
    .withFailureHandler(function(err) {
      console.error('Error loading home summary:', err);
    })
    .getHomeDashboard(opts);
}

function renderHomeSummary(data) {
  // Update timestamp
  const timestampEl = document.getElementById('homeSummaryTimestamp');
  if (timestampEl && data.generatedAt) {
    timestampEl.textContent = 'Updated: ' + data.generatedAt;
  }
  
  // Render latest session
  const sessionBody = document.getElementById('homeSessionBody');
  if (sessionBody && data.summary && data.summary.latestSession) {
    const session = data.summary.latestSession;
    let html = '';
    
    // Date and session
    html += '<div style="margin-bottom:12px;">';
    if (session.displayDate) {
      html += '<div class="muted" style="font-size:12px; margin-bottom:4px;">' + escapeHtml(session.displayDate) + '</div>';
    }
    if (session.session) {
      html += '<div style="font-size:16px; font-weight:600; color:#e9edf6; margin-bottom:4px;">' + escapeHtml(session.session) + '</div>';
    }
    if (session.coach) {
      html += '<div class="muted" style="font-size:12px;">Coach: ' + escapeHtml(session.coach) + '</div>';
    }
    html += '</div>';
    
    // Average score with delta
    if (session.avgScore != null) {
      html += '<div style="display:flex; align-items:center; gap:12px; margin-bottom:12px;">';
      html += '<div style="font-size:32px; font-weight:700; color:#4aa8ff;">' + session.avgScore.toFixed(2) + '</div>';
      if (session.deltaPrev != null) {
        const deltaColor = session.deltaPrev >= 0 ? '#2ecc71' : '#ff5a5f';
        const deltaSign = session.deltaPrev >= 0 ? '+' : '';
        html += '<div style="font-size:16px; font-weight:600; color:' + deltaColor + ';">' + deltaSign + session.deltaPrev.toFixed(2) + '</div>';
      }
      html += '</div>';
    }
    
    // Player count
    if (session.playerCount) {
      html += '<div class="muted" style="font-size:12px; margin-bottom:8px;">' + session.playerCount + ' players rated</div>';
    }
    
    // Top and worst players
    if (session.players && session.players.length > 0) {
      // Top players (first 3)
      html += '<div style="margin-top:12px;"><div style="font-size:12px; font-weight:600; margin-bottom:6px; color:#2ecc71;">⭐ Top Performers:</div>';
      const topPlayers = session.players.slice(0, Math.min(3, session.players.length));
      topPlayers.forEach(function(p) {
        if (p.avg != null) {
          html += '<div style="display:flex; justify-content:space-between; padding:4px 0; font-size:13px;">';
          html += '<span>' + escapeHtml(p.player) + '</span>';
          html += '<span style="font-weight:600; color:#4aa8ff;">' + p.avg.toFixed(2) + '</span>';
          html += '</div>';
        }
      });
      html += '</div>';
      
      // Worst performers (show bottom 3 if more than 3 players total)
      // Filter out unrated players (avg is null or 0)
      const ratedPlayers = session.players.filter(function(p) { 
        return p.avg != null && p.avg > 0; 
      });
      
      if (ratedPlayers.length > 3) {
        // Get worst performers (last 3 from sorted list)
        const worstPlayers = ratedPlayers.slice(-3).reverse(); // Reverse to show worst first
        
        html += '<div style="margin-top:16px; padding:10px; background:rgba(255,90,95,0.08); border-radius:8px; border-left:3px solid #ff5a5f;">';
        html += '<div style="font-size:12px; font-weight:600; margin-bottom:6px; color:#ff5a5f;">⚠️ Needs Attention:</div>';
        
        worstPlayers.forEach(function(worstPlayer) {
          html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; padding:4px 0;">';
          html += '<span style="font-size:13px;">' + escapeHtml(worstPlayer.player) + '</span>';
          html += '<span style="font-weight:600; color:#ff5a5f; font-size:13px;">' + worstPlayer.avg.toFixed(2) + '</span>';
          html += '</div>';
        });
        
        // Show notes for the worst player (first in the list)
        const worstPlayer = worstPlayers[0];
        if (worstPlayer && worstPlayer.notes && worstPlayer.notes.length > 0) {
          html += '<div style="margin-top:8px; border-top:1px solid rgba(255,90,95,0.2); padding-top:8px;">';
          html += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:4px;">Coach Notes for ' + escapeHtml(worstPlayer.player) + ':</div>';
          worstPlayer.notes.forEach(function(noteObj) {
            html += '<div style="margin-bottom:6px; font-size:12px;">';
            if (noteObj.coach) {
              html += '<span style="color:#9aa6bf; font-size:10px;">' + escapeHtml(noteObj.coach) + ':</span> ';
            }
            html += '<span style="color:#e9edf6;">' + escapeHtml(noteObj.note) + '</span>';
            html += '</div>';
          });
          html += '</div>';
        }
        html += '</div>';
      } else if (ratedPlayers.length > 0) {
        // If 3 or fewer players, still show worst one
        const worstPlayer = ratedPlayers[ratedPlayers.length - 1];
        if (worstPlayer && worstPlayer.avg < topPlayers[topPlayers.length - 1].avg) {
        html += '<div style="margin-top:16px; padding:10px; background:rgba(255,90,95,0.08); border-radius:8px; border-left:3px solid #ff5a5f;">';
        html += '<div style="font-size:12px; font-weight:600; margin-bottom:6px; color:#ff5a5f;">⚠️ Needs Attention:</div>';
        html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">';
        html += '<span style="font-size:13px; font-weight:600;">' + escapeHtml(worstPlayer.player) + '</span>';
        html += '<span style="font-weight:600; color:#ff5a5f; font-size:14px;">' + worstPlayer.avg.toFixed(2) + '</span>';
        html += '</div>';
        
        if (worstPlayer.notes && worstPlayer.notes.length > 0) {
          html += '<div style="margin-top:8px; border-top:1px solid rgba(255,90,95,0.2); padding-top:8px;">';
          html += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:4px;">Coach Notes:</div>';
          worstPlayer.notes.forEach(function(noteObj) {
            html += '<div style="margin-bottom:6px; font-size:12px;">';
            if (noteObj.coach) {
              html += '<span style="color:#9aa6bf; font-size:10px;">' + escapeHtml(noteObj.coach) + ':</span> ';
            }
            html += '<span style="color:#e9edf6;">' + escapeHtml(noteObj.note) + '</span>';
            html += '</div>';
          });
          html += '</div>';
        }
        html += '</div>';
        }
      }
    }
    
    sessionBody.innerHTML = html;
  }
  
  // Render practice time chart
  if (data.summary && data.summary.practiceTime) {
    renderPracticeTimeChart(data.summary.practiceTime);
  }
  
  // Team rating chart is loaded separately by loadTeamRatings() from tmp_script.html
  // Don't render it here to avoid overwriting the original rendering logic
  
  // Render 3-day flags
  if (data.flags) {
    renderThreeDayFlags(data.flags);
  }
  
  // Render insights
  if (data.insights && data.insights.ok) {
    renderTeamInsights(data.insights);
  }
}

function renderTeamInsights(insightsData) {
  const card = document.getElementById('homeInsightsCard');
  const content = document.getElementById('homeInsightsContent');
  
  if (!card || !content || !insightsData.insights) {
    if (card) card.style.display = 'none';
    return;
  }
  
  const insights = insightsData.insights;
  let html = '';
  
  // Predictions
  if (insights.predictions && insights.predictions.length > 0) {
    html += '<div style="margin-bottom:16px; padding:12px; background:rgba(74,168,255,0.08); border-radius:8px; border-left:3px solid #4aa8ff;">';
    html += '<div style="font-size:13px; font-weight:600; margin-bottom:8px; color:#4aa8ff;">📈 Predictions</div>';
    
    insights.predictions.forEach(function(pred) {
      if (pred.type === 'next_session') {
        html += '<div style="margin-bottom:6px; font-size:12px;">';
        html += '<strong>Next Session:</strong> ' + pred.value.toFixed(2);
        if (pred.range) {
          html += ' (range: ' + pred.range[0].toFixed(2) + ' - ' + pred.range[1].toFixed(2) + ')';
        }
        html += ' <span style="color:#9aa6bf; font-size:11px;">[' + pred.confidence + ' confidence]</span>';
        html += '</div>';
      } else if (pred.type === 'zone_progression') {
        html += '<div style="margin-top:8px; padding:8px; background:rgba(46,204,113,0.1); border-radius:6px; font-size:12px;">';
        html += '✅ ' + pred.message;
        html += '</div>';
      }
    });
    
    html += '</div>';
  }
  
  // Trends
  if (insights.trends) {
    const trend = insights.trends;
    const trendColor = trend.direction === 'improving' ? '#2ecc71' : (trend.direction === 'declining' ? '#ff5a5f' : '#9aa6bf');
    const trendIcon = trend.direction === 'improving' ? '📈' : (trend.direction === 'declining' ? '📉' : '➡️');
    
    html += '<div style="margin-bottom:16px; padding:12px; background:rgba(255,255,255,0.02); border-radius:8px; border-left:3px solid ' + trendColor + ';">';
    html += '<div style="font-size:13px; font-weight:600; margin-bottom:8px; color:' + trendColor + ';">' + trendIcon + ' Trend Analysis</div>';
    html += '<div style="font-size:12px; margin-bottom:4px;">Current Session: <strong>' + trend.current.toFixed(2) + '</strong> <span style="color:#9aa6bf; font-size:11px;">(matches Latest Session)</span></div>';
    html += '<div style="font-size:12px; margin-bottom:4px;">Previous Session: ' + trend.previous.toFixed(2) + '</div>';
    html += '<div style="font-size:12px; margin-bottom:4px;">Session Change: <strong style="color:' + trendColor + ';">' + (trend.change >= 0 ? '+' : '') + trend.change.toFixed(2) + '</strong> <span style="color:#9aa6bf; font-size:11px;">(matches Latest Session delta)</span></div>';
    if (trend.trend !== undefined && Math.abs(trend.trend - trend.change) > 0.01) {
      html += '<div style="font-size:11px; margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1); color:#9aa6bf;">Overall Trend (last 5 vs previous 5): <strong style="color:' + trendColor + ';">' + (trend.trend >= 0 ? '+' : '') + trend.trend.toFixed(2) + '</strong> (' + trend.direction + ')</div>';
    }
    html += '</div>';
  }
  
  // Correlations
  if (insights.correlations && Object.keys(insights.correlations).length > 0) {
    html += '<div style="margin-bottom:16px; padding:12px; background:rgba(255,176,32,0.08); border-radius:8px; border-left:3px solid #ffb020;">';
    html += '<div style="font-size:13px; font-weight:600; margin-bottom:8px; color:#ffb020;">🔗 Correlations</div>';
    
    for (const key in insights.correlations) {
      const corr = insights.correlations[key];
      html += '<div style="margin-bottom:8px; font-size:12px;">';
      html += '<div style="font-weight:600; margin-bottom:2px;">' + corr.finding + '</div>';
      html += '<div style="color:#9aa6bf; font-size:11px; margin-left:8px;">💡 ' + corr.recommendation + '</div>';
      html += '</div>';
    }
    
    html += '</div>';
  }
  
  // Warnings
  if (insights.warnings && insights.warnings.length > 0) {
    html += '<div style="margin-bottom:16px; padding:12px; background:rgba(255,90,95,0.08); border-radius:8px; border-left:3px solid #ff5a5f;">';
    html += '<div style="font-size:13px; font-weight:600; margin-bottom:8px; color:#ff5a5f;">⚠️ Warnings</div>';
    
    insights.warnings.forEach(function(warning) {
      html += '<div style="margin-bottom:8px; font-size:12px;">';
      html += '<div style="font-weight:600; margin-bottom:2px;">' + warning.message + '</div>';
      if (warning.recommendation) {
        html += '<div style="color:#9aa6bf; font-size:11px; margin-left:8px;">💡 ' + warning.recommendation + '</div>';
      }
      html += '</div>';
    });
    
    html += '</div>';
  }
  
  // Recommendations (Data-Rich)
  if (insights.recommendations && insights.recommendations.length > 0) {
    html += '<div style="margin-bottom:16px; padding:12px; background:rgba(46,204,113,0.08); border-radius:8px; border-left:3px solid #2ecc71;">';
    html += '<div style="font-size:13px; font-weight:600; margin-bottom:12px; color:#2ecc71;">🎯 Data-Driven Recommendations</div>';
    
    insights.recommendations.forEach(function(rec) {
      const priorityColor = rec.priority === 'high' || rec.priority === 'critical' ? '#ff5a5f' : (rec.priority === 'medium' ? '#ffb020' : '#4aa8ff');
      const priorityLabel = rec.priority === 'critical' ? '🔴 CRITICAL' : (rec.priority === 'high' ? '🟠 HIGH' : (rec.priority === 'medium' ? '🟡 MEDIUM' : '🔵 LOW'));
      
      html += '<div style="margin-bottom:16px; padding:10px; background:rgba(255,255,255,0.03); border-radius:6px; border:1px solid rgba(255,255,255,0.1);">';
      html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">';
      html += '<div style="font-weight:600; font-size:12px; color:#e9edf6;">' + rec.message + '</div>';
      html += '<div style="font-size:10px; color:' + priorityColor + '; font-weight:600;">' + priorityLabel + '</div>';
      html += '</div>';
      
      // Display data metrics if available
      if (rec.data && Object.keys(rec.data).length > 0) {
        html += '<div style="margin:8px 0; padding:8px; background:rgba(0,0,0,0.2); border-radius:4px; display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:8px; font-size:11px;">';
        for (const key in rec.data) {
          // Skip highRatingAnalysis object - it's displayed separately
          if (key === 'highRatingAnalysis') continue;
          
          const value = rec.data[key];
          // Skip objects and arrays from data display
          if (typeof value === 'object' && value !== null) continue;
          
          const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim();
          html += '<div style="text-align:center;">';
          html += '<div style="color:#9aa6bf; font-size:9px; margin-bottom:2px;">' + label + '</div>';
          html += '<div style="color:#4aa8ff; font-weight:600; font-size:13px;">' + value + '</div>';
          html += '</div>';
        }
        html += '</div>';
      }
      
      // Display high-rating analysis for performance_zone recommendations
      if (rec.category === 'performance_zone' && rec.data && rec.data.highRatingAnalysis && rec.data.highRatingAnalysis.insights && rec.data.highRatingAnalysis.insights.length > 0) {
        html += '<div style="margin:8px 0; padding:10px; background:rgba(46,204,113,0.1); border-radius:6px; border-left:3px solid #2ecc71;">';
        html += '<div style="font-size:12px; color:#2ecc71; margin-bottom:8px; font-weight:600;">📈 What Drives Ratings ≥3.5:</div>';
        html += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:6px;">' + escapeHtml(rec.data.highRatingAnalysis.summary) + '</div>';
        html += '<ul style="margin:4px 0 0 16px; padding:0; color:#e9edf6; font-size:11px; line-height:1.8;">';
        rec.data.highRatingAnalysis.insights.forEach(function(insight) {
          html += '<li style="margin-bottom:4px;">' + escapeHtml(insight) + '</li>';
        });
        html += '</ul>';
        html += '</div>';
      }
      
      // Display player details table if available (for player correlation analysis)
      if (rec.playerDetails && rec.playerDetails.length > 0) {
        html += '<div style="margin:8px 0; padding:8px; background:rgba(74,168,255,0.1); border-radius:4px;">';
        html += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:6px; font-weight:600;">👥 Top 5 Players by Correlation (based on all analyzed sessions):</div>';
        html += '<table style="width:100%; font-size:11px; border-collapse:collapse;">';
        html += '<thead><tr style="border-bottom:1px solid rgba(255,255,255,0.2);">';
        html += '<th style="text-align:left; padding:4px; color:#9aa6bf;">Player</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Correlation</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Best Trait</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Avg Rating</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Sessions</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Impact</th>';
        html += '</tr></thead><tbody>';
        
        rec.playerDetails.forEach(function(p) {
          const corrColor = Math.abs(parseFloat(p.correlation)) > 0.5 ? '#2ecc71' : (Math.abs(parseFloat(p.correlation)) > 0.3 ? '#ffb020' : '#9aa6bf');
          const impactColor = p.impact === 'high' ? '#2ecc71' : (p.impact === 'medium' ? '#ffb020' : '#9aa6bf');
          html += '<tr style="border-bottom:1px solid rgba(255,255,255,0.05);">';
          html += '<td style="padding:4px; color:#e9edf6;">' + escapeHtml(p.player) + '</td>';
          html += '<td style="padding:4px; text-align:center; color:' + corrColor + '; font-weight:600;">' + p.correlation + '</td>';
          html += '<td style="padding:4px; text-align:center; color:#ffb020; font-weight:600; font-size:10px;">' + escapeHtml(p.bestTrait || 'N/A') + '</td>';
          html += '<td style="padding:4px; text-align:center; color:#4aa8ff;">' + p.avgRating + '</td>';
          html += '<td style="padding:4px; text-align:center; color:#9aa6bf;">' + (p.sessions || 'N/A') + '</td>';
          html += '<td style="padding:4px; text-align:center; color:' + impactColor + '; font-weight:600; text-transform:uppercase; font-size:10px;">' + p.impact + '</td>';
          html += '</tr>';
        });
        
        html += '</tbody></table>';
        html += '</div>';
      }
      
      // Display negative correlation players table
      if (rec.playerDetailsNegative && rec.playerDetailsNegative.length > 0) {
        html += '<div style="margin:8px 0; padding:8px; background:rgba(255,90,95,0.1); border-radius:4px;">';
        html += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:6px; font-weight:600;">👥 Bottom 5 Players by Correlation (lowest correlations, based on all analyzed sessions):</div>';
        html += '<table style="width:100%; font-size:11px; border-collapse:collapse;">';
        html += '<thead><tr style="border-bottom:1px solid rgba(255,255,255,0.2);">';
        html += '<th style="text-align:left; padding:4px; color:#9aa6bf;">Player</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Correlation</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Best Trait</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Avg Rating</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Sessions</th>';
        html += '<th style="text-align:center; padding:4px; color:#9aa6bf;">Impact</th>';
        html += '</tr></thead><tbody>';
        
        rec.playerDetailsNegative.forEach(function(p) {
          // For negative correlations, use red color scheme
          const corrColor = Math.abs(parseFloat(p.correlation)) > 0.5 ? '#ff5a5f' : (Math.abs(parseFloat(p.correlation)) > 0.3 ? '#ff8c42' : '#9aa6bf');
          const impactColor = p.impact === 'high' ? '#ff5a5f' : (p.impact === 'medium' ? '#ff8c42' : '#9aa6bf');
          html += '<tr style="border-bottom:1px solid rgba(255,255,255,0.05);">';
          html += '<td style="padding:4px; color:#e9edf6;">' + escapeHtml(p.player) + '</td>';
          html += '<td style="padding:4px; text-align:center; color:' + corrColor + '; font-weight:600;">' + p.correlation + '</td>';
          html += '<td style="padding:4px; text-align:center; color:#ffb020; font-weight:600; font-size:10px;">' + escapeHtml(p.bestTrait || 'N/A') + '</td>';
          html += '<td style="padding:4px; text-align:center; color:#4aa8ff;">' + p.avgRating + '</td>';
          html += '<td style="padding:4px; text-align:center; color:#9aa6bf;">' + (p.sessions || 'N/A') + '</td>';
          html += '<td style="padding:4px; text-align:center; color:' + impactColor + '; font-weight:600; text-transform:uppercase; font-size:10px;">' + p.impact + '</td>';
          html += '</tr>';
        });
        
        html += '</tbody></table>';
        html += '</div>';
      }
      
      // Display correlation summary insights
      if (rec.summary && rec.summary.length > 0) {
        html += '<div style="margin:12px 0; padding:12px; background:rgba(46,204,113,0.1); border-radius:6px; border-left:3px solid #2ecc71;">';
        html += '<div style="font-size:12px; color:#2ecc71; margin-bottom:8px; font-weight:600;">📊 Correlation Analysis Summary:</div>';
        html += '<ul style="margin:4px 0 0 16px; padding:0; color:#e9edf6; font-size:11px; line-height:1.8;">';
        rec.summary.forEach(function(insight) {
          html += '<li style="margin-bottom:6px;">' + escapeHtml(insight) + '</li>';
        });
        html += '</ul>';
        html += '</div>';
      }
      
      // Display actionable items
      if (rec.actions && rec.actions.length > 0) {
        html += '<div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">';
        html += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:4px; font-weight:600;">📋 Action Items:</div>';
        html += '<ul style="margin:4px 0 0 16px; padding:0; color:#e9edf6; font-size:11px; line-height:1.6;">';
        rec.actions.forEach(function(action) {
          html += '<li style="margin-bottom:4px;">' + escapeHtml(action) + '</li>';
        });
        html += '</ul>';
        html += '</div>';
      }
      
      html += '</div>';
    });
    
    html += '</div>';
  }
  
  if (html === '') {
    html = '<div style="text-align:center; color:#9aa6bf; font-size:12px;">Not enough data yet for insights. Check back after a few more sessions!</div>';
  } else {
    html += '<div style="margin-top:12px; font-size:10px; text-align:center; color:#9aa6bf; font-style:italic;">Generated: ' + (insightsData.generatedAt || '') + '</div>';
  }
  
  content.innerHTML = html;
  card.style.display = 'block';
}

function renderThreeDayFlags(flags) {
  const table = document.getElementById('flagsTable');
  const msgEl = document.getElementById('flagsMsg');
  
  if (!table) return;
  
  if (!flags || !flags.ok || !flags.rows || flags.rows.length === 0) {
    table.innerHTML = '<tbody><tr><td class="muted" style="padding:12px; text-align:center;">No flags in last 3 days</td></tr></tbody>';
    if (msgEl) msgEl.textContent = '';
    return;
  }
  
  // flags.rows is an array of arrays (display values from the sheet)
  // flags.headers contains the column names
  const headers = flags.headers || [];
  
  let html = '<thead><tr>';
  // Use the actual headers from the sheet
  if (headers.length > 0) {
    headers.forEach(function(h) {
      html += '<th style="text-align:left; padding:8px; border-bottom:1px solid #2a3448;">' + escapeHtml(h) + '</th>';
    });
  }
  html += '</tr></thead><tbody>';
  
  flags.rows.forEach(function(row) {
    html += '<tr>';
    row.forEach(function(cell, idx) {
      const cellValue = String(cell || '').trim();
      // Color the score column (usually contains numbers < 3)
      const isNumeric = !isNaN(parseFloat(cellValue)) && isFinite(cellValue);
      const style = isNumeric && parseFloat(cellValue) < 3 
        ? 'padding:8px; font-weight:600; color:#ff5a5f;' 
        : 'padding:8px;';
      html += '<td style="' + style + '">' + escapeHtml(cellValue) + '</td>';
    });
    html += '</tr>';
  });
  
  html += '</tbody>';
  table.innerHTML = html;
  
  if (msgEl) {
    msgEl.textContent = 'Showing ' + flags.rows.length + ' flag(s)';
  }
}

function escapeHtml(text) {
  const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
  return String(text).replace(/[&<>"']/g, function(m) { return map[m]; });
}

function renderPracticeTimeChart(practiceData) {
  const chartDiv = document.getElementById('practiceTimeChart');
  const detailsDiv = document.getElementById('practiceTimeDetails');
  
  if (!chartDiv || !detailsDiv) return;
  
  if (practiceData.error || !practiceData.categories || practiceData.categories.length === 0) {
    chartDiv.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">No practice data available</div>';
    detailsDiv.innerHTML = '';
    return;
  }
  
  // Tooltip functions (reuse #notesTooltip)
  const tipEl = document.getElementById('notesTooltip');
  function hideTip() { if (tipEl) tipEl.style.display = 'none'; }
  function showTip(html, x, y) {
    if (!tipEl) return;
    if (html) tipEl.innerHTML = html;
    tipEl.style.display = 'block';
    const pad = 12, vw = window.innerWidth, vh = window.innerHeight;
    const r = tipEl.getBoundingClientRect();
    let L = x + pad, T = y + pad;
    if (L + r.width > vw - 8) L = x - r.width - pad;
    if (T + r.height > vh - 8) T = y - r.height - pad;
    tipEl.style.left = Math.max(8, L) + 'px';
    tipEl.style.top = Math.max(8, T) + 'px';
  }
  
  // Create pie chart using SVG
  const categories = practiceData.categories;
  const colors = {
    'offense': '#4aa8ff',
    'defense': '#ff5a5f',
    'other': '#ffb020'
  };
  
  const width = 300;
  const height = 300;
  const radius = Math.min(width, height) / 2 - 10;
  const cx = width / 2;
  const cy = height / 2;
  
  // Create SVG element
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);
  svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
  
  let currentAngle = -90; // Start at top
  let legendHtml = '<div style="display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin-top:12px;">';
  
  categories.forEach(function(cat) {
    const percentage = cat.percentage;
    const angle = (percentage / 100) * 360;
    const color = colors[cat.segment.toLowerCase()] || colors['other'];
    
    // Calculate path for pie slice
    const startAngle = currentAngle * Math.PI / 180;
    const endAngle = (currentAngle + angle) * Math.PI / 180;
    
    const x1 = cx + radius * Math.cos(startAngle);
    const y1 = cy + radius * Math.sin(startAngle);
    const x2 = cx + radius * Math.cos(endAngle);
    const y2 = cy + radius * Math.sin(endAngle);
    
    const largeArc = angle > 180 ? 1 : 0;
    
    const pathD = [
      'M', cx, cy,
      'L', x1, y1,
      'A', radius, radius, 0, largeArc, 1, x2, y2,
      'Z'
    ].join(' ');
    
    // Create path element
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathD);
    path.setAttribute('fill', color);
    path.setAttribute('stroke', '#14181f');
    path.setAttribute('stroke-width', '2');
    path.style.cursor = 'pointer';
    
    // Add hover effect
    path.addEventListener('mouseenter', function(e) {
      path.setAttribute('opacity', '0.8');
      
      // Build tooltip HTML
      let tooltipHtml = '<div style="font-weight:700; margin-bottom:4px;">' + cat.segment + ' (' + cat.count + ' segments)</div>';
      tooltipHtml += '<div style="margin-bottom:6px;">' + percentage.toFixed(1) + '% of total practice time</div>';
      
      if (cat.subCategories && cat.subCategories.length > 0) {
        tooltipHtml += '<div style="margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.2);">';
        tooltipHtml += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:4px;">Sub-segments:</div>';
        cat.subCategories.forEach(function(sub) {
          tooltipHtml += '<div style="font-size:12px; margin-left:8px;">• ' + sub.name + ': ' + sub.percentage.toFixed(1) + '% (' + sub.count + ')</div>';
        });
        tooltipHtml += '</div>';
      }
      
      showTip(tooltipHtml, e.clientX, e.clientY);
    });
    
    path.addEventListener('mousemove', function(e) {
      showTip(null, e.clientX, e.clientY);
    });
    
    path.addEventListener('mouseleave', function() {
      path.setAttribute('opacity', '1');
      hideTip();
    });
    
    svg.appendChild(path);
    
    // Add percentage label
    const labelAngle = (currentAngle + angle / 2) * Math.PI / 180;
    const labelRadius = radius * 0.7;
    const labelX = cx + labelRadius * Math.cos(labelAngle);
    const labelY = cy + labelRadius * Math.sin(labelAngle);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', labelX);
    text.setAttribute('y', labelY);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('dominant-baseline', 'middle');
    text.setAttribute('fill', '#fff');
    text.setAttribute('font-size', '18');
    text.setAttribute('font-weight', 'bold');
    text.setAttribute('pointer-events', 'none');
    text.textContent = percentage.toFixed(0) + '%';
    svg.appendChild(text);
    
    currentAngle += angle;
    
    // Add to legend
    legendHtml += '<div style="display:flex; align-items:center; gap:6px;">';
    legendHtml += '<div style="width:12px; height:12px; background:' + color + '; border-radius:2px;"></div>';
    legendHtml += '<span style="font-size:13px;">' + cat.segment + ' (' + cat.count + ')</span>';
    legendHtml += '</div>';
  });
  
  legendHtml += '</div>';
  
  chartDiv.innerHTML = '';
  chartDiv.appendChild(svg);
  
  // Add total sessions/segments info
  let detailsHtml = '<div style="margin-top:12px;">';
  detailsHtml += '<div style="font-size:11px; text-align:center; margin-bottom:8px; color:#9aa6bf;">';
  detailsHtml += 'Total Sessions: ' + practiceData.totalSessions;
  if (practiceData.totalSegments) {
    detailsHtml += ' • Total Segments: ' + practiceData.totalSegments;
  }
  detailsHtml += '</div>';
  detailsHtml += '</div>';
  
  // Add aspects (teach, learn, compete)
  let aspectsHtml = '';
  if (practiceData.aspects) {
    aspectsHtml += '<div style="margin-top:16px; padding:12px; background:rgba(74,168,255,0.08); border-radius:8px; border:1px solid rgba(74,168,255,0.2);">';
    aspectsHtml += '<div style="font-size:12px; font-weight:600; margin-bottom:10px; text-align:center; color:#e9edf6;">Practice Aspects</div>';
    aspectsHtml += '<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px;">';
    
    // Teach aspect
    aspectsHtml += '<div style="text-align:center; padding:8px; background:rgba(46,204,113,0.1); border-radius:6px; border:1px solid rgba(46,204,113,0.3);">';
    aspectsHtml += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:4px;">📚 Teach</div>';
    aspectsHtml += '<div style="font-size:18px; font-weight:700; color:#2ecc71;">' + practiceData.aspects.teach.percentage.toFixed(0) + '%</div>';
    aspectsHtml += '<div style="font-size:10px; color:#9aa6bf; margin-top:2px;">(' + practiceData.aspects.teach.count + ')</div>';
    aspectsHtml += '</div>';
    
    // Learn aspect
    aspectsHtml += '<div style="text-align:center; padding:8px; background:rgba(74,168,255,0.1); border-radius:6px; border:1px solid rgba(74,168,255,0.3);">';
    aspectsHtml += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:4px;">🧠 Learn</div>';
    aspectsHtml += '<div style="font-size:18px; font-weight:700; color:#4aa8ff;">' + practiceData.aspects.learn.percentage.toFixed(0) + '%</div>';
    aspectsHtml += '<div style="font-size:10px; color:#9aa6bf; margin-top:2px;">(' + practiceData.aspects.learn.count + ')</div>';
    aspectsHtml += '</div>';
    
    // Compete aspect
    aspectsHtml += '<div style="text-align:center; padding:8px; background:rgba(255,90,95,0.1); border-radius:6px; border:1px solid rgba(255,90,95,0.3);">';
    aspectsHtml += '<div style="font-size:11px; color:#9aa6bf; margin-bottom:4px;">🏆 Compete</div>';
    aspectsHtml += '<div style="font-size:18px; font-weight:700; color:#ff5a5f;">' + practiceData.aspects.compete.percentage.toFixed(0) + '%</div>';
    aspectsHtml += '<div style="font-size:10px; color:#9aa6bf; margin-top:2px;">(' + practiceData.aspects.compete.count + ')</div>';
    aspectsHtml += '</div>';
    
    aspectsHtml += '</div>';
    aspectsHtml += '<div style="margin-top:8px; font-size:10px; text-align:center; color:#9aa6bf; font-style:italic;">Hover over the chart for sub-segment details</div>';
    aspectsHtml += '</div>';
  }
  
  detailsDiv.innerHTML = legendHtml + detailsHtml + aspectsHtml;
}

// Load home summary on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', function() {
    loadHomeSummary(false);
  });
} else {
  loadHomeSummary(false);
}
    </script>





 
   












    <!-- SPIRAL FEEDBACK FUNCTIONS (Standalone - can be removed without breaking app) -->
    <script>
// Spiral Feedback Functions - Completely independent module

// Register tabLoader immediately (before IIFE)
if (typeof window.tabLoaders === 'undefined') {
  window.tabLoaders = {};
}

// Register the tab loader function immediately
window.tabLoaders.spiralfeedback = function() {
  console.log('[tabLoaders.spiralfeedback] Tab clicked');
  // Check if detail view is active - don't reload if it is
  const detailView = document.getElementById('spiralDetailView');
  if (detailView && detailView.style.display !== 'none') {
    console.log('[tabLoaders.spiralfeedback] Detail view active, skipping reload');
    return;
  }
  
  // Check if dashboard is already loaded and visible
  const dashboardTable = document.getElementById('spiralDashboardTable');
  const teamSummary = document.getElementById('spiralTeamSummary');
  if (dashboardTable && teamSummary && teamSummary.style.display !== 'none') {
    // Check if content is already rendered
    const hasContent = teamSummary.innerHTML && 
      !teamSummary.innerHTML.includes('Loading') && 
      teamSummary.innerHTML.trim().length > 0;
    if (hasContent) {
      console.log('[tabLoaders.spiralfeedback] Dashboard already loaded, skipping reload');
      // Still load predictions (they update independently)
      loadPredictions();
      return;
    }
  }
  
  console.log('[tabLoaders.spiralfeedback] Loading spiral dashboard...');
  if (typeof window.loadSpiralDashboard === 'function') {
    window.loadSpiralDashboard();
  } else {
    console.warn('[tabLoaders.spiralfeedback] loadSpiralDashboard function not found');
  }
  
  // Load predictions
  loadPredictions();
};

// Prediction Validation Functions
function loadPredictions() {
  const panel = document.getElementById('predictionsPanel');
  if (!panel) return;
  
  panel.innerHTML = '<div class="muted" style="text-align:center; padding:20px;">Loading predictions...</div>';
  
  // Load active predictions and accuracy in parallel
  Promise.all([
    new Promise((resolve) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(() => resolve({ ok: false, predictions: [] }))
        .getActivePredictions();
    }),
    new Promise((resolve) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(() => resolve({ ok: false }))
        .getPredictionAccuracy();
    })
  ]).then(([predictionsData, accuracyData]) => {
    renderPredictionsPanel(predictionsData, accuracyData);
  });
}

function renderPredictionsPanel(predictionsData, accuracyData) {
  const panel = document.getElementById('predictionsPanel');
  if (!panel) return;
  
  let html = '';
  
  // Accuracy Summary
  if (accuracyData && accuracyData.ok && accuracyData.total > 0) {
    const overallAcc = accuracyData.overallAccuracy;
    const accPercent = overallAcc != null ? (overallAcc * 100).toFixed(0) : '—';
    const accColor = overallAcc != null && overallAcc >= 0.7 ? '#2ecc71' : (overallAcc != null && overallAcc >= 0.5 ? '#ffb020' : '#ff5a5f');
    
    html += '<div style="margin-bottom:20px; padding:12px; background:rgba(74,168,255,0.1); border-radius:8px; border-left:3px solid #4aa8ff;">';
    html += '<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">';
    html += '<strong style="color:#4aa8ff; font-size:14px;">📊 System Accuracy</strong>';
    html += '<span style="font-size:18px; font-weight:600; color:' + accColor + ';">' + accPercent + '%</span>';
    html += '</div>';
    html += '<div style="font-size:12px; color:#9aa5be;">Based on ' + accuracyData.total + ' validated predictions</div>';
    
    // Accuracy by type
    if (accuracyData.byType && Object.keys(accuracyData.byType).length > 0) {
      html += '<div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(74,168,255,0.2);">';
      Object.entries(accuracyData.byType).forEach(([type, data]) => {
        const typeLabel = type === 'dip' ? 'Dip Predictions' : (type === 'recovery' ? 'Recovery Predictions' : type);
        const typeAcc = data.average != null ? (data.average * 100).toFixed(0) : '—';
        const typeColor = data.average != null && data.average >= 0.7 ? '#2ecc71' : (data.average != null && data.average >= 0.5 ? '#ffb020' : '#ff5a5f');
        html += '<div style="display:flex; justify-content:space-between; margin-bottom:6px; font-size:12px;">';
        html += '<span style="color:#9aa5be;">' + typeLabel + ':</span>';
        html += '<span style="color:' + typeColor + '; font-weight:600;">' + typeAcc + '%</span>';
        html += '<span style="color:#79839a; margin-left:8px;">(' + data.total + ')</span>';
        html += '</div>';
      });
      html += '</div>';
    }
    
    html += '</div>';
  } else {
    html += '<div style="margin-bottom:20px; padding:12px; background:rgba(74,168,255,0.1); border-radius:8px; border-left:3px solid #4aa8ff;">';
    html += '<div style="color:#9aa5be; font-size:12px; text-align:center;">No predictions validated yet. System will learn as predictions are made and outcomes occur.</div>';
    html += '</div>';
  }
  
  // Active Predictions
  const predictions = (predictionsData && predictionsData.ok) ? predictionsData.predictions || [] : [];
  
  if (predictions.length > 0) {
    html += '<div style="margin-bottom:12px;">';
    html += '<strong style="color:#e9edf6; font-size:14px; display:block; margin-bottom:12px;">🔮 Active Predictions (' + predictions.length + ')</strong>';
    
    predictions.forEach(pred => {
      const predDate = pred.prediction && pred.prediction.expectedDate 
        ? new Date(pred.prediction.expectedDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
        : 'Unknown';
      const confidence = pred.prediction && pred.prediction.confidence 
        ? (pred.prediction.confidence * 100).toFixed(0) 
        : '—';
      const confColor = pred.prediction && pred.prediction.confidence >= 0.7 ? '#2ecc71' : (pred.prediction && pred.prediction.confidence >= 0.5 ? '#ffb020' : '#ff5a5f');
      const typeLabel = pred.type === 'dip' ? 'Dip' : (pred.type === 'recovery' ? 'Recovery' : pred.type);
      const targetLabel = pred.target === 'team' ? 'Team' : (pred.targetId || 'Player');
      const reasoning = pred.prediction && pred.prediction.reasoning ? pred.prediction.reasoning : 'Based on historical patterns';
      
      html += '<div style="margin-bottom:12px; padding:12px; background:rgba(155,89,182,0.1); border-radius:8px; border-left:3px solid #9b59b6;">';
      html += '<div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">';
      html += '<div>';
      html += '<strong style="color:#9b59b6; font-size:13px;">' + typeLabel + ' Prediction</strong>';
      html += '<div style="font-size:11px; color:#9aa5be; margin-top:4px;">' + targetLabel + ' • Expected: ' + predDate + '</div>';
      html += '</div>';
      html += '<div style="text-align:right;">';
      html += '<div style="font-size:12px; color:' + confColor + '; font-weight:600;">' + confidence + '%</div>';
      html += '<div style="font-size:10px; color:#79839a;">confidence</div>';
      html += '</div>';
      html += '</div>';
      html += '<div style="font-size:11px; color:#9aa5be; margin-top:6px; padding-left:4px;">' + escapeHtml(reasoning) + '</div>';
      html += '</div>';
    });
    
    html += '</div>';
  } else {
    html += '<div style="padding:12px; background:rgba(155,89,182,0.1); border-radius:8px; border-left:3px solid #9b59b6;">';
    html += '<div style="color:#9aa5be; font-size:12px; text-align:center;">No active predictions. Predictions will appear here when the system forecasts future performance.</div>';
    html += '</div>';
  }
  
  panel.innerHTML = html;
}

// Make loadPredictions available globally
window.loadPredictions = loadPredictions;

(function() {
  'use strict';
  
  // Cache for spiral dashboard data
  let spiralDashboardCache = null;
  let spiralDashboardCacheTime = null;
  const SPIRAL_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
  
  // Dashboard view - load all players automatically
  window.loadSpiralDashboard = function(forceRefresh) {
    const messageEl = document.getElementById('spiralDashboardMessage');
    const tableEl = document.getElementById('spiralDashboardTable');
    const refreshBtn = document.getElementById('spiralRefreshAllBtn');
    const detailView = document.getElementById('spiralDetailView');
    
    if (!tableEl) return;
    
    // If individual player detail view is open, don't re-render dashboard
    if (detailView && detailView.style.display !== 'none') {
      // Individual view is open, just return without re-rendering
      if (refreshBtn) refreshBtn.disabled = false;
      return;
    }
    
    // Check cache - if data exists and is fresh, and not forcing refresh, use cached data
    const now = Date.now();
    if (!forceRefresh && spiralDashboardCache && spiralDashboardCacheTime && 
        (now - spiralDashboardCacheTime) < SPIRAL_CACHE_DURATION) {
      // Use cached data - check if table already has content
      const hasContent = tableEl.innerHTML && 
        !tableEl.innerHTML.includes('Loading') && 
        !tableEl.innerHTML.includes('Failed') &&
        tableEl.innerHTML.trim().length > 0;
      
      if (hasContent) {
        // Table already rendered, just enable refresh button and return
        if (messageEl) messageEl.textContent = '';
        if (refreshBtn) refreshBtn.disabled = false;
        // Make sure cluster visualization is rendered if it exists
        if (spiralDashboardCache.playerClusters && spiralDashboardCache.playerClusters.clusters && spiralDashboardCache.playerClusters.clusters.length > 0) {
          renderPlayerClusters(spiralDashboardCache.playerClusters);
        }
        return;
      }
      
      // Table is empty, render from cache
      if (messageEl) messageEl.textContent = '';
      if (refreshBtn) refreshBtn.disabled = false;
      renderSpiralTeamSummary(spiralDashboardCache.teamSummary || {}, spiralDashboardCache.teamPredictions || null);
      // Don't render table - replaced by cluster chart
      // renderSpiralDashboard(spiralDashboardCache.players || []);
      // Store players globally for detail view dropdown
      window.spiralPlayersList = spiralDashboardCache.players || [];
      // Render charts asynchronously to prevent blocking
      if (spiralDashboardCache.teamAnalysis) {
        setTimeout(() => {
        renderSpiralTeamChart(spiralDashboardCache.teamAnalysis, spiralDashboardCache.teamPredictions || null);
        }, 50);
      }
      // Render clusters after team chart (deferred)
      if (spiralDashboardCache.playerClusters && spiralDashboardCache.playerClusters.clusters && spiralDashboardCache.playerClusters.clusters.length > 0) {
        setTimeout(() => {
          requestAnimationFrame(() => {
            renderPlayerClusters(spiralDashboardCache.playerClusters);
          });
        }, 100);
      }
      return;
    }
    
    if (messageEl) messageEl.textContent = 'Loading all players...';
    if (refreshBtn) refreshBtn.disabled = true;
    
    // Funny loading messages that rotate
    const loadingMessages = [
      'Analyzing performance spirals...',
      'Detecting dips and recoveries...',
      'Calculating baseline trajectories...',
      'Classifying learning patterns...',
      'Identifying productive vs dangerous dips...',
      'Tracking cycle progressions...',
      'Measuring spiral development...',
      'Processing player ratings...',
      'Grouping sessions by date...',
      'Finding performance patterns...',
      'Almost there, just a few more calculations...',
      'Crunching numbers like a pro...',
      'Reading between the performance lines...',
      'Connecting the dots (and dips)...',
      'Spiraling through the data...',
      'Identifying baseline periods...',
      'Classifying dip types from notes...',
      'Calculating recovery trajectories...',
      'Building performance cycles...',
      'Finalizing spiral analysis...'
    ];
    
    let messageIndex = 0;
    let progressPercent = 0;
    const startTime = Date.now();
    const estimatedDuration = 30000; // 30 seconds estimated
    let loadingInterval = null;
    
    // Initial loading display - show in message area and cluster section placeholder
    if (messageEl) {
      messageEl.innerHTML = '<div style="text-align:center; padding:20px; background:rgba(74,168,255,0.1); border-radius:8px; border:1px solid rgba(74,168,255,0.3);">' +
        '<div style="margin-bottom:12px; font-size:14px; color:#4aa8ff; font-weight:600;">⏳ ' + loadingMessages[0] + '</div>' +
        '<div style="width:100%; max-width:400px; margin:0 auto; background:rgba(255,255,255,0.1); border-radius:10px; height:8px; overflow:hidden; margin-bottom:8px;">' +
        '<div id="spiral-loading-bar" style="background:linear-gradient(90deg, #4aa8ff, #2ecc71); height:100%; width:5%; transition:width 0.3s ease; border-radius:10px; box-shadow:0 0 10px rgba(74,168,255,0.5);"></div>' +
      '</div>' +
        '<div id="spiral-loading-text" style="font-size:12px; opacity:0.7; color:#9aa5be;">Starting analysis...</div>' +
      '</div>';
    }
    
    // Also show in tableEl for backward compatibility
    tableEl.innerHTML = '<div class="muted" style="text-align:center; padding:40px;">Loading...</div>';
    
    loadingInterval = setInterval(function() {
        // Calculate progress (capped at 95% until done)
        const elapsed = Date.now() - startTime;
        progressPercent = Math.min(95, Math.floor((elapsed / estimatedDuration) * 100));
        
        // Rotate message every 5 seconds
        const msg = loadingMessages[messageIndex % loadingMessages.length];
        messageIndex++;
        
      // Update loading bar in message area
      const loadingBar = document.getElementById('spiral-loading-bar');
      const loadingText = document.getElementById('spiral-loading-text');
      const loadingMsg = messageEl?.querySelector('div[style*="font-size:14px"]');
      
      if (loadingBar) {
        loadingBar.style.width = progressPercent + '%';
      }
      if (loadingText) {
        loadingText.textContent = progressPercent + '% complete';
      }
      if (loadingMsg) {
        loadingMsg.textContent = '⏳ ' + msg;
      }
      
      // Stop if message area is gone (content loaded)
      if (!messageEl || !messageEl.innerHTML.includes('⏳')) {
        if (loadingInterval) {
          clearInterval(loadingInterval);
          loadingInterval = null;
        }
      }
    }, 2000); // Update every 2 seconds for smoother progress
    
    google.script.run
      .withSuccessHandler(function(result) {
        // Clear loading interval in all possible ways
        if (window._spiralLoadingInterval) {
          clearInterval(window._spiralLoadingInterval);
          window._spiralLoadingInterval = null;
        }
        if (loadingInterval) {
          clearInterval(loadingInterval);
          loadingInterval = null;
        }
        if (refreshBtn) refreshBtn.disabled = false;
        
        if (!result || !result.ok) {
          if (messageEl) messageEl.innerHTML = '<div style="color:#ff5a5f; padding:12px; background:rgba(255,90,95,0.1); border-radius:8px; border:1px solid rgba(255,90,95,0.3);">' + 
            (result && result.reason ? escapeHtml(result.reason) : 'Failed to load data.') + '</div>';
          tableEl.innerHTML = '<div class="muted" style="text-align:center; padding:40px;">Failed to load data.</div>';
          return;
        }
        
        // Cache the result
        spiralDashboardCache = result;
        spiralDashboardCacheTime = Date.now();
        
        // Clear loading message
        if (messageEl) messageEl.innerHTML = '';
        // Debug: log first player to check archetype data
        if (result.players && result.players.length > 0) {
          console.log('First player data:', result.players[0]);
          console.log('First player archetype:', result.players[0].archetype);
        }
        // Show content progressively for faster perceived performance
        renderSpiralTeamSummary(result.teamSummary || {}, result.teamPredictions || null);
        window.spiralPlayersList = result.players || [];
        
        // Render charts asynchronously to prevent blocking
        if (result.teamAnalysis) {
          setTimeout(() => {
          renderSpiralTeamChart(result.teamAnalysis, result.teamPredictions || null);
          }, 50);
        }
        
        // Render clusters after team chart (deferred)
        if (result.playerClusters && result.playerClusters.clusters && result.playerClusters.clusters.length > 0) {
          setTimeout(() => {
            requestAnimationFrame(() => {
              renderPlayerClusters(result.playerClusters);
            });
          }, 100);
        }
      })
      .withFailureHandler(function(err) {
        if (loadingInterval) {
          clearInterval(loadingInterval);
          loadingInterval = null;
        }
        if (refreshBtn) refreshBtn.disabled = false;
        if (messageEl) messageEl.textContent = 'Error: ' + (err.message || String(err));
        tableEl.innerHTML = '<div class="muted" style="text-align:center; padding:40px;">Error loading data.</div>';
        console.error('Spiral dashboard error:', err);
      })
      .getAllSpiralAnalysis();
  };
  
  function renderSpiralTeamSummary(teamSummary, teamPredictions) {
    const summaryEl = document.getElementById('spiralTeamSummary');
    const contentEl = document.getElementById('spiralTeamSummaryContent');
    
    if (!summaryEl || !contentEl || !teamSummary || teamSummary.totalPlayers === 0) {
      if (summaryEl) summaryEl.style.display = 'none';
      return;
    }
    
    // Show the card but hide the content (we only need the chart section)
    summaryEl.style.display = 'block';
    
    // Store team summary data for modal access (including pattern distribution)
    window.teamSummaryData = teamSummary;
    
    // Team Archetype moved to modal - store data for modal
    if (teamSummary.teamArchetype) {
      window.teamArchetypeData = teamSummary.teamArchetype;
    }
    
    // Clear content (Team Overview section removed)
    contentEl.innerHTML = '';
  }
  
  /**
   * Open Team Development Archetype Modal
   */
  function openTeamArchetypeModal() {
    const modal = document.getElementById('spiralTeamArchetypeModal');
    const contentEl = document.getElementById('teamArchetypeModalContent');
    if (!modal || !contentEl) return;
    
    const teamArch = window.teamArchetypeData;
    const teamSummary = window.teamSummaryData;
    
    if (!teamArch) {
      contentEl.innerHTML = '<div class="muted" style="text-align:center; padding:20px;">No archetype data available.</div>';
      modal.style.display = 'flex';
      return;
    }
    
    let html = '';
    
    // Pattern Distribution (moved from Team Overview)
    if (teamSummary) {
      html += '<div style="margin-bottom:24px; padding:16px; background:rgba(74,168,255,0.1); border-radius:8px; border:1px solid rgba(74,168,255,0.2);">';
      html += '<div style="font-size:13px; font-weight:600; color:#e9edf6; margin-bottom:12px;">Pattern Distribution</div>';
      html += '<div style="display:flex; flex-direction:column; gap:8px;">';
      html += '<div style="display:flex; justify-content:space-between; align-items:center;"><span style="color:#e9edf6; font-size:13px;">Line 1 (Flat):</span><span style="color:#79839a; font-weight:600; font-size:14px;">' + (teamSummary.line1Count || 0) + '</span></div>';
      html += '<div style="display:flex; justify-content:space-between; align-items:center;"><span style="color:#e9edf6; font-size:13px;">Line 2 (Dip):</span><span style="color:#ffb020; font-weight:600; font-size:14px;">' + (teamSummary.line2Count || 0) + '</span></div>';
      html += '<div style="display:flex; justify-content:space-between; align-items:center;"><span style="color:#e9edf6; font-size:13px;">Line 3 (Return):</span><span style="color:#ff5a5f; font-weight:600; font-size:14px;">' + (teamSummary.line3Count || 0) + '</span></div>';
      html += '<div style="display:flex; justify-content:space-between; align-items:center;"><span style="color:#e9edf6; font-size:13px;">Line 4 (Spiral):</span><span style="color:#2ecc71; font-weight:600; font-size:14px;">' + (teamSummary.line4Count || 0) + '</span></div>';
    html += '</div>';
      html += '</div>';
    }
    
    // Development Spectrum
    html += '<div style="margin-bottom:20px;">';
    html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">';
    html += '<span style="font-size:12px; color:#9aa5be;">Development Spectrum</span>';
    html += '<span style="font-size:12px; color:#e9edf6; font-weight:600;">' + teamArch.teamArchetype.replace(/([A-Z])/g, ' $1').trim() + '</span>';
    html += '</div>';
    
    // Spectrum bar
    const position = teamArch.position || 50;
    const spectrumLabels = ['At-Risk', 'Struggling', 'Moderate', 'Strong', 'Elite'];
    html += '<div style="position:relative; height:40px; background:linear-gradient(to right, #ff5a5f 0%, #ff9500 20%, #ffb020 40%, #4aa8ff 70%, #2ecc71 100%); border-radius:8px; margin-bottom:8px;">';
    html += '<div style="position:absolute; left:' + position + '%; top:50%; transform:translate(-50%, -50%); width:4px; height:50px; background:#fff; border-radius:2px; box-shadow:0 0 8px rgba(255,255,255,0.8);"></div>';
    html += '<div style="position:absolute; left:' + position + '%; top:100%; transform:translate(-50%, 8px); font-size:11px; font-weight:700; color:#fff; text-shadow:0 1px 3px rgba(0,0,0,0.5); white-space:nowrap;">' + teamArch.averageDevelopmentScore + '</div>';
    html += '</div>';
    
    // Spectrum labels
    html += '<div style="display:flex; justify-content:space-between; font-size:10px; color:#9aa5be; margin-top:20px;">';
    spectrumLabels.forEach((label) => {
      html += '<span>' + label + '</span>';
    });
    html += '</div>';
    html += '</div>';
    
    // Direction indicator
    const directionIcons = {
      'headingUp': '📈',
      'headingDown': '📉',
      'stable': '➡️',
      'mixed': '🔄'
    };
    const directionLabels = {
      'headingUp': 'Heading Up',
      'headingDown': 'Heading Down',
      'stable': 'Stable',
      'mixed': 'Mixed'
    };
    const directionColors = {
      'headingUp': '#2ecc71',
      'headingDown': '#ff5a5f',
      'stable': '#4aa8ff',
      'mixed': '#ffb020'
    };
    html += '<div style="display:flex; align-items:center; gap:8px; margin-bottom:16px;">';
    html += '<span style="font-size:12px; color:#9aa5be;">Direction:</span>';
    html += '<span style="font-size:16px;">' + (directionIcons[teamArch.direction] || '➡️') + '</span>';
    html += '<span style="font-size:12px; color:' + (directionColors[teamArch.direction] || '#4aa8ff') + '; font-weight:600;">' + (directionLabels[teamArch.direction] || 'Stable') + '</span>';
    html += '<span style="font-size:11px; color:#9aa5be; margin-left:auto;">(' + teamArch.improvingPlayers + ' improving, ' + teamArch.decliningPlayers + ' declining)</span>';
    html += '</div>';
    
    // Trait Profile
    if (teamArch.traitProfile) {
      html += '<div style="margin-top:20px;">';
      html += '<div style="font-size:12px; color:#9aa5be; margin-bottom:12px;">Team Trait Profile (Average)</div>';
      html += '<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px;">';
      const traits = [
        { key: 'execution', name: 'Execution' },
        { key: 'energy', name: 'Energy' },
        { key: 'communication', name: 'Communication' },
        { key: 'adaptability', name: 'Adaptability' },
        { key: 'resilience', name: 'Resilience' },
        { key: 'impact', name: 'Impact' }
      ];
      traits.forEach(trait => {
        const value = teamArch.traitProfile[trait.key];
        if (value != null) {
          const color = value >= 3.5 ? '#2ecc71' : (value >= 3.0 ? '#4aa8ff' : (value >= 2.5 ? '#ffb020' : '#ff5a5f'));
          html += '<div style="padding:8px; background:rgba(74,168,255,0.05); border-radius:6px; border-left:3px solid ' + color + ';">';
          html += '<div style="font-size:10px; color:#9aa5be; margin-bottom:4px;">' + trait.name + '</div>';
          html += '<div style="font-size:16px; font-weight:700; color:' + color + ';">' + value.toFixed(1) + '</div>';
    html += '</div>';
        }
      });
      html += '</div>';
      html += '</div>';
    }
    
    contentEl.innerHTML = html;
    modal.style.display = 'flex';
  }
  
  /**
   * Close Team Development Archetype Modal
   */
  function closeTeamArchetypeModal() {
    const modal = document.getElementById('spiralTeamArchetypeModal');
    if (modal) {
      modal.style.display = 'none';
    }
  }
  
  window.openTeamArchetypeModal = openTeamArchetypeModal;
  window.closeTeamArchetypeModal = closeTeamArchetypeModal;
  
  /**
   * Render player cluster analysis visualization
   */
  function renderPlayerClusters(clusterData) {
    if (!clusterData || !clusterData.clusters || clusterData.clusters.length === 0) {
      return;
    }
    
    // Remove existing cluster section if present to prevent duplicate rendering
    const existing = document.getElementById('player-clusters-section');
    if (existing) {
      existing.remove();
    }
    
    // Find the table card container (parent of spiralDashboardTable)
    const tableEl = document.getElementById('spiralDashboardTable');
    if (!tableEl) return;
    
    // Get the card container (parent of tableEl)
    const tableCard = tableEl.closest('.card');
    if (!tableCard) return;
    
    // Append after the table card, not inside it
    const container = tableCard.parentElement;
    if (!container) return;
    
    // Create cluster visualization section
    const clusterSection = document.createElement('div');
    clusterSection.id = 'player-clusters-section';
    clusterSection.style.cssText = 'margin-top: 40px; padding: 24px; background: rgba(74, 168, 255, 0.05); border-radius: 12px; border: 1px solid rgba(74, 168, 255, 0.2);';
    
    let html = '<div style="margin-bottom: 24px;">';
    html += '<div style="font-size: 18px; font-weight: 700; color: #e9edf6; margin-bottom: 8px;">🔍 Player Cluster Analysis</div>';
    html += '<div style="font-size: 13px; color: #9aa5be; line-height: 1.5;">Players grouped by similar development patterns, traits, and performance characteristics. Hover over cluster areas to see details. Click on a player to view their individual analysis.</div>';
    html += '</div>';
    
    // Cluster comparison chart (2D scatter plot with player images and cluster regions)
    html += '<div style="margin-top: 24px; padding: 20px; background: rgba(255, 255, 255, 0.02); border-radius: 10px; border: 1px solid rgba(74, 168, 255, 0.1);">';
    html += '<div style="font-size: 14px; font-weight: 600; color: #e9edf6; margin-bottom: 16px;">📊 Player Cluster Map - Click on a player to view details</div>';
    html += '<div id="cluster-chart-container" style="position: relative; width: 100%; height: 500px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; overflow: visible;">';
    html += '<canvas id="cluster-scatter-chart" style="width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1;"></canvas>';
    html += '<div id="cluster-player-images" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 4; pointer-events: auto;"></div>';
      html += '</div>';
    // Tooltip outside container to prevent clipping
    html += '<div id="cluster-player-tooltip" style="position: fixed; display: none; background: rgba(20, 24, 31, 0.98); border: 1px solid rgba(74, 168, 255, 0.5); border-radius: 8px; padding: 16px; color: #e9edf6; font-size: 12px; pointer-events: none; z-index: 10000; max-width: 350px; box-shadow: 0 4px 16px rgba(0,0,0,0.5);"></div>';
    html += '<div style="margin-top: 12px; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">';
    html += '<div style="font-size: 11px; color: #9aa5be;"><span style="display: inline-block; width: 12px; height: 12px; background: #2ecc71; border-radius: 50%; margin-right: 6px; vertical-align: middle;"></span> X-axis: Development Score</div>';
    html += '<div style="font-size: 11px; color: #9aa5be;"><span style="display: inline-block; width: 12px; height: 12px; background: #4aa8ff; border-radius: 50%; margin-right: 6px; vertical-align: middle;"></span> Y-axis: Average Trait Score</div>';
    html += '</div>';
    html += '</div>';
    
    clusterSection.innerHTML = html;
    // Insert after the table card, not inside it
    if (tableCard.nextSibling) {
      container.insertBefore(clusterSection, tableCard.nextSibling);
    } else {
      container.appendChild(clusterSection);
    }
    
    // Store cluster data globally for hover detection
    window.clusterDataForHover = clusterData;
    
    // Draw scatter plot after DOM is ready
    setTimeout(() => {
      drawClusterScatterPlot(clusterData);
    }, 100);
  }
  
  /**
   * Calculate convex hull using Graham scan algorithm
   */
  function calculateConvexHull(points) {
    if (points.length < 3) return points;
    
    // Create a copy to avoid mutating original
    const pts = points.map(p => ({ x: p.x, y: p.y }));
    
    // Find bottom-most point (or leftmost in case of tie)
    let bottom = 0;
    for (let i = 1; i < pts.length; i++) {
      if (pts[i].y > pts[bottom].y || 
          (pts[i].y === pts[bottom].y && pts[i].x < pts[bottom].x)) {
        bottom = i;
      }
    }
    
    // Swap bottom point to first position
    [pts[0], pts[bottom]] = [pts[bottom], pts[0]];
    
    // Sort by polar angle with respect to bottom point
    const pivot = pts[0];
    pts.slice(1).sort((a, b) => {
      const angleA = Math.atan2(a.y - pivot.y, a.x - pivot.x);
      const angleB = Math.atan2(b.y - pivot.y, b.x - pivot.x);
      if (Math.abs(angleA - angleB) > 0.0001) return angleA - angleB;
      // If same angle, keep closer one
      const distA = Math.pow(a.x - pivot.x, 2) + Math.pow(a.y - pivot.y, 2);
      const distB = Math.pow(b.x - pivot.x, 2) + Math.pow(b.y - pivot.y, 2);
      return distA - distB;
    });
    
    // Build hull
    const hull = [pts[0]];
    if (pts.length > 1) hull.push(pts[1]);
    
    for (let i = 2; i < pts.length; i++) {
      while (hull.length > 1) {
        const p1 = hull[hull.length - 2];
        const p2 = hull[hull.length - 1];
        const p3 = pts[i];
        // Cross product to check if turn is clockwise
        const cross = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
        if (cross <= 0) break; // Counter-clockwise or collinear
        hull.pop();
      }
      hull.push(pts[i]);
    }
    
    return hull;
  }
  
  /**
   * Draw 2D scatter plot for cluster visualization
   */
  function drawClusterScatterPlot(clusterData) {
    const canvas = document.getElementById('cluster-scatter-chart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const container = canvas.parentElement;
    if (!container) return;
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = 500;
    
    const padding = { top: 40, right: 40, bottom: 40, left: 60 };
    const plotWidth = canvas.width - padding.left - padding.right;
    const plotHeight = canvas.height - padding.top - padding.bottom;
    
    // Get the image container
    const imageContainer = document.getElementById('cluster-player-images');
    if (!imageContainer) return;
    imageContainer.style.pointerEvents = 'auto'; // Enable clicks on player images
    
    // Get all players from cache
    const players = spiralDashboardCache ? (spiralDashboardCache.players || []) : [];
    const validPlayers = players.filter(p => p.ok === true && p.developmentScore != null);
    
    if (validPlayers.length === 0) return;
    
    // Extract data points
    const points = validPlayers.map(player => {
      const archetype = player.archetype || {};
      const traitAverages = archetype.traitAverages || {};
      const traits = [
        traitAverages.execution || 0,
        traitAverages.energy || 0,
        traitAverages.communication || 0,
        traitAverages.adaptability || 0,
        traitAverages.resilience || 0,
        traitAverages.impact || 0
      ].filter(t => t > 0);
      const avgTrait = traits.length > 0 ? traits.reduce((a, b) => a + b, 0) / traits.length : 0;
      
      return {
        x: player.developmentScore || 0,
        y: avgTrait || 0,
        playerName: player.playerName,
        clusterId: clusterData.playerAssignments[player.playerName] !== undefined ? clusterData.playerAssignments[player.playerName] : -1
      };
    });
    
    // Find min/max for scaling with padding to spread out the data
    const xValues = points.map(p => p.x);
    const yValues = points.map(p => p.y);
    const xDataMin = Math.min(...xValues);
    const xDataMax = Math.max(...xValues);
    const yDataMin = Math.min(...yValues);
    const yDataMax = Math.max(...yValues);
    
    // Add 15% padding on each side to spread out the data and make it look more full
    const xPadding = (xDataMax - xDataMin) * 0.15;
    const yPadding = (yDataMax - yDataMin) * 0.15;
    
    const xMin = Math.max(0, xDataMin - xPadding); // Don't go below 0 for dev score
    const xMax = Math.min(100, xDataMax + xPadding); // Don't go above 100 for dev score
    const yMin = Math.max(0, yDataMin - yPadding); // Don't go below 0 for trait score
    const yMax = Math.min(5, yDataMax + yPadding); // Don't go above 5 for trait score
    
    const xRange = xMax - xMin || 1;
    const yRange = yMax - yMin || 1;
    
    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = 'rgba(74, 168, 255, 0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
      const x = padding.left + (i / 5) * plotWidth;
      ctx.beginPath();
      ctx.moveTo(x, padding.top);
      ctx.lineTo(x, padding.top + plotHeight);
      ctx.stroke();
    }
    for (let i = 0; i <= 5; i++) {
      const y = padding.top + (i / 5) * plotHeight;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(padding.left + plotWidth, y);
      ctx.stroke();
    }
    
    // Draw axes
    ctx.strokeStyle = 'rgba(74, 168, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top);
    ctx.lineTo(padding.left, padding.top + plotHeight);
    ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
    ctx.stroke();
    
    // Draw axis labels
    ctx.fillStyle = '#9aa5be';
    ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Development Score', padding.left + plotWidth / 2, canvas.height - 10);
    
    ctx.save();
    ctx.translate(15, padding.top + plotHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Average Trait Score', 0, 0);
    ctx.restore();
    
    // Draw cluster regions on separate layer
    const regionsCanvas = document.getElementById('cluster-regions-layer');
    if (regionsCanvas) {
      const regionsCtx = regionsCanvas.getContext('2d');
      regionsCanvas.width = canvas.width;
      regionsCanvas.height = canvas.height;
      
      // Cluster regions removed - no shaded areas
      // Store cluster data for tooltip (if needed in future)
      window.clusterRegionsData = clusterData.clusters.map(cluster => ({
        ...cluster,
        bounds: null
      }));
    }
    
    // Clear image container
    imageContainer.innerHTML = '';
    
    // Create image elements for each player
    const imageSize = 50; // Size of player images
    
    // Create a map of clusterId to cluster for quick lookup
    const clusterMap = {};
    clusterData.clusters.forEach((cluster, idx) => {
      clusterMap[idx] = cluster;
    });
    
    // Helper function to get phase color
    const getPhaseColor = function(player) {
      if (!player) return '#79839a';
      const phase = player.phase ? String(player.phase).toLowerCase() : '';
      if (phase === 'dip') {
        return '#ff5a5f'; // Red for dip
      } else if (phase === 'recovery' || player.isSpiraling) {
        return '#2ecc71'; // Green for spiral
      } else if (phase === 'baseline') {
        return '#4aa8ff'; // Blue for baseline
      }
      return '#79839a'; // Default gray
    };
    
    const allPoints = points.map(point => {
      const player = validPlayers.find(p => p.playerName === point.playerName);
      // Find the correct cluster by matching clusterId
      const cluster = point.clusterId >= 0 && clusterMap[point.clusterId] ? clusterMap[point.clusterId] : null;
      const clusterColor = cluster ? cluster.clusterColor : '#79839a';
      const phaseColor = getPhaseColor(player); // Get color based on phase
      
      const x = padding.left + ((point.x - xMin) / xRange) * plotWidth;
      const y = padding.top + plotHeight - ((point.y - yMin) / yRange) * plotHeight;
      
      return {
        ...point,
        x: x,
        y: y,
        color: phaseColor, // Use phase color instead of cluster color
        clusterColor: clusterColor, // Keep cluster color for reference if needed
        player: player,
        cluster: cluster
      };
    });
    
    // Fetch player photos and create image elements
    allPoints.forEach((point, index) => {
      const img = document.createElement('img');
      img.style.position = 'absolute';
      img.style.left = (point.x - imageSize / 2) + 'px';
      img.style.top = (point.y - imageSize / 2) + 'px';
      img.style.width = imageSize + 'px';
      img.style.height = imageSize + 'px';
      img.style.borderRadius = '50%';
      img.style.objectFit = 'cover';
      img.style.objectPosition = 'center top'; // Focus on head/face area (top-center)
      img.style.border = '3px solid ' + point.color;
      img.style.cursor = 'pointer';
      img.style.zIndex = '10';
      img.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
      img.style.transition = 'transform 0.2s, box-shadow 0.2s';
      img.alt = point.playerName;
      img.title = point.playerName + ' - Click to view details';
      img.dataset.playerName = point.playerName;
      
      // Hover effects
      img.addEventListener('mouseenter', function() {
        this.style.transform = 'scale(1.15)';
        this.style.boxShadow = '0 4px 12px rgba(74,168,255,0.5)';
        this.style.zIndex = '20';
      });
      img.addEventListener('mouseleave', function() {
        this.style.transform = 'scale(1)';
        this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
        this.style.zIndex = '10';
      });
      
      // Click handler to show player details
      img.addEventListener('click', function(e) {
        e.stopPropagation();
        const playerName = this.dataset.playerName;
        if (playerName && typeof window.showSpiralPlayerDetail === 'function') {
          window.showSpiralPlayerDetail(playerName);
        }
      });
      
      // Create fallback with initials immediately (for fast rendering)
      const fallback = document.createElement('div');
      fallback.style.position = 'absolute';
      fallback.style.left = (point.x - imageSize / 2) + 'px';
      fallback.style.top = (point.y - imageSize / 2) + 'px';
      fallback.style.width = imageSize + 'px';
      fallback.style.height = imageSize + 'px';
      fallback.style.borderRadius = '50%';
      fallback.style.background = point.color; // Phase color for background
      fallback.style.border = '3px solid ' + point.color; // Phase color for border
      fallback.style.display = 'flex';
      fallback.style.alignItems = 'center';
      fallback.style.justifyContent = 'center';
      fallback.style.color = '#0b0d10';
      fallback.style.fontWeight = '700';
      fallback.style.fontSize = '14px';
      fallback.style.cursor = 'pointer';
      fallback.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
      fallback.style.transition = 'transform 0.2s, box-shadow 0.2s';
      fallback.textContent = point.playerName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
      fallback.title = point.playerName + ' - Click to view details';
      fallback.dataset.playerName = point.playerName;
      fallback.id = 'player-marker-' + point.playerName.replace(/\s+/g, '-');
      
      // Hover and click handlers with tooltip
      const showTooltip = function(e) {
        const playerName = this.dataset.playerName;
        const tooltip = document.getElementById('cluster-player-tooltip');
        if (!tooltip || !playerName) return;
        
        // Find the point object for this player (it already has the cluster attached)
        const pointObj = allPoints.find(p => p.playerName === playerName);
        const player = pointObj ? pointObj.player : (window.spiralPlayersList ? window.spiralPlayersList.find(p => p.playerName === playerName) : null);
        const cluster = pointObj ? pointObj.cluster : null;
        
        // Build tooltip content
        let tooltipHtml = '<div style="font-size: 14px; font-weight: 700; color: ' + (cluster ? cluster.clusterColor : '#4aa8ff') + '; margin-bottom: 12px; border-bottom: 1px solid rgba(74,168,255,0.2); padding-bottom: 8px;">' + escapeHtml(playerName) + '</div>';
        
        // Player stats
        if (player) {
          const archetype = player.archetype || {};
          const metrics = archetype.metrics || {};
          const traitAverages = archetype.traitAverages || {};
          
          // Determine phase display
          let phaseDisplay = '—';
          let phaseColor = '#9aa5be';
          if (player.phase) {
            const phase = String(player.phase).toLowerCase();
            if (phase === 'dip') {
              phaseDisplay = 'Dip';
              phaseColor = '#ff5a5f';
            } else if (phase === 'recovery' || player.isSpiraling) {
              phaseDisplay = 'Spiral';
              phaseColor = '#2ecc71';
            } else if (phase === 'baseline') {
              phaseDisplay = 'Baseline';
              phaseColor = '#4aa8ff';
            } else {
              phaseDisplay = phase.charAt(0).toUpperCase() + phase.slice(1);
            }
          } else if (player.isSpiraling) {
            phaseDisplay = 'Spiral';
            phaseColor = '#2ecc71';
          }
          
          tooltipHtml += '<div style="margin-bottom: 12px;">';
          tooltipHtml += '<div style="font-size: 11px; color: #9aa5be; margin-bottom: 6px; font-weight: 600;">Player Stats</div>';
          tooltipHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 11px;">';
          tooltipHtml += '<div><span style="color: #9aa5be;">Dev Score:</span> <span style="color: #e9edf6; font-weight: 600;">' + (player.developmentScore || 0) + '</span></div>';
          tooltipHtml += '<div><span style="color: #9aa5be;">Avg Rating:</span> <span style="color: #e9edf6; font-weight: 600;">' + (player.currentRating ? player.currentRating.toFixed(1) : '—') + '</span></div>';
          tooltipHtml += '<div><span style="color: #9aa5be;">Cycles:</span> <span style="color: #e9edf6; font-weight: 600;">' + (player.cyclesCompleted || 0) + '</span></div>';
          tooltipHtml += '<div><span style="color: #9aa5be;">Line 4%:</span> <span style="color: #2ecc71; font-weight: 600;">' + (player.line4Percentage ? player.line4Percentage.toFixed(0) + '%' : '—') + '</span></div>';
          tooltipHtml += '<div><span style="color: #9aa5be;">Phase:</span> <span style="color: ' + phaseColor + '; font-weight: 600;">' + phaseDisplay + '</span></div>';
          tooltipHtml += '</div>';
          tooltipHtml += '</div>';
          
          // Trait averages
          if (traitAverages && Object.keys(traitAverages).length > 0) {
            tooltipHtml += '<div style="margin-bottom: 12px;">';
            tooltipHtml += '<div style="font-size: 11px; color: #9aa5be; margin-bottom: 6px; font-weight: 600;">Traits</div>';
            tooltipHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 10px;">';
            const traits = ['execution', 'energy', 'communication', 'adaptability', 'resilience', 'impact'];
            traits.forEach(trait => {
              const value = traitAverages[trait];
              if (value != null) {
                const color = value >= 3.5 ? '#2ecc71' : (value >= 3.0 ? '#4aa8ff' : (value >= 2.5 ? '#ffb020' : '#ff5a5f'));
                tooltipHtml += '<div><span style="color: #9aa5be;">' + trait.charAt(0).toUpperCase() + trait.slice(1) + ':</span> <span style="color: ' + color + '; font-weight: 600;">' + value.toFixed(1) + '</span></div>';
              }
            });
            tooltipHtml += '</div>';
            tooltipHtml += '</div>';
          }
        }
        
        tooltip.innerHTML = tooltipHtml;
        tooltip.style.display = 'block';
        
        // Position tooltip using fixed positioning (relative to viewport, not container)
        const rect = this.getBoundingClientRect();
        const tooltipWidth = 350; // max-width
        const tooltipHeight = tooltip.offsetHeight || 200; // approximate
        
        // Position above the marker by default
        let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
        let top = rect.top - tooltipHeight - 15;
        
        // Adjust if tooltip goes off screen (viewport bounds)
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const padding = 10;
        
        // Check left edge
        if (left < padding) {
          left = rect.left + rect.width + 15; // Position to the right
        }
        // Check right edge
        if (left + tooltipWidth > viewportWidth - padding) {
          left = rect.left - tooltipWidth - 15; // Position to the left
        }
        // Check top edge
        if (top < padding) {
          top = rect.bottom + 15; // Position below
        }
        // Check bottom edge
        if (top + tooltipHeight > viewportHeight - padding) {
          top = viewportHeight - tooltipHeight - padding; // Move up
        }
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
      };
      
      const hideTooltip = function() {
        hidePlayerTooltip();
      };
      
      fallback.addEventListener('mouseenter', function(e) {
        this.style.transform = 'scale(1.15)';
        this.style.boxShadow = '0 4px 12px rgba(74,168,255,0.5)';
        this.style.zIndex = '20';
        showTooltip.call(this, e);
      });
      fallback.addEventListener('mouseleave', function() {
        this.style.transform = 'scale(1)';
        this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
        this.style.zIndex = '10';
        hideTooltip();
      });
      fallback.addEventListener('click', function(e) {
        e.stopPropagation();
        const playerName = this.dataset.playerName;
        if (playerName && typeof window.showSpiralPlayerDetail === 'function') {
          window.showSpiralPlayerDetail(playerName);
        }
      });
      
      imageContainer.appendChild(fallback);
      
      // Lazy load photos - only load on hover or after delay (much faster initial render)
      const loadPhoto = function() {
        if (fallback.dataset.photoLoading === 'true') return; // Already loading
        fallback.dataset.photoLoading = 'true';
        
        setTimeout(function() {
        google.script.run
          .withSuccessHandler(function(photoUrl) {
          if (photoUrl) {
            const existing = document.getElementById('player-marker-' + point.playerName.replace(/\s+/g, '-'));
            if (existing) {
              img.src = photoUrl;
              img.style.position = 'absolute';
              img.style.left = (point.x - imageSize / 2) + 'px';
              img.style.top = (point.y - imageSize / 2) + 'px';
              img.style.width = imageSize + 'px';
              img.style.height = imageSize + 'px';
              img.style.borderRadius = '50%';
              img.style.objectFit = 'cover';
              img.style.objectPosition = 'center top'; // Focus on head/face area (top-center)
              img.style.border = '3px solid ' + point.color; // Phase color for border
              img.style.cursor = 'pointer';
              img.style.zIndex = '10';
              img.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
              img.style.transition = 'transform 0.2s, box-shadow 0.2s';
              img.alt = point.playerName;
              img.title = point.playerName + ' - Click to view details';
              img.dataset.playerName = point.playerName;
              img.id = 'player-marker-' + point.playerName.replace(/\s+/g, '-');
              
              // Reuse tooltip handlers
              const showTooltip = function(e) {
                const playerName = this.dataset.playerName;
                const tooltip = document.getElementById('cluster-player-tooltip');
                if (!tooltip || !playerName) return;
                
                // Find the point object for this player (it already has the cluster attached)
                const pointObj = allPoints.find(p => p.playerName === playerName);
                const player = pointObj ? pointObj.player : (window.spiralPlayersList ? window.spiralPlayersList.find(p => p.playerName === playerName) : null);
                const cluster = pointObj ? pointObj.cluster : null;
                
                let tooltipHtml = '<div style="font-size: 14px; font-weight: 700; color: ' + (cluster ? cluster.clusterColor : '#4aa8ff') + '; margin-bottom: 12px; border-bottom: 1px solid rgba(74,168,255,0.2); padding-bottom: 8px;">' + escapeHtml(playerName) + '</div>';
                
                if (player) {
                  const archetype = player.archetype || {};
                  const traitAverages = archetype.traitAverages || {};
                  
                  // Determine phase display
                  let phaseDisplay = '—';
                  let phaseColor = '#9aa5be';
                  if (player.phase) {
                    const phase = String(player.phase).toLowerCase();
                    if (phase === 'dip') {
                      phaseDisplay = 'Dip';
                      phaseColor = '#ff5a5f';
                    } else if (phase === 'recovery' || player.isSpiraling) {
                      phaseDisplay = 'Spiral';
                      phaseColor = '#2ecc71';
                    } else if (phase === 'baseline') {
                      phaseDisplay = 'Baseline';
                      phaseColor = '#4aa8ff';
                    } else {
                      phaseDisplay = phase.charAt(0).toUpperCase() + phase.slice(1);
                    }
                  } else if (player.isSpiraling) {
                    phaseDisplay = 'Spiral';
                    phaseColor = '#2ecc71';
                  }
                  
                  tooltipHtml += '<div style="margin-bottom: 12px;">';
                  tooltipHtml += '<div style="font-size: 11px; color: #9aa5be; margin-bottom: 6px; font-weight: 600;">Player Stats</div>';
                  tooltipHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 11px;">';
                  tooltipHtml += '<div><span style="color: #9aa5be;">Dev Score:</span> <span style="color: #e9edf6; font-weight: 600;">' + (player.developmentScore || 0) + '</span></div>';
                  tooltipHtml += '<div><span style="color: #9aa5be;">Avg Rating:</span> <span style="color: #e9edf6; font-weight: 600;">' + (player.currentRating ? player.currentRating.toFixed(1) : '—') + '</span></div>';
                  tooltipHtml += '<div><span style="color: #9aa5be;">Cycles:</span> <span style="color: #e9edf6; font-weight: 600;">' + (player.cyclesCompleted || 0) + '</span></div>';
                  tooltipHtml += '<div><span style="color: #9aa5be;">Line 4%:</span> <span style="color: #2ecc71; font-weight: 600;">' + (player.line4Percentage ? player.line4Percentage.toFixed(0) + '%' : '—') + '</span></div>';
                  tooltipHtml += '<div><span style="color: #9aa5be;">Phase:</span> <span style="color: ' + phaseColor + '; font-weight: 600;">' + phaseDisplay + '</span></div>';
                  tooltipHtml += '</div>';
                  tooltipHtml += '</div>';
                  
                  if (traitAverages && Object.keys(traitAverages).length > 0) {
                    tooltipHtml += '<div style="margin-bottom: 12px;">';
                    tooltipHtml += '<div style="font-size: 11px; color: #9aa5be; margin-bottom: 6px; font-weight: 600;">Traits</div>';
                    tooltipHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 10px;">';
                    ['execution', 'energy', 'communication', 'adaptability', 'resilience', 'impact'].forEach(trait => {
                      const value = traitAverages[trait];
                      if (value != null) {
                        const color = value >= 3.5 ? '#2ecc71' : (value >= 3.0 ? '#4aa8ff' : (value >= 2.5 ? '#ffb020' : '#ff5a5f'));
                        tooltipHtml += '<div><span style="color: #9aa5be;">' + trait.charAt(0).toUpperCase() + trait.slice(1) + ':</span> <span style="color: ' + color + '; font-weight: 600;">' + value.toFixed(1) + '</span></div>';
                      }
                    });
                    tooltipHtml += '</div>';
                    tooltipHtml += '</div>';
                  }
                }
                
                tooltip.innerHTML = tooltipHtml;
                tooltip.style.display = 'block';
                
                // Position tooltip using fixed positioning (relative to viewport, not container)
                const rect = this.getBoundingClientRect();
                const tooltipWidth = 350; // max-width
                const tooltipHeight = tooltip.offsetHeight || 200; // approximate
                
                // Position above the marker by default
                let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
                let top = rect.top - tooltipHeight - 15;
                
                // Adjust if tooltip goes off screen (viewport bounds)
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const padding = 10;
                
                // Check left edge
                if (left < padding) {
                  left = rect.left + rect.width + 15; // Position to the right
                }
                // Check right edge
                if (left + tooltipWidth > viewportWidth - padding) {
                  left = rect.left - tooltipWidth - 15; // Position to the left
                }
                // Check top edge
                if (top < padding) {
                  top = rect.bottom + 15; // Position below
                }
                // Check bottom edge
                if (top + tooltipHeight > viewportHeight - padding) {
                  top = viewportHeight - tooltipHeight - padding; // Move up
                }
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
              };
              
              const hideTooltip = function() {
                hidePlayerTooltip();
              };
              
              img.addEventListener('mouseenter', function(e) {
                this.style.transform = 'scale(1.15)';
                this.style.boxShadow = '0 4px 12px rgba(74,168,255,0.5)';
                this.style.zIndex = '20';
                showTooltip.call(this, e);
              });
              img.addEventListener('mouseleave', function() {
                this.style.transform = 'scale(1)';
                this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
                this.style.zIndex = '10';
                hideTooltip();
              });
              img.addEventListener('click', function(e) {
                e.stopPropagation();
                const playerName = this.dataset.playerName;
                if (playerName && typeof window.showSpiralPlayerDetail === 'function') {
                  window.showSpiralPlayerDetail(playerName);
                }
              });
              
              existing.replaceWith(img);
            }
          }
        })
          .withFailureHandler(function() {
            // Keep fallback if photo fails to load
          })
          .getPlayerPhoto(point.playerName);
        }, 0);
      };
      
      // Load photo on hover (immediate) and also start loading in background after delay
      fallback.addEventListener('mouseenter', loadPhoto);
      
      // Start loading photos in background batches (deferred, non-blocking)
      // Load first 5 immediately, then batches of 3 every 200ms
      const batchSize = 3;
      const batchIndex = Math.floor(index / batchSize);
      const initialLoad = index < 5; // Load first 5 immediately
      const delay = initialLoad ? 100 : (batchIndex * 200);
      setTimeout(loadPhoto, delay);
    });
  }
  
  // Store players globally for detail view dropdown
  window.spiralPlayersList = null;
  
  // Archetype information mapping
  function getArchetypeInfo(archetypeName) {
    const archetypes = {
      'plateau': {
        name: 'Plateau Performer',
        icon: '',
        color: '#79839a',
        description: 'High average rating with low spiral development. Demonstrates consistent performance but limited growth trajectory. May benefit from increased challenge levels or new training stimuli to break performance ceiling.'
      },
      'risingStar': {
        name: 'Rising Star',
        icon: '',
        color: '#2ecc71',
        description: 'Moderate current performance with high spiral development rate. Shows strong learning capacity and rapid improvement trajectory. High growth potential with continued development focus.'
      },
      'eliteDeveloper': {
        name: 'Elite Developer',
        icon: '',
        color: '#4aa8ff',
        description: 'High performance baseline combined with strong spiral development. Top-tier performer who consistently exceeds previous baselines. Demonstrates both current excellence and sustained improvement capacity.'
      },
      'clutchPerformer': {
        name: 'Clutch Performer',
        icon: '',
        color: '#9b59b6',
        description: 'Moderate average performance with high performance variance. Demonstrates ability to perform under pressure despite inconsistent practice ratings. High-impact potential when performance peaks align with competition.'
      },
      'steadyEddie': {
        name: 'Steady Performer',
        icon: '',
        color: '#ffb020',
        description: 'Moderate average performance with low variance and limited spiral development. Reliable and consistent contributor with predictable output. May require targeted interventions to stimulate growth beyond current baseline.'
      },
      'learner': {
        name: 'Adaptive Learner',
        icon: '',
        color: '#2ecc71',
        description: 'High frequency of productive performance dips with strong recovery patterns (high Line 4%). Embraces challenges and demonstrates effective learning from setbacks. Strong resilience and growth mindset indicators.'
      },
      'atRisk': {
        name: 'At-Risk Player',
        icon: '',
        color: '#ff5a5f',
        description: 'Below-average performance with multiple dangerous dip patterns and low recovery rates. Requires immediate coaching support and intervention strategies. May indicate systemic issues requiring attention.'
      },
      'volatileTalent': {
        name: 'Volatile Talent',
        icon: '',
        color: '#ffb020',
        description: 'High performance variance with mixed dip patterns (both productive and dangerous). Unpredictable performance trajectory with high ceiling potential. Requires careful monitoring and targeted support during low phases.'
      },
      'lateBloom': {
        name: 'Late Bloomer',
        icon: '',
        color: '#2ecc71',
        description: 'Low initial performance ratings with recent acceleration in spiral development. Demonstrates delayed adaptation followed by rapid improvement. Strong long-term development potential with continued support.'
      },
      'stagnant': {
        name: 'Stagnant Player',
        icon: '',
        color: '#ff5a5f',
        description: 'Low average performance, minimal spiral development, and low variance. Performance plateau with limited improvement indicators. Requires immediate coaching intervention and development strategy review.'
      },
      'unknown': {
        name: 'Undetermined',
        icon: '',
        color: '#79839a',
        description: 'Insufficient data available to determine performance archetype. Additional session data required for accurate classification.'
      },
      'insufficient_data': {
        name: 'Insufficient Data',
        icon: '',
        color: '#79839a',
        description: 'Insufficient session data to determine performance archetype. Minimum of 5 sessions required for accurate classification.'
      },
      // New development-based archetypes
      'eliteSpiral': {
        name: 'Elite Spiral',
        icon: '⭐',
        color: '#2ecc71',
        description: 'Elite development score (90-100). Exceptional spiral growth with high Line 4 recovery rate. Mostly productive dips with consistent upward trajectory. Top-tier development pattern.'
      },
      'strongDeveloper': {
        name: 'Strong Developer',
        icon: '📈',
        color: '#4aa8ff',
        description: 'Strong development score (75-89). Good spiral growth with balanced dip quality. Positive recovery patterns and upward trend. Solid development trajectory.'
      },
      'moderateDeveloper': {
        name: 'Moderate Developer',
        icon: '➡️',
        color: '#ffb020',
        description: 'Moderate development score (60-74). Mixed development patterns with some volatility. Slow but positive growth. Needs targeted support to accelerate.'
      },
      'strugglingDeveloper': {
        name: 'Struggling Developer',
        icon: '⚠️',
        color: '#ff9500',
        description: 'Low development score (45-59). Many dangerous dips with poor recovery patterns. High volatility and neutral/negative trend. Requires intervention.'
      },
      'atRisk': {
        name: 'At-Risk',
        icon: '🚨',
        color: '#ff5a5f',
        description: 'Very low development score (0-44). Multiple dangerous dips, high volatility, declining trend. Critical intervention needed.'
      }
    };
    return archetypes[archetypeName] || archetypes['unknown'];
  }
  
  function getTraitName(traitKey) {
    const traitNames = {
      'execution': 'Execution',
      'energy': 'Energy',
      'communication': 'Communication',
      'adaptability': 'Adaptability',
      'resilience': 'Resilience',
      'impact': 'Team Impact'
    };
    return traitNames[traitKey] || traitKey;
  }
  
  function renderSpiralDashboard(players) {
    const tableEl = document.getElementById('spiralDashboardTable');
    if (!tableEl) return;
    
    if (players.length === 0) {
      tableEl.innerHTML = '<div class="muted" style="text-align:center; padding:40px;">No player data available.</div>';
      return;
    }
    
    // Store players globally
    window.spiralPlayersList = players;
    
    // Sort by development score (descending), then by name
    const sortedPlayers = players.slice().sort((a, b) => {
      if (a.ok && b.ok) {
        const scoreA = a.developmentScore || a.spiralScore || 0; // Fallback to spiralScore for backward compatibility
        const scoreB = b.developmentScore || b.spiralScore || 0;
        if (scoreB !== scoreA) {
          return scoreB - scoreA; // Higher score first
        }
        return (a.playerName || '').localeCompare(b.playerName || '');
      }
      if (a.ok && !b.ok) return -1;
      if (!a.ok && b.ok) return 1;
      return (a.playerName || '').localeCompare(b.playerName || '');
    });
    
    // Create table with archetype column
    let html = '<table style="width:100%; border-collapse:collapse;">';
    html += '<thead><tr style="border-bottom:2px solid var(--border);">';
    html += '<th style="text-align:left; padding:12px; font-weight:600; color:#e9edf6;">Player</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;">Archetype</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;">Current Phase</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;">Pattern</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;">Rating</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;" title="Comprehensive score: Spiral growth (30) + Dip quality (25) + Consistency (20) + Recovery quality (15) + Trend (10)">Development Score</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;" title="Complete spiral cycles (dip → recovery → baseline). More cycles = more experience with the learning process.">Cycles</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;">Line 4 %</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;">Sessions</th>';
    html += '<th style="text-align:center; padding:12px; font-weight:600; color:#e9edf6;">Action</th>';
    html += '</tr></thead><tbody>';
    
    sortedPlayers.forEach(function(player) {
      const lineColors = {
        'Line1': '#79839a',
        'Line2': '#ffb020',
        'Line3': '#ff5a5f',
        'Line4': '#2ecc71'
      };
      
      const lineLabels = {
        'Line1': 'Flat',
        'Line2': 'Dip',
        'Line3': 'Return',
        'Line4': 'Spiral'
      };
      
      const phaseLabels = {
        'baseline': 'Baseline',
        'dip': 'Dip',
        'recovery': 'Recovery',
        'unknown': 'Unknown'
      };
      
      const lineColor = lineColors[player.line] || '#79839a';
      const lineLabel = lineLabels[player.line] || player.line || 'Unknown';
      const phaseLabel = phaseLabels[player.phase] || player.phase || 'Unknown';
      
      const rowColor = player.ok ? 'transparent' : 'rgba(255,90,95,0.1)';
      
      html += '<tr style="border-bottom:1px solid var(--border); background:' + rowColor + ';">';
      html += '<td style="padding:12px; font-weight:600; color:#e9edf6;">' + escapeHtml(player.playerName) + '</td>';
      
      if (player.ok) {
        // Enhanced Archetype badge with development archetype and trait info
        const archetype = player.archetype || {};
        const primaryArchetypeName = archetype.primaryArchetype || 'unknown';
        const devArchetypeName = archetype.developmentArchetype || 'moderateDeveloper';
        const primaryInfo = getArchetypeInfo(primaryArchetypeName);
        const devInfo = getArchetypeInfo(devArchetypeName);
        
        // Build enhanced tooltip with trait info
        let tooltipText = devInfo.description || primaryInfo.description || '';
        if (archetype.traitAnalysis) {
          const traitAnalysis = archetype.traitAnalysis;
          tooltipText += '\n\n📊 Trait Profile:';
          if (traitAnalysis.highTraits && traitAnalysis.highTraits.length > 0) {
            tooltipText += '\n✓ High: ' + traitAnalysis.highTraits.map(t => getTraitName(t.name) + ' (' + t.value.toFixed(1) + ')').join(', ');
          }
          if (traitAnalysis.lowTraits && traitAnalysis.lowTraits.length > 0) {
            tooltipText += '\n⚠ Low: ' + traitAnalysis.lowTraits.map(t => getTraitName(t.name) + ' (' + t.value.toFixed(1) + ')').join(', ');
          }
        }
        if (primaryArchetypeName !== devArchetypeName && primaryArchetypeName !== 'unknown') {
          tooltipText += '\n\nPattern: ' + primaryInfo.name;
        }
        
        // Escape description for HTML attribute
        tooltipText = tooltipText
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
          .replace(/\n/g, '&#10;');
        
        html += '<td style="padding:12px; text-align:center;">';
        // Show development archetype as primary (more relevant)
        html += '<div style="display:flex; flex-direction:column; gap:4px; align-items:center;">';
        html += '<span class="archetype-badge" style="display:inline-block; padding:4px 10px; background:' + devInfo.color + '; color:#0b0d10; border-radius:8px; font-size:11px; font-weight:500; cursor:help; opacity:0.85; transition:opacity 0.2s; position:relative;" data-tooltip="' + tooltipText + '" onmouseover="this.style.opacity=\'1\'" onmouseout="this.style.opacity=\'0.85\'">' + (devInfo.icon ? devInfo.icon + ' ' : '') + devInfo.name + '</span>';
        // Show primary archetype as secondary badge if different
        if (primaryArchetypeName !== devArchetypeName && primaryArchetypeName !== 'unknown') {
          html += '<span style="display:inline-block; padding:2px 6px; background:' + primaryInfo.color + '; color:#0b0d10; border-radius:4px; font-size:9px; opacity:0.7;">' + primaryInfo.name + '</span>';
        }
        html += '</div>';
        html += '</td>';
        
        html += '<td style="padding:12px; text-align:center; color:#e9edf6;">' + phaseLabel + '</td>';
        html += '<td style="padding:12px; text-align:center;"><span style="padding:4px 10px; background:' + lineColor + '; color:#0b0d10; border-radius:12px; font-size:11px; font-weight:600;">' + lineLabel + '</span></td>';
        html += '<td style="padding:12px; text-align:center; color:#e9edf6; font-weight:600;">' + (player.currentRating ? player.currentRating.toFixed(2) : '—') + '</td>';
        const devScore = player.developmentScore || player.spiralScore || 0; // Use developmentScore, fallback to spiralScore
        const scoreColor = devScore >= 75 ? '#2ecc71' : (devScore >= 60 ? '#ffb020' : (devScore >= 45 ? '#ff5a5f' : '#79839a'));
        html += '<td style="padding:12px; text-align:center;"><span style="font-weight:700; color:' + scoreColor + ';" title="Development Score: ' + devScore + '">' + devScore + '</span></td>';
        html += '<td style="padding:12px; text-align:center; color:#e9edf6;" title="Complete spiral cycles (dip → recovery → baseline). More cycles = more experience with the learning process.">' + (player.cyclesCompleted || 0) + '</td>';
        html += '<td style="padding:12px; text-align:center; color:#e9edf6;">' + (player.line4Percentage || 0) + '%</td>';
        html += '<td style="padding:12px; text-align:center; color:#9aa5be; font-size:12px;">' + (player.totalSessions || 0) + '</td>';
        html += '<td style="padding:12px; text-align:center;"><button class="btn btn-small" onclick="showSpiralDetail(\'' + escapeHtml(player.playerName) + '\')" style="padding:6px 12px; font-size:12px;">Details</button></td>';
      } else {
        html += '<td style="padding:12px; text-align:center;">—</td>';
        html += '<td style="padding:12px; text-align:center; color:#9aa5be;" colspan="7">' + escapeHtml(player.reason || 'No data') + '</td>';
        html += '<td style="padding:12px; text-align:center;">—</td>';
      }
      
      html += '</tr>';
    });
    
    html += '</tbody></table>';
    tableEl.innerHTML = html;
  }
  
  // Render archetype visualizations (2x2 matrix, radar charts, comparison)
  function renderArchetypeVisualizations(players) {
    const containerEl = document.getElementById('spiralArchetypeViz');
    if (!containerEl) return;
    
    const validPlayers = players.filter(p => p.ok && p.archetype);
    if (validPlayers.length === 0) {
      containerEl.style.display = 'none';
      return;
    }
    
    containerEl.style.display = 'block';
    let html = '<div style="margin-top:30px;">';
    html += '<h3 style="color:#e9edf6; margin-bottom:20px; font-size:18px;">Player Archetypes</h3>';
    
    // 2x2 Matrix: Avg Rating vs Spiral Score
    html += '<div style="margin-bottom:30px;">';
    html += '<h4 style="color:#9aa5be; font-size:14px; margin-bottom:12px;">Performance Matrix (Avg Rating vs Spiral Score)</h4>';
    html += '<div style="position:relative; width:100%; max-width:600px; height:400px; background:rgba(74,168,255,0.05); border:1px solid var(--border); border-radius:8px; padding:20px;">';
    
    // Y-axis label (Spiral Score)
    html += '<div style="position:absolute; left:-40px; top:50%; transform:rotate(-90deg); color:#9aa5be; font-size:12px;">Spiral Score</div>';
    
    // X-axis label (Avg Rating)
    html += '<div style="position:absolute; bottom:-30px; left:50%; transform:translateX(-50%); color:#9aa5be; font-size:12px;">Average Rating</div>';
    
    // Plot players
    validPlayers.forEach(function(player) {
      const avgRating = player.archetype.metrics.avgRating || 0;
      const spiralScore = player.spiralScore || 0;
      const archetypeInfo = getArchetypeInfo(player.archetype.primaryArchetype);
      
      // Normalize positions (rating: 1-5, spiral: 0-100)
      const x = ((avgRating - 1) / 4) * 100; // 0-100%
      const y = 100 - (spiralScore / 100) * 100; // Invert Y axis
      
      html += '<div style="position:absolute; left:' + x + '%; top:' + y + '%; transform:translate(-50%, -50%); cursor:pointer;" title="' + escapeHtml(player.playerName) + ' - ' + archetypeInfo.name + '">';
      html += '<div style="width:12px; height:12px; background:' + archetypeInfo.color + '; border-radius:50%; border:2px solid #0b0d10; box-shadow:0 2px 4px rgba(0,0,0,0.3);"></div>';
      html += '</div>';
    });
    
    // Grid lines
    for (let i = 0; i <= 4; i++) {
      const x = (i / 4) * 100;
      html += '<div style="position:absolute; left:' + x + '%; top:0; bottom:0; width:1px; background:rgba(255,255,255,0.1);"></div>';
    }
    for (let i = 0; i <= 4; i++) {
      const y = (i / 4) * 100;
      html += '<div style="position:absolute; left:0; right:0; top:' + y + '%; height:1px; background:rgba(255,255,255,0.1);"></div>';
    }
    
    html += '</div>';
    html += '</div>';
    
    // Archetype Distribution
    html += '<div style="margin-bottom:30px;">';
    html += '<h4 style="color:#9aa5be; font-size:14px; margin-bottom:12px;">Archetype Distribution</h4>';
    html += '<div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px;">';
    
    const archetypeCounts = {};
    validPlayers.forEach(function(player) {
      const arch = player.archetype.primaryArchetype || 'unknown';
      archetypeCounts[arch] = (archetypeCounts[arch] || 0) + 1;
    });
    
    Object.entries(archetypeCounts).sort((a, b) => b[1] - a[1]).forEach(function([archName, count]) {
      const archInfo = getArchetypeInfo(archName);
      const percentage = Math.round((count / validPlayers.length) * 100);
      html += '<div style="padding:12px; background:rgba(74,168,255,0.05); border-radius:6px; border-left:3px solid ' + archInfo.color + ';">';
      html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">';
      html += '<span style="font-size:14px; font-weight:600; color:#e9edf6;">' + archInfo.icon + ' ' + archInfo.name + '</span>';
      html += '<span style="font-size:18px; font-weight:700; color:' + archInfo.color + ';">' + count + '</span>';
      html += '</div>';
      html += '<div style="width:100%; height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;">';
      html += '<div style="width:' + percentage + '%; height:100%; background:' + archInfo.color + '; transition:width 0.3s ease;"></div>';
      html += '</div>';
      html += '<div style="font-size:11px; color:#9aa5be; margin-top:4px;">' + percentage + '% of players</div>';
      html += '</div>';
    });
    
    html += '</div>';
    html += '</div>';
    
    // Individual Player Archetype Cards (with radar charts)
    html += '<div style="margin-top:30px;">';
    html += '<h4 style="color:#9aa5be; font-size:14px; margin-bottom:12px;">Player Archetype Profiles</h4>';
    html += '<div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(300px, 1fr)); gap:16px;">';
    
    validPlayers.slice(0, 12).forEach(function(player) { // Show first 12 players
      const arch = player.archetype;
      const archInfo = getArchetypeInfo(arch.primaryArchetype);
      const metrics = arch.metrics || {};
      
      html += '<div style="padding:16px; background:rgba(74,168,255,0.05); border-radius:8px; border:1px solid var(--border); border-left:4px solid ' + archInfo.color + ';">';
      html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">';
      html += '<div style="font-size:16px; font-weight:700; color:#e9edf6;">' + escapeHtml(player.playerName) + '</div>';
      html += '<span style="padding:4px 10px; background:' + archInfo.color + '; color:#0b0d10; border-radius:12px; font-size:11px; font-weight:600;">' + archInfo.icon + ' ' + archInfo.name + '</span>';
      html += '</div>';
      
      // Mini radar chart (simplified)
      html += '<div style="margin:12px 0; padding:12px; background:rgba(0,0,0,0.2); border-radius:6px;">';
      html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:8px;">Performance Metrics</div>';
      
      const metricBars = [
        { label: 'Avg Rating', value: metrics.avgRating || 0, max: 5, color: '#4aa8ff' },
        { label: 'Spiral', value: metrics.spiralScore || 0, max: 100, color: '#2ecc71' },
        { label: 'Consistency', value: metrics.consistencyScore || 0, max: 100, color: '#ffb020' },
        { label: 'Growth', value: (metrics.growthRate || 0) * 10, max: 5, color: '#9b59b6' },
        { label: 'Recovery', value: metrics.recoveryRate || 0, max: 100, color: '#2ecc71' }
      ];
      
      metricBars.forEach(function(metric) {
        const percentage = Math.min(100, (metric.value / metric.max) * 100);
        html += '<div style="margin-bottom:6px;">';
        html += '<div style="display:flex; justify-content:space-between; margin-bottom:2px;">';
        html += '<span style="font-size:10px; color:#9aa5be;">' + metric.label + '</span>';
        html += '<span style="font-size:10px; color:#e9edf6; font-weight:600;">' + metric.value.toFixed(1) + '</span>';
        html += '</div>';
        html += '<div style="width:100%; height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;">';
        html += '<div style="width:' + percentage + '%; height:100%; background:' + metric.color + '; transition:width 0.3s ease;"></div>';
        html += '</div>';
        html += '</div>';
      });
      
      html += '</div>';
      
      // Secondary traits
      if (arch.secondaryTraits && arch.secondaryTraits.length > 0) {
        html += '<div style="margin-top:8px; font-size:11px; color:#9aa5be;">';
        html += 'Also shows: ' + arch.secondaryTraits.map(function(trait) {
          return getArchetypeInfo(trait).name;
        }).join(', ');
        html += '</div>';
      }
      
      html += '</div>';
    });
    
    html += '</div>';
    html += '</div>';
    
    html += '</div>';
    containerEl.innerHTML = html;
  }
  
  function renderSpiralTeamChart(teamAnalysis, teamPredictions) {
    const canvas = document.getElementById('spiralTeamChart');
    if (!canvas || typeof Chart === 'undefined') return;
    
    // Destroy existing chart
    if (spiralTeamChart) {
      try { spiralTeamChart.destroy(); } catch(e) {}
      spiralTeamChart = null;
    }
    
    if (!teamAnalysis || !teamAnalysis.sessions || teamAnalysis.sessions.length === 0) return;
    
    const ctx = canvas.getContext('2d');
    const sessions = teamAnalysis.sessions;
    const baselines = teamAnalysis.baselines || [];
    const dips = teamAnalysis.dips || [];
    const volatilityPeriods = teamAnalysis.volatilityPeriods || [];
    const flatPeriods = teamAnalysis.flatPeriods || [];
    const recoveries = teamAnalysis.recoveries || [];
    
    console.log('[Chart Render] Flat periods:', flatPeriods.length, flatPeriods);
    
    // Create labels (dates)
    const labels = sessions.map((s, idx) => {
      const date = new Date(s.date);
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    });
    
    // Main team average rating line
    const ratingData = sessions.map(s => s.value);
    
    // Create datasets
    const datasets = [{
      label: 'Team Average',
      data: ratingData,
      borderColor: '#4aa8ff',
      backgroundColor: 'rgba(74,168,255,0.1)',
      tension: 0.4,
      fill: false,
      pointRadius: 3,
      pointHoverRadius: 5,
      borderWidth: 3
    }];
    
    // Add baseline lines
    baselines.forEach((baseline) => {
      const baselineData = new Array(sessions.length).fill(null);
      for (let i = baseline.startIndex; i <= baseline.endIndex && i < sessions.length; i++) {
        baselineData[i] = baseline.value;
      }
      datasets.push({
        label: `Baseline ${baseline.baselineNumber}`,
        data: baselineData,
        borderColor: '#79839a',
        borderDash: [5, 5],
        borderWidth: 2,
        pointRadius: 0,
        fill: false
      });
    });
    
    // Add dip markers
    dips.forEach((dip) => {
      const dipData = new Array(sessions.length).fill(null);
      for (let i = dip.startIndex; i <= dip.endIndex && i < sessions.length; i++) {
        dipData[i] = sessions[i].value;
      }
      // Color logic: productive or unknown = yellow, dangerous = red
      const isProductive = dip.type === 'productive' || dip.type === 'unknown';
      datasets.push({
        label: `Dip ${dip.dipNumber} (${dip.type === 'unknown' ? 'learning' : dip.type})`,
        data: dipData,
        borderColor: isProductive ? '#ffb020' : '#ff5a5f',
        backgroundColor: isProductive ? 'rgba(255,176,32,0.3)' : 'rgba(255,90,95,0.3)',
        borderWidth: 3,
        pointRadius: 4,
        pointHoverRadius: 6,
        fill: true,
        tension: 0.4,
        dipInfo: dip // Store dip info for tooltip keyword display
      });
    });
    
    // Add flat periods (stable baselines with no improvement)
    if (flatPeriods && flatPeriods.length > 0) {
      console.log('[Flat Periods] Found', flatPeriods.length, 'flat periods');
      flatPeriods.forEach((fp) => {
        const fpData = new Array(sessions.length).fill(null);
        // Fill with the actual rating values for the period
        for (let i = fp.startIndex; i <= fp.endIndex && i < sessions.length; i++) {
          fpData[i] = sessions[i].value;
        }
        // Add a dataset that fills the area
        datasets.push({
          label: `Flat Period ${fp.periodNumber}`,
          data: fpData,
          borderColor: '#79839a', // Gray color
          backgroundColor: 'rgba(121,131,154,0.3)', // Gray with transparency - increased opacity
          borderWidth: 2,
          borderDash: [4, 4], // Dashed border to distinguish from solid dips
          pointRadius: 0,
          fill: '-1', // Fill to the previous dataset (main rating line)
          tension: 0.4,
          order: 3, // Render behind dips and volatility but above baselines
          flatPeriodInfo: fp // Store info for tooltip
        });
      });
    } else {
      console.log('[Flat Periods] No flat periods found in data');
    }
    
    // Add volatility periods (Inconsistent Performance)
    volatilityPeriods.forEach((vp) => {
      const vpData = new Array(sessions.length).fill(null);
      for (let i = vp.startIndex; i <= vp.endIndex && i < sessions.length; i++) {
        vpData[i] = sessions[i].value;
      }
      datasets.push({
        label: `Inconsistent Performance`,
        data: vpData,
        borderColor: '#00d4ff', // Cyan color
        backgroundColor: 'rgba(0,212,255,0.15)', // Light cyan with transparency
        borderWidth: 2,
        borderDash: [8, 4], // Striped pattern
        pointRadius: 0,
        fill: 'origin',
        tension: 0.4,
        order: 2, // Render behind dips but above baselines
        volatilityInfo: vp // Store info for tooltip
      });
    });
    
    // Add recovery markers (make them very visible)
    recoveries.forEach((recovery) => {
      const recoveryData = new Array(sessions.length).fill(null);
      if (recovery.recoveryIndex < sessions.length) {
        recoveryData[recovery.recoveryIndex] = recovery.recoveryValue;
      }
      datasets.push({
        label: recovery.exceedsBaseline ? 'Recovery (Line 4)' : 'Recovery (Line 3)',
        data: recoveryData,
        borderColor: recovery.exceedsBaseline ? '#2ecc71' : '#ff5a5f',
        backgroundColor: recovery.exceedsBaseline ? '#2ecc71' : '#ff5a5f',
        pointRadius: 12,
        pointHoverRadius: 14,
        pointStyle: 'triangle', // Triangle shape to stand out
        borderWidth: 4,
        showLine: false,
        order: -1 // Draw on top of other elements
      });
    });
    
    // Add projected trajectory line with extended cycle prediction if available
    if (teamAnalysis.trajectory && teamAnalysis.trajectory.projected && teamAnalysis.trajectory.projected.length > 0) {
      // Use extended projection if available (includes predicted cycle), otherwise use short-term projection
      const projectionToUse = teamAnalysis.trajectory.extendedProjection || teamAnalysis.trajectory.projected;
      const cyclePrediction = teamAnalysis.trajectory.cyclePrediction || null;
      
      const projectedData = new Array(sessions.length + projectionToUse.length).fill(null);
      // Set last actual value as starting point
      projectedData[sessions.length - 1] = sessions[sessions.length - 1].value;
      
      // Extend labels for projected points FIRST (before using extendedLabels)
      const extendedLabels = [...labels];
      const totalProjectedSessions = projectionToUse.length;
      for (let i = 1; i <= totalProjectedSessions; i++) {
        const lastDate = new Date(sessions[sessions.length - 1].date);
        const nextDate = new Date(lastDate);
        nextDate.setDate(nextDate.getDate() + (i * 7)); // Assume weekly sessions
        extendedLabels.push(nextDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
      }
      
      // Add projected values
      projectionToUse.forEach(function(proj, idx) {
        const dataIdx = sessions.length + idx;
        if (dataIdx < projectedData.length) {
          projectedData[dataIdx] = proj.value;
        }
      });
      
      // Add purple shaded area for predicted dip period
      if (cyclePrediction && cyclePrediction.dip) {
        try {
          const dip = cyclePrediction.dip;
          const dipShadeData = new Array(extendedLabels.length).fill(null);
          
          // Fill the dip period with the trajectory values
          for (let i = dip.startSession; i <= dip.endSession && i < extendedLabels.length; i++) {
            // Find the value at this point in the projected data
            if (i >= sessions.length && i < projectedData.length) {
              dipShadeData[i] = projectedData[i];
            } else if (i < sessions.length) {
              // Use actual session value if in past
              dipShadeData[i] = sessions[i].value;
            }
          }
          
          // Add shaded area dataset (draws behind the line)
          datasets.push({
            label: 'Predicted Dip Area',
            data: dipShadeData,
            borderColor: 'transparent',
            backgroundColor: 'rgba(155, 89, 182, 0.2)', // Purple with transparency
            pointRadius: 0,
            fill: 'origin', // Fill to zero/axis
            tension: 0.4,
            order: 1 // Behind the trajectory line
          });
        } catch (e) {
          console.error('Error adding predicted dip area:', e);
        }
      }
      
      // Add main projected trajectory line
      datasets.push({
        label: 'Projected Trajectory',
        data: projectedData,
        borderColor: '#9b59b6', // Purple color for projection
        backgroundColor: 'transparent',
        borderWidth: 2,
        borderDash: [5, 5], // Dashed line
        pointRadius: function(context) {
          // Make predicted dip, recovery, and peak points larger
          const idx = context.dataIndex;
          if (idx >= sessions.length) {
            const projIdx = idx - sessions.length;
            const proj = projectionToUse[projIdx];
            if (proj && (proj.isDip || proj.isRecovery || proj.isPeak)) {
              return 6;
            }
          }
          return 3;
        },
        pointHoverRadius: 7,
        fill: false,
        tension: 0.4,
        order: 0 // Draw after main line but before recovery markers
      });
      
      // Add visual markers for predicted dip, recovery, and peak
      if (cyclePrediction) {
        // Predicted dip marker (show at lowest point)
        if (cyclePrediction.dip) {
          const dip = cyclePrediction.dip;
          const dipData = new Array(extendedLabels.length).fill(null);
          // Find the lowest point in the dip (middle of dip duration)
          // dip.startSession and dip.endSession are absolute session numbers (0-based from first session)
          // extendedLabels array is also 0-based, so dipMiddleSession is already the correct index
          const dipMiddleSession = Math.floor((dip.startSession + dip.endSession) / 2);
          
          // dipMiddleSession is already the correct index in extendedLabels
          // Just ensure it's in the future (after actual sessions) and within bounds
          if (dipMiddleSession >= sessions.length && dipMiddleSession < extendedLabels.length) {
            dipData[dipMiddleSession] = dip.lowestValue;
            datasets.push({
              label: 'Predicted Dip (Lowest Point)',
              data: dipData,
              borderColor: '#ffb020',
              backgroundColor: '#ffb020',
              pointRadius: 8,
              pointHoverRadius: 10,
              pointStyle: 'circle',
              borderWidth: 3,
              showLine: false,
              order: -1
            });
          }
        }
        
        // Predicted recovery marker
        if (cyclePrediction.recovery) {
          const recovery = cyclePrediction.recovery;
          const recoveryData = new Array(extendedLabels.length).fill(null);
          // recovery.session is already an absolute session number (0-based)
          // So it's already the correct index in extendedLabels
          const recoveryIdx = recovery.session;
          
          // Ensure it's in the future (after actual sessions) and within bounds
          if (recoveryIdx >= sessions.length && recoveryIdx < extendedLabels.length) {
            recoveryData[recoveryIdx] = recovery.value;
            // Use same colors as actual recoveries: green for Line 4, red for Line 3
            const recoveryColor = recovery.exceedsBaseline ? '#2ecc71' : '#ff5a5f';
            datasets.push({
              label: 'Predicted Recovery (' + recovery.type + ')',
              data: recoveryData,
              borderColor: recoveryColor,
              backgroundColor: recoveryColor,
              pointRadius: 12,
              pointHoverRadius: 14,
              pointStyle: 'triangle', // Triangle shape like actual recoveries
              borderWidth: 4,
              showLine: false,
              order: -1 // Draw on top of other elements
            });
          }
        }
        
        // Predicted peak marker
        if (cyclePrediction.peak) {
          const peak = cyclePrediction.peak;
          const peakData = new Array(extendedLabels.length).fill(null);
          const peakIdx = peak.session - sessions.length;
          
          if (peakIdx >= 0 && peakIdx < extendedLabels.length) {
            peakData[peakIdx] = peak.value;
            datasets.push({
              label: 'Predicted Peak',
              data: peakData,
              borderColor: '#2ecc71',
              backgroundColor: '#2ecc71',
              pointRadius: 12,
              pointHoverRadius: 14,
              pointStyle: 'star',
              borderWidth: 3,
              showLine: false,
              order: -2 // Draw on top
            });
          }
        }
      }
      
      // Update labels to include projected dates
      labels.length = 0;
      labels.push(...extendedLabels);
    }
    
    // Store dips and volatility periods in variables accessible to tooltip
    const teamDips = dips;
    const teamVolatilityPeriods = volatilityPeriods;
    
    // Fetch team clips asynchronously (lazy load)
    spiralTeamChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false, // Disable animations to prevent freezing
        transitions: {
          active: {
            animation: {
              duration: 0
            }
          }
        },
        interaction: {
          mode: 'index',
          intersect: false
        },
        plugins: {
          legend: { 
            display: false // Remove legend - description text explains everything
          },
          tooltip: {
            callbacks: {
              title: function(context) {
                const idx = context[0].dataIndex;
                return sessions[idx] ? sessions[idx].session + ' - ' + labels[idx] : labels[idx];
              },
              label: function(context) {
                const value = context.parsed.y;
                if (value === null) return null;
                return context.dataset.label + ': ' + value.toFixed(2);
              },
              afterBody: function(context) {
                const lines = [];
                const idx = context[0].dataIndex;
                
                // Prediction info removed per user request
                
                // Find which dip this point belongs to
                const matchingDip = teamDips.find(function(d) {
                  return idx >= d.startIndex && idx <= d.endIndex;
                });
                
                if (matchingDip) {
                  if (matchingDip.type === 'productive' && matchingDip.matchedLearningKeywords && matchingDip.matchedLearningKeywords.length > 0) {
                    lines.push('✓ Learning keywords: ' + matchingDip.matchedLearningKeywords.join(', '));
                  }
                  if (matchingDip.type === 'dangerous' && matchingDip.matchedConcernKeywords && matchingDip.matchedConcernKeywords.length > 0) {
                    lines.push('⚠ Concern keywords: ' + matchingDip.matchedConcernKeywords.join(', '));
                  }
                  
                  // Add trait correlation information
                  if (matchingDip.traitCorrelations && matchingDip.traitCorrelations.correlatedTraits && matchingDip.traitCorrelations.correlatedTraits.length > 0) {
                    lines.push('');
                    lines.push('📊 Trait Correlations:');
                    matchingDip.traitCorrelations.correlatedTraits.forEach(function(corr) {
                      const dropText = corr.dropPercent != null 
                        ? '↓' + corr.dropPercent.toFixed(1) + '%'
                        : '↓' + corr.drop.toFixed(2);
                      lines.push('  • ' + corr.trait + ': ' + dropText);
                      
                      // Add players with lowest ratings for this trait
                      if (corr.lowestPlayers && corr.lowestPlayers.length > 0) {
                        const playerList = corr.lowestPlayers.map(function(p) {
                          return p.player + ' (' + p.average.toFixed(2) + ')';
                        }).join(', ');
                        lines.push('    Players: ' + playerList);
                      }
                    });
                  }
                }
                
                // Find which volatility period this point belongs to
                const matchingVolatility = teamVolatilityPeriods.find(function(v) {
                  return idx >= v.startIndex && idx <= v.endIndex;
                });
                
                if (matchingVolatility) {
                  lines.push('');
                  lines.push('⚠️ Inconsistent Performance');
                  lines.push('Std Dev: ' + matchingVolatility.stdDev.toFixed(2));
                  lines.push('Range: ' + matchingVolatility.minValue.toFixed(2) + ' - ' + matchingVolatility.maxValue.toFixed(2));
                  lines.push('Avg: ' + matchingVolatility.mean.toFixed(2));
                  if (matchingVolatility.isAlternating) {
                    lines.push('Pattern: Alternating highs/lows');
                  }
                  if (matchingVolatility.type === 'volatile-learning' && matchingVolatility.matchedLearningKeywords && matchingVolatility.matchedLearningKeywords.length > 0) {
                    lines.push('✓ Learning keywords: ' + matchingVolatility.matchedLearningKeywords.join(', '));
                  }
                  if (matchingVolatility.type === 'volatile-concern' && matchingVolatility.matchedConcernKeywords && matchingVolatility.matchedConcernKeywords.length > 0) {
                    lines.push('⚠ Concern keywords: ' + matchingVolatility.matchedConcernKeywords.join(', '));
                  }
                }
                
                // Add cycle information to tooltip
                const cycles = teamAnalysis.cycles || [];
                const cycleInfo = [];
                
                // Find which cycle this point belongs to
                cycles.forEach(cycle => {
                  if (cycle.baseline && idx >= cycle.baseline.startIndex && idx <= cycle.baseline.endIndex) {
                    cycleInfo.push('Cycle ' + cycle.cycleNumber + ': ' + cycle.type);
                  }
                  if (cycle.dip && idx >= cycle.dip.startIndex && idx <= cycle.dip.endIndex) {
                    cycleInfo.push('Cycle ' + cycle.cycleNumber + ': ' + cycle.type);
                  }
                  if (cycle.recovery && idx === cycle.recovery.recoveryIndex) {
                    cycleInfo.push('Cycle ' + cycle.cycleNumber + ': ' + cycle.type);
                  }
                });
                
                if (cycleInfo.length > 0) {
                  lines.push('Cycle: ' + cycleInfo[0]);
                }
                
                // Add competition initials for predicted points
                if (spiralTeamChart && spiralTeamChart._competitionData) {
                  const competitionData = spiralTeamChart._competitionData;
                  const matchingCompetition = competitionData.positions.find(function(pos) {
                    return pos.dataIndex === idx;
                  });
                  
                  if (matchingCompetition && matchingCompetition.initials) {
                    lines.push('');
                    let competitionLine = '🏀 Competition: ' + matchingCompetition.initials + ' (' + matchingCompetition.competition + ')';
                    if (matchingCompetition.opponent) {
                      competitionLine += ' vs ' + matchingCompetition.opponent;
                    }
                    lines.push(competitionLine);
                  }
                }
                
                return lines.length > 0 ? lines : null;
              }
            }
          },
          annotation: {
            annotations: {}
          }
        },
        scales: {
          y: {
            beginAtZero: false,
            min: 1,
            max: 5.4, // Extended to accommodate clip icons at top
            ticks: { 
              color: '#9aa5be',
              stepSize: 0.5
            },
            grid: { color: 'rgba(255,255,255,0.1)' }
          },
          x: {
            ticks: { 
              color: '#9aa5be',
              maxRotation: 45,
              minRotation: 0
            },
            grid: { color: 'rgba(255,255,255,0.05)' }
          }
        }
      }
    });
    
    // Fetch competition data for predicted dots asynchronously
    if (teamPredictions && teamAnalysis.trajectory && teamAnalysis.trajectory.projected && teamAnalysis.trajectory.projected.length > 0) {
      google.script.run
        .withSuccessHandler(function(competitionData) {
          if (competitionData && competitionData.ok && competitionData.dateToCompetition && Object.keys(competitionData.dateToCompetition).length > 0 && spiralTeamChart) {
            addCompetitionLogosToChart(spiralTeamChart, teamAnalysis, competitionData.dateToCompetition);
          }
        })
        .withFailureHandler(function(err) {
          console.warn('[Competition Initials] Competition data not available:', err);
        })
        .getCompetitionLogosForPredictions();
    }
    
    // Fetch team clips asynchronously after chart is created
    if (ENABLE_SPIRAL_CLIPS && sessions && sessions.length > 0 && !_fetchingTeamClips) {
      const sessionDates = sessions.map(s => s.date);
      const allPlayerNames = window.spiralPlayersList ? window.spiralPlayersList.filter(p => p.ok).map(p => p.playerName) : [];
      
      if (allPlayerNames.length > 0) {
        console.log('[Spiral Clips] Fetching team clips for', allPlayerNames.length, 'players, dates:', sessionDates.length);
        _fetchingTeamClips = true;
        
        google.script.run
          .withSuccessHandler(function(clipsByDate) {
            _fetchingTeamClips = false;
            console.log('[Spiral Clips] Received team clips:', Object.keys(clipsByDate || {}).length, 'dates');
            if (clipsByDate && Object.keys(clipsByDate).length > 0 && spiralTeamChart) {
              addClipMarkersToChart(spiralTeamChart, sessions, clipsByDate);
            }
          })
          .withFailureHandler(function(err) {
            _fetchingTeamClips = false;
            console.warn('[Spiral Clips] Team clips not available:', err);
          })
          .getTeamClipsForSessions(sessionDates, allPlayerNames);
      }
    }
  }
  
  // Show detailed view for a player
  window.showSpiralDetail = function(playerName) {
    const dashboardEl = document.getElementById('spiralDashboardTable');
    const detailEl = document.getElementById('spiralDetailView');
    const playerNameEl = document.getElementById('spiralDetailPlayerName');
    const playerSelector = document.getElementById('spiralPlayerSelector');
    
    if (!detailEl || !playerNameEl) return;
    
    if (dashboardEl) dashboardEl.closest('.card').style.display = 'none';
    detailEl.style.display = 'block';
    playerNameEl.textContent = playerName;
    
    // Populate player selector dropdown
    if (playerSelector && window.spiralPlayersList) {
      playerSelector.innerHTML = '<option value="">Select a player...</option>';
      const sortedPlayers = window.spiralPlayersList.slice().sort((a, b) => {
        if (a.ok && b.ok) {
          const scoreA = a.spiralScore || 0;
          const scoreB = b.spiralScore || 0;
          if (scoreB !== scoreA) return scoreB - scoreA;
          return (a.playerName || '').localeCompare(b.playerName || '');
        }
        if (a.ok && !b.ok) return -1;
        if (!a.ok && b.ok) return 1;
        return (a.playerName || '').localeCompare(b.playerName || '');
      });
      
      sortedPlayers.forEach(function(player) {
        if (player.ok) {
          const option = document.createElement('option');
          option.value = player.playerName;
          option.textContent = player.playerName + ' (Score: ' + (player.spiralScore || 0) + ')';
          if (player.playerName === playerName) {
            option.selected = true;
          }
          playerSelector.appendChild(option);
        }
      });
    }
    
    // Load detailed analysis
    loadSpiralPlayerDetail(playerName);
  };
  
  // Load player detail (separate function for reuse)
  function loadSpiralPlayerDetail(playerName) {
    google.script.run
      .withSuccessHandler(function(result) {
        if (!result || !result.ok) {
          const statusEl = document.getElementById('spiralCurrentStatus');
          if (statusEl) statusEl.innerHTML = '<div class="muted">Failed to load details: ' + escapeHtml(result && result.reason ? result.reason : 'Unknown error') + '</div>';
          return;
        }
        renderSpiralAnalysis(result);
      })
      .withFailureHandler(function(err) {
        const statusEl = document.getElementById('spiralCurrentStatus');
        if (statusEl) statusEl.innerHTML = '<div class="muted">Error: ' + escapeHtml(err.message || String(err)) + '</div>';
        console.error('Spiral detail error:', err);
      })
      .getSpiralAnalysis(playerName);
  }
  
  // Switch to different player from dropdown
  window.switchSpiralPlayer = function(playerName) {
    if (!playerName) return;
    const playerNameEl = document.getElementById('spiralDetailPlayerName');
    if (playerNameEl) {
      playerNameEl.textContent = playerName;
    }
    loadSpiralPlayerDetail(playerName);
  };
  
  // Show player detail view
  window.showSpiralPlayerDetail = function(playerName) {
    if (!playerName) return;
    
    const detailEl = document.getElementById('spiralDetailView');
    const playerNameEl = document.getElementById('spiralDetailPlayerName');
    
    if (playerNameEl) {
      playerNameEl.textContent = playerName;
    }
    
    // Show detail view and position it after the cluster section
    if (detailEl) {
      detailEl.style.display = 'block';
      
      // Move detail view to appear after cluster section
      const clusterSection = document.getElementById('player-clusters-section');
      if (clusterSection && clusterSection.parentNode) {
        // Remove from current position if it's already in DOM
        if (detailEl.parentNode) {
          detailEl.parentNode.removeChild(detailEl);
        }
        // Insert after cluster section
        if (clusterSection.nextSibling) {
          clusterSection.parentNode.insertBefore(detailEl, clusterSection.nextSibling);
        } else {
          clusterSection.parentNode.appendChild(detailEl);
        }
      }
      
      // Scroll to detail view
      setTimeout(() => {
        detailEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 100);
    }
    
    // Populate player selector if needed
    const playerSelector = document.getElementById('spiralPlayerSelector');
    if (playerSelector && window.spiralPlayersList) {
      playerSelector.innerHTML = '<option value="">Select a player...</option>';
      window.spiralPlayersList.forEach(function(p) {
        if (p.ok) {
          const option = document.createElement('option');
          option.value = p.playerName;
          option.textContent = p.playerName;
          if (p.playerName === playerName) option.selected = true;
          playerSelector.appendChild(option);
        }
      });
    }
    
    // Load detailed analysis
    loadSpiralPlayerDetail(playerName);
  };
  
  // Close detailed view
  window.closeSpiralDetail = function() {
    const detailEl = document.getElementById('spiralDetailView');
    
    // Hide detail view
    if (detailEl) detailEl.style.display = 'none';
    
    // Scroll to top of cluster section
    const clusterSection = document.getElementById('player-clusters-section');
    if (clusterSection) {
      clusterSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  };
  
  // Legacy function for backward compatibility (if needed)
  window.loadSpiralAnalysis = function(forceRefresh) {
    // Redirect to dashboard
    loadSpiralDashboard();
  };
  
  // Chart instances
  let spiralPlayerChart = null;
  let spiralTeamChart = null;
  
  // Feature flag for clips (can be disabled if issues arise)
  const ENABLE_SPIRAL_CLIPS = true;
  
  // Prevent multiple simultaneous clip fetches
  let _fetchingTeamClips = false;
  let _fetchingPlayerClips = {};
  
  // Scroll lock management for modals - SIMPLIFIED approach
  let _scrollLockCount = 0;
  let _savedScrollY = 0;
  let _originalOverflow = '';
  let _originalPosition = '';
  
  function lockBodyScroll() {
    console.log('[ScrollLock] Lock called, count:', _scrollLockCount);
    if (_scrollLockCount === 0) {
      // First modal opening - use simple overflow hidden
      _savedScrollY = window.scrollY || window.pageYOffset || 0;
      _originalOverflow = document.body.style.overflow;
      _originalPosition = document.body.style.position;
      
      // Simple approach: just hide overflow
      document.body.style.overflow = 'hidden';
      
      console.log('[ScrollLock] Locked at position:', _savedScrollY);
    }
    _scrollLockCount++;
    console.log('[ScrollLock] Count now:', _scrollLockCount);
  }
  
  function unlockBodyScroll() {
    console.log('[ScrollLock] Unlock called, count before:', _scrollLockCount);
    _scrollLockCount = Math.max(0, _scrollLockCount - 1);
    
    if (_scrollLockCount === 0) {
      // Last modal closing - restore everything
      console.log('[ScrollLock] Restoring scroll to:', _savedScrollY);
      
      // Restore overflow
      document.body.style.overflow = _originalOverflow;
      document.body.style.position = _originalPosition;
      
      // Restore scroll position
      window.scrollTo(0, _savedScrollY);
      
      // Reset
      _savedScrollY = 0;
      _originalOverflow = '';
      _originalPosition = '';
      
      console.log('[ScrollLock] Unlocked completely');
    }
    console.log('[ScrollLock] Count now:', _scrollLockCount);
  }
  
  // Emergency reset function
  window.forceUnlockScroll = function() {
    console.log('[ScrollLock] FORCE UNLOCK');
    _scrollLockCount = 0;
    document.body.style.overflow = '';
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.width = '';
    document.body.style.overflowY = '';
    console.log('[ScrollLock] Force unlock complete');
  };
  
  // Expose scroll lock functions globally for use by tmp_script.html
  window.lockBodyScroll = lockBodyScroll;
  window.unlockBodyScroll = unlockBodyScroll;
  
  // SAFETY: Monitor clipModal and force unlock if it gets hidden without calling closeClipModal
  (function() {
    const modal = document.getElementById('clipModal');
    if (!modal) {
      console.warn('[SAFETY] clipModal not found for monitoring');
      return;
    }
    
    let lastDisplayState = modal.style.display;
    
    // Use MutationObserver to watch for style changes
    const observer = new MutationObserver(function(mutations) {
      const currentDisplay = modal.style.display;
      
      // If modal was visible and now is hidden
      if (lastDisplayState !== 'none' && currentDisplay === 'none') {
        console.log('[SAFETY] Modal was hidden, checking if scroll needs unlock...');
        console.log('[SAFETY] Current lock count:', _scrollLockCount);
        
        // If still locked, force unlock
        if (_scrollLockCount > 0) {
          console.warn('[SAFETY] Modal hidden but scroll still locked! Force unlocking...');
          _scrollLockCount = 0;
          document.body.style.overflow = '';
          document.body.style.position = '';
          document.body.style.top = '';
          document.body.style.width = '';
          document.body.style.overflowY = '';
          console.log('[SAFETY] Force unlock complete');
        } else {
          console.log('[SAFETY] Scroll already unlocked, no action needed');
        }
      }
      
      lastDisplayState = currentDisplay;
    });
    
    observer.observe(modal, {
      attributes: true,
      attributeFilter: ['style']
    });
    
    console.log('[SAFETY] Modal monitor installed');
  })();
  
  // Create play button emoji icon for clips
  let cameraIconImage = null;
  function getCameraEmojiIcon() {
    if (cameraIconImage) return cameraIconImage;
    
    const canvas = document.createElement('canvas');
    canvas.width = 16;
    canvas.height = 16;
    const ctx = canvas.getContext('2d');
    
    // Draw smaller play button emoji ▶️
    ctx.font = '12px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('▶️', 8, 8);
    
    cameraIconImage = new Image();
    cameraIconImage.src = canvas.toDataURL();
    return cameraIconImage;
  }
  
  // Show modal to select from multiple clips
  function showClipSelectionModal(clips, date) {
    try {
      // Remove any existing selection modal first
      const existingModal = document.getElementById('spiralClipSelectionModal');
      if (existingModal) {
        existingModal.remove();
        unlockBodyScroll(); // Unlock if previous modal was open
      }
      
      // Lock body scroll when modal opens
      lockBodyScroll();
      
      // Create modal overlay
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:40001; display:flex; align-items:center; justify-content:center;';
      modal.id = 'spiralClipSelectionModal';
      
      const card = document.createElement('div');
      card.style.cssText = 'background:#14181f; border:1px solid #2a3448; border-radius:12px; padding:24px; max-width:500px; width:90%; max-height:80vh; overflow-y:auto; position:relative;';
      
      let html = '<h3 style="margin:0 0 16px 0; color:#e9edf6;">Clips for ' + escapeHtml(date) + '</h3>';
      html += '<div style="display:flex; flex-direction:column; gap:8px;">';
      
      clips.forEach((clip, idx) => {
        const clipUrl = escapeHtml(clip.url || '');
        const player = escapeHtml(clip.player || '');
        const theme = escapeHtml(clip.theme || 'Clip ' + (idx + 1));
        const type = escapeHtml(clip.type || '');
        const notes = escapeHtml((clip.notes || '').substring(0, 100));
        
        html += '<div class="spiral-clip-item" data-clip-url="' + clipUrl + '" style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px; cursor:pointer; border:1px solid rgba(74,168,255,0.3); transition:background 0.2s;" ';
        html += 'onmouseover="this.style.background=\'rgba(74,168,255,0.2)\'" ';
        html += 'onmouseout="this.style.background=\'rgba(74,168,255,0.1)\'">';
        
        // Show player name prominently for team charts
        if (player) {
          html += '<div style="font-size:11px; color:#4aa8ff; margin-bottom:4px; font-weight:500;">👤 ' + player + '</div>';
        }
        
        html += '<div style="font-weight:600; color:#e9edf6; margin-bottom:4px;">' + theme + '</div>';
        if (type) html += '<div style="font-size:12px; color:#9aa5be;">Type: ' + type + '</div>';
        if (notes) html += '<div style="font-size:12px; color:#9aa5be; margin-top:4px;">' + notes + (clip.notes && clip.notes.length > 100 ? '...' : '') + '</div>';
        html += '</div>';
      });
      
      html += '</div>';
      html += '<button class="spiral-clip-close" style="margin-top:16px; padding:8px 16px; background:#ff5a5f; border:0; color:white; border-radius:6px; cursor:pointer; width:100%;">Close</button>';
      
      card.innerHTML = html;
      modal.appendChild(card);
      
      // Helper to close modal and unlock scroll
      function closeSelectionModal() {
        modal.remove();
        unlockBodyScroll();
      }
      
      // Use event delegation instead of inline handlers (better performance)
      card.addEventListener('click', function(e) {
        const clipItem = e.target.closest('.spiral-clip-item');
        if (clipItem) {
          const url = clipItem.getAttribute('data-clip-url');
          if (url && typeof window.openClipModal === 'function') {
            closeSelectionModal();
            // Use requestAnimationFrame to defer modal open and prevent blocking
            requestAnimationFrame(function() {
              window.openClipModal(url);
            });
          }
          return;
        }
        
        if (e.target.classList.contains('spiral-clip-close')) {
          closeSelectionModal();
        }
      });
      
      document.body.appendChild(modal);
      
      // Close on outside click
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          closeSelectionModal();
        }
      });
      
      // Close on ESC key
      function handleEscape(e) {
        if (e.key === 'Escape') {
          closeSelectionModal();
          document.removeEventListener('keydown', handleEscape);
        }
      }
      document.addEventListener('keydown', handleEscape);
      
    } catch (e) {
      console.error('Error showing clip selection modal:', e);
      unlockBodyScroll(); // Make sure to unlock on error
    }
  }
  
  // Add clip markers to chart
  function addClipMarkersToChart(chart, sessions, clipsByDate) {
    try {
      console.log('[Spiral Clips] addClipMarkersToChart called', {
        enabled: ENABLE_SPIRAL_CLIPS,
        hasClips: !!clipsByDate,
        clipKeys: clipsByDate ? Object.keys(clipsByDate) : [],
        hasChart: !!chart,
        hasData: chart && chart.data ? true : false
      });
      
      if (!ENABLE_SPIRAL_CLIPS) {
        console.log('[Spiral Clips] Clips disabled');
        return;
      }
      if (!clipsByDate || Object.keys(clipsByDate).length === 0) {
        console.log('[Spiral Clips] No clips data');
        return;
      }
      if (!chart || !chart.data || !chart.data.datasets) {
        console.log('[Spiral Clips] Chart not ready');
        return;
      }
      
      const clipData = new Array(sessions.length).fill(null);
      const clipInfo = new Array(sessions.length).fill(null);
      let clipsFound = 0;
      
      // Find the chart's y-axis range to position clips at top
      const allValues = sessions.map(s => s.value).filter(v => v != null);
      const maxValue = allValues.length > 0 ? Math.max(...allValues) : 5;
      const minValue = allValues.length > 0 ? Math.min(...allValues) : 1;
      const range = maxValue - minValue;
      
      // Position clips near the top but with some padding (8% above max value)
      // This keeps them visible without being cut off
      const clipYPosition = maxValue + (range * 0.08);
      
      sessions.forEach((session, idx) => {
        const dateISO = session.date;
        if (clipsByDate[dateISO] && clipsByDate[dateISO].length > 0) {
          // Position icon at TOP of chart (fixed Y position)
          clipData[idx] = clipYPosition;
          clipInfo[idx] = {
            clips: clipsByDate[dateISO],
            count: clipsByDate[dateISO].length,
            date: dateISO
          };
          clipsFound++;
        }
      });
      
      console.log('[Spiral Clips] Found clips for', clipsFound, 'sessions out of', sessions.length);
      
      if (clipsFound === 0) {
        console.log('[Spiral Clips] No matching clips found. Session dates:', sessions.map(s => s.date).slice(0, 5), 'Clip dates:', Object.keys(clipsByDate));
        return;
      }
      
      console.log('[Spiral Clips] Adding clip dataset to chart with', clipsFound, 'markers');
      
      // REMOVED: Chart.js plugin that was causing freezing
      // The plugin was running on every animation frame, blocking the UI
      // Using simple visible markers instead
      
      // Create separate datasets for single and multiple clips
      const singleClipData = new Array(sessions.length).fill(null);
      const multipleClipData = new Array(sessions.length).fill(null);
      const singleClipInfo = new Array(sessions.length).fill(null);
      const multipleClipInfo = new Array(sessions.length).fill(null);
      
      clipInfo.forEach((info, idx) => {
        if (info) {
          if (info.count === 1) {
            singleClipData[idx] = clipData[idx];
            singleClipInfo[idx] = info;
          } else {
            multipleClipData[idx] = clipData[idx];
            multipleClipInfo[idx] = info;
          }
        }
      });
      
      // Get play button emoji icon
      const cameraIcon = getCameraEmojiIcon();
      
      // Add single clip markers with small play button ▶️ (at top of chart)
      if (singleClipData.some(v => v !== null)) {
        chart.data.datasets.push({
          label: 'Clips',
          data: singleClipData,
          pointRadius: 6,
          pointHoverRadius: 8,
          backgroundColor: 'transparent',
          borderWidth: 0,
          showLine: false,
          pointHitRadius: 25,
          clipInfo: singleClipInfo,
          order: -10,
          pointStyle: cameraIcon
        });
      }
      
      // Add multiple clip markers (slightly larger play button)
      if (multipleClipData.some(v => v !== null)) {
        chart.data.datasets.push({
          label: 'Clips (Multiple)',
          data: multipleClipData,
          pointRadius: 7,
          pointHoverRadius: 9,
          backgroundColor: 'transparent',
          borderWidth: 0,
          showLine: false,
          pointHitRadius: 25,
          clipInfo: multipleClipInfo,
          order: -10,
          pointStyle: cameraIcon
        });
      }
      
      // Add custom tooltip callback for clip datasets to show helpful info
      // Only modify if not already modified
      if (!chart._clipTooltipModified) {
        const originalTooltipCallbacks = chart.options.plugins?.tooltip?.callbacks || {};
        if (!chart.options.plugins) chart.options.plugins = {};
        if (!chart.options.plugins.tooltip) chart.options.plugins.tooltip = {};
        if (!chart.options.plugins.tooltip.callbacks) chart.options.plugins.tooltip.callbacks = {};
        
        const originalLabel = chart.options.plugins.tooltip.callbacks.label;
        chart.options.plugins.tooltip.callbacks.label = function(context) {
          try {
            const dataset = context.dataset;
            // Only customize tooltip for clip datasets
            if (dataset && dataset.clipInfo && dataset.clipInfo[context.dataIndex]) {
              const info = dataset.clipInfo[context.dataIndex];
              const clipCount = info.count || 0;
              const clipText = clipCount === 1 ? '1 clip' : clipCount + ' clips';
              
              // Show player names if available (for team charts)
              if (info.clips && Array.isArray(info.clips)) {
                const playerNames = info.clips
                  .map(c => c.player)
                  .filter(p => p)
                  .filter((p, i, arr) => arr.indexOf(p) === i); // unique
                
                if (playerNames.length > 0 && playerNames.length <= 3) {
                  return '🎬 ' + clipText + ' (' + playerNames.join(', ') + ')';
                } else if (playerNames.length > 3) {
                  return '🎬 ' + clipText + ' (' + playerNames.length + ' players)';
                }
              }
              
              return '🎬 ' + clipText + ' - Click to view';
            }
            // For non-clip datasets, use original callback
            return originalLabel ? originalLabel.call(this, context) : context.dataset.label;
          } catch (e) {
            console.warn('Tooltip callback error:', e);
            return context.dataset.label;
          }
        };
        
        chart._clipTooltipModified = true;
      }
      
      // Add click handler if not already added
      if (!chart._clipClickHandler) {
        chart._clipClickHandler = function(evt) {
          const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
          if (points.length) {
            const firstPoint = points[0];
            const datasetIndex = firstPoint.datasetIndex;
            const dataIndex = firstPoint.index;
            
            const dataset = chart.data.datasets[datasetIndex];
            if (dataset.clipInfo) {
              const info = dataset.clipInfo[dataIndex];
              if (info && info.clips && info.clips.length > 0) {
                if (info.count === 1) {
                  // Single clip - open directly
                  if (info.clips[0].url && typeof window.openClipModal === 'function') {
                    window.openClipModal(info.clips[0].url);
                  }
                } else {
                  // Multiple clips - show selection modal
                  showClipSelectionModal(info.clips, info.date);
                }
              }
            }
          }
        };
        chart.canvas.onclick = chart._clipClickHandler;
      }
      
      console.log('[Spiral Clips] Updating chart with clip markers. Total datasets:', chart.data.datasets.length);
      // Use setTimeout to defer update and prevent blocking - no animation
      setTimeout(function() {
        try {
          chart.update('none'); // 'none' mode prevents animation blocking
          console.log('[Spiral Clips] Chart updated successfully');
        } catch (e) {
          console.error('[Spiral Clips] Error updating chart:', e);
        }
      }, 0);
    } catch (e) {
      console.error('[Spiral Clips] Error adding clip markers:', e);
      // Don't break chart if clip markers fail
    }
  }
  
  // Add competition initials to predicted dots
  function addCompetitionLogosToChart(chart, teamAnalysis, dateToCompetition) {
    try {
      if (!chart || !chart.data || !teamAnalysis || !teamAnalysis.trajectory || !teamAnalysis.trajectory.projected) {
        console.log('[Competition Initials] Chart or trajectory data not available');
        return;
      }
      
      if (!dateToCompetition || Object.keys(dateToCompetition).length === 0) {
        console.log('[Competition Initials] No competition data available');
        return;
      }
      
      const sessions = teamAnalysis.sessions || [];
      const projectionToUse = teamAnalysis.trajectory.extendedProjection || teamAnalysis.trajectory.projected;
      if (!projectionToUse || projectionToUse.length === 0) {
        console.log('[Competition Initials] No projected data');
        return;
      }
      
      // Create mapping of predicted dates to competition initials
      const competitionPositions = [];
      
      // Calculate predicted dates (assuming weekly sessions)
      const lastSessionDate = new Date(sessions[sessions.length - 1].date);
      
      projectionToUse.forEach((proj, idx) => {
        const predictedDate = new Date(lastSessionDate);
        predictedDate.setDate(predictedDate.getDate() + ((idx + 1) * 7)); // Weekly sessions
        
        // Normalize date to YYYY-MM-DD format for matching
        const dateISO = predictedDate.getFullYear() + '-' + 
                       String(predictedDate.getMonth() + 1).padStart(2, '0') + '-' + 
                       String(predictedDate.getDate()).padStart(2, '0');
        
        // Check if this date has a competition
        const competitionData = dateToCompetition[dateISO];
        if (competitionData) {
          const competition = competitionData.competition || competitionData; // Support both old format (string) and new format (object)
          const opponent = competitionData.opponent || '';
          
          // Determine initials based on competition name
          // Check FIBA Europe Cup first (more specific), then Greek League
          const compLower = String(competition).toLowerCase();
          let initials = '';
          console.log('[Competition Initials] Checking competition:', competition, 'lowercase:', compLower);
          if (compLower.includes('fiba europe cup')) {
            initials = 'EC';
            console.log('[Competition Initials] Matched FIBA Europe Cup -> EC');
          } else if (compLower.includes('fiba') && !compLower.includes('heba')) {
            initials = 'EC';
            console.log('[Competition Initials] Matched FIBA (not HEBA) -> EC');
          } else if (compLower.includes('greek heba a1') || compLower.includes('heba a1') || compLower.includes('heba')) {
            initials = 'GBL';
            console.log('[Competition Initials] Matched HEBA -> GBL');
          } else {
            console.log('[Competition Initials] No match for competition:', competition);
          }
          
          if (initials) {
            const dataIndex = sessions.length + idx; // Index in extended labels array
            competitionPositions.push({
              dataIndex: dataIndex,
              value: proj.value,
              date: dateISO,
              initials: initials,
              competition: competition,
              opponent: opponent
            });
          }
        }
      });
      
      if (competitionPositions.length === 0) {
        console.log('[Competition Initials] No matching dates found between predictions and schedule');
        return;
      }
      
      console.log('[Competition Initials] Found', competitionPositions.length, 'matching dates for initials');
      console.log('[Competition Initials] Positions:', competitionPositions.map(p => ({ date: p.date, initials: p.initials, competition: p.competition })));
      
      // Store competition data on chart for tooltip access (no drawing needed)
      chart._competitionData = {
        positions: competitionPositions
      };
      
      console.log('[Competition Initials] Stored', competitionPositions.length, 'competition positions for tooltip');
      
    } catch (e) {
      console.error('[Competition Initials] Error adding initials:', e);
      // Don't break chart if initials fail
    }
  }
  
  
  function renderSpiralAnalysis(data) {
    renderSpiralPlayerChart(data);
    renderCurrentStatus(data);
    renderSpiralMetrics(data);
    renderCycles(data);
    renderBaselines(data);
  }
  
  function renderSpiralPlayerChart(data) {
    const canvas = document.getElementById('spiralPlayerChart');
    if (!canvas || typeof Chart === 'undefined') return;
    
    // Destroy existing chart
    if (spiralPlayerChart) {
      try { spiralPlayerChart.destroy(); } catch(e) {}
      spiralPlayerChart = null;
    }
    
    if (!data || !data.sessions || data.sessions.length === 0) return;
    
    const ctx = canvas.getContext('2d');
    const sessions = data.sessions;
    const baselines = data.baselines || [];
    const dips = data.dips || [];
    const volatilityPeriods = data.volatilityPeriods || [];
    const recoveries = data.recoveries || [];
    
    // Create labels (dates)
    const labels = sessions.map((s, idx) => {
      const date = new Date(s.date);
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    });
    
    // Main rating line
    const ratingData = sessions.map(s => s.value);
    
    // Create datasets
    const datasets = [{
      label: 'Rating',
      data: ratingData,
      borderColor: '#4aa8ff',
      backgroundColor: 'rgba(74,168,255,0.1)',
      tension: 0.4,
      fill: false,
      pointRadius: 2, // Smaller dots so recovery stars stand out
      pointHoverRadius: 4
    }];
    
    // Add baseline lines
    baselines.forEach((baseline) => {
      const baselineData = new Array(sessions.length).fill(null);
      for (let i = baseline.startIndex; i <= baseline.endIndex && i < sessions.length; i++) {
        baselineData[i] = baseline.value;
      }
      datasets.push({
        label: `Baseline ${baseline.baselineNumber}`,
        data: baselineData,
        borderColor: '#79839a',
        borderDash: [5, 5],
        borderWidth: 2,
        pointRadius: 0,
        fill: false
      });
    });
    
    // Add dip markers
    dips.forEach((dip) => {
      const dipData = new Array(sessions.length).fill(null);
      for (let i = dip.startIndex; i <= dip.endIndex && i < sessions.length; i++) {
        dipData[i] = sessions[i].value;
      }
      // Color logic: productive or unknown = yellow, dangerous = red
      const isProductive = dip.type === 'productive' || dip.type === 'unknown';
      datasets.push({
        label: `Dip ${dip.dipNumber} (${dip.type === 'unknown' ? 'learning' : dip.type})`,
        data: dipData,
        borderColor: isProductive ? '#ffb020' : '#ff5a5f',
        backgroundColor: isProductive ? 'rgba(255,176,32,0.3)' : 'rgba(255,90,95,0.3)',
        borderWidth: 3,
        pointRadius: 4,
        pointHoverRadius: 6,
        fill: true,
        tension: 0.4,
        dipInfo: dip // Store dip info for tooltip keyword display
      });
    });
    
    // Add volatility periods (inconsistent performance) with orange striped shading
    volatilityPeriods.forEach((volatility) => {
      const volatilityData = new Array(sessions.length).fill(null);
      // Fill with mean value to create a horizontal line at average
      for (let i = volatility.startIndex; i <= volatility.endIndex && i < sessions.length; i++) {
        volatilityData[i] = volatility.mean;
      }
      // Cyan/teal color for volatility periods (distinct from yellow/red dips)
      datasets.push({
        label: `Inconsistent Performance ${volatility.periodNumber}`,
        data: volatilityData,
        borderColor: '#00d4ff', // Bright cyan
        backgroundColor: 'rgba(0, 212, 255, 0.2)', // Light cyan with transparency
        borderWidth: 2,
        borderDash: [8, 4], // Dashed line pattern
        pointRadius: 0,
        fill: true,
        tension: 0,
        order: -3, // Draw behind dips but above baselines
        volatilityInfo: volatility // Store volatility info for tooltip
      });
    });
    
    // Add recovery markers (make them very visible)
    recoveries.forEach((recovery) => {
      const recoveryData = new Array(sessions.length).fill(null);
      if (recovery.recoveryIndex < sessions.length) {
        recoveryData[recovery.recoveryIndex] = recovery.recoveryValue;
      }
      datasets.push({
        label: recovery.exceedsBaseline ? 'Recovery (Line 4)' : 'Recovery (Line 3)',
        data: recoveryData,
        borderColor: recovery.exceedsBaseline ? '#2ecc71' : '#ff5a5f',
        backgroundColor: recovery.exceedsBaseline ? '#2ecc71' : '#ff5a5f',
        pointRadius: 12,
        pointHoverRadius: 14,
        pointStyle: 'triangle', // Triangle shape to stand out
        borderWidth: 4,
        showLine: false,
        order: -1 // Draw on top of other elements
      });
    });
    
    // Add projected trajectory line with cycle predictions if available
    if (data.trajectory) {
      try {
        // Use extendedProjection if available (includes cycle predictions), otherwise use basic projected
        const projectionToUse = data.trajectory.extendedProjection || data.trajectory.projected || [];
        const cyclePrediction = data.trajectory.cyclePrediction || null;
        
        if (projectionToUse && projectionToUse.length > 0) {
        const projectedData = new Array(sessions.length + projectionToUse.length).fill(null);
        // Set last actual value as starting point
        projectedData[sessions.length - 1] = sessions[sessions.length - 1].value;
        
        // Extend labels for projected points FIRST (before using extendedLabels)
        const extendedLabels = [...labels];
        const totalProjectedSessions = projectionToUse.length;
        for (let i = 1; i <= totalProjectedSessions; i++) {
          const lastDate = new Date(sessions[sessions.length - 1].date);
          const nextDate = new Date(lastDate);
          nextDate.setDate(nextDate.getDate() + (i * 7)); // Assume weekly sessions
          extendedLabels.push(nextDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
        }
        
        // Add projected values using array position (sequential)
        projectionToUse.forEach(function(proj, idx) {
          const dataIdx = sessions.length + idx;
          if (dataIdx < projectedData.length) {
            projectedData[dataIdx] = proj.value;
          }
        });
        
        // Add purple shaded area for predicted dip period (if available)
        if (cyclePrediction && cyclePrediction.dip) {
          try {
            const dip = cyclePrediction.dip;
            const dipShadeData = new Array(extendedLabels.length).fill(null);
            
            // Find the array positions for dip start and end
            // dip.startSession and dip.endSession are absolute session numbers
            // We need to find their positions in the extended projection array
            const dipStartIdx = dip.startSession >= sessions.length 
              ? sessions.length + (dip.startSession - sessions.length)
              : dip.startSession;
            const dipEndIdx = dip.endSession >= sessions.length
              ? sessions.length + (dip.endSession - sessions.length)
              : dip.endSession;
            
            // Fill the dip period with the trajectory values
            for (let i = Math.max(0, dipStartIdx); i <= Math.min(dipEndIdx, extendedLabels.length - 1); i++) {
              if (projectedData[i] != null) {
                dipShadeData[i] = projectedData[i];
              } else if (i < sessions.length) {
                dipShadeData[i] = sessions[i].value;
              }
            }
            
            // Add shaded area dataset (draws behind the line)
            datasets.push({
              label: 'Predicted Dip Area',
              data: dipShadeData,
              borderColor: 'transparent',
              backgroundColor: 'rgba(155, 89, 182, 0.2)', // Purple with transparency
              pointRadius: 0,
              fill: 'origin', // Fill to zero/axis
              tension: 0.4,
              order: 1 // Behind the trajectory line
            });
          } catch (e) {
            console.error('Error adding predicted dip area:', e);
          }
        }
        
        // Add main projected trajectory line
        datasets.push({
          label: 'Projected Trajectory',
          data: projectedData,
          borderColor: '#9b59b6', // Purple color for projection
          backgroundColor: 'transparent',
          borderWidth: 2,
          borderDash: [5, 5], // Dashed line
          pointRadius: function(context) {
            // Make predicted dip, recovery, and peak points larger
            const idx = context.dataIndex;
            if (idx >= sessions.length) {
              const projIdx = idx - sessions.length;
              const proj = projectionToUse[projIdx];
              if (proj && (proj.isDip || proj.isRecovery || proj.isPeak)) {
                return 6;
              }
            }
            return 3;
          },
          pointHoverRadius: 7,
          fill: false,
          tension: 0.4,
          order: 0 // Draw after main line but before recovery markers
        });
        
        // Add visual markers for predicted dip, recovery, and peak
        if (cyclePrediction) {
          // Predicted dip marker (show at lowest point)
          if (cyclePrediction.dip) {
            try {
              const dip = cyclePrediction.dip;
              if (dip && dip.startSession != null && dip.endSession != null) {
                const dipData = new Array(extendedLabels.length).fill(null);
                // Find the lowest point in the dip (middle of dip duration)
                const dipMiddleSession = Math.floor((dip.startSession + dip.endSession) / 2);
                
                // Find the position in the extended projection array by matching index
                let dipMiddleIdx = null;
                for (let i = 0; i < projectionToUse.length; i++) {
                  if (projectionToUse[i].index === dipMiddleSession) {
                    dipMiddleIdx = sessions.length + i;
                    break;
                  }
                }
                
                // If not found, try approximate position (but only if within reasonable range)
                if (dipMiddleIdx === null && dipMiddleSession >= sessions.length) {
                  const relativeIdx = dipMiddleSession - sessions.length;
                  if (relativeIdx >= 0 && relativeIdx < projectionToUse.length) {
                    dipMiddleIdx = sessions.length + relativeIdx;
                  }
                }
                
                // Only add marker if we found a valid position within bounds
                if (dipMiddleIdx !== null && dipMiddleIdx >= 0 && dipMiddleIdx < extendedLabels.length) {
                  dipData[dipMiddleIdx] = dip.lowestValue || dip.startValue;
                  datasets.push({
                    label: 'Predicted Dip (Lowest Point)',
                    data: dipData,
                    borderColor: '#ffb020',
                    backgroundColor: '#ffb020',
                    pointRadius: 8,
                    pointHoverRadius: 10,
                    pointStyle: 'circle',
                    borderWidth: 3,
                    showLine: false,
                    order: -1
                  });
                }
              }
            } catch (e) {
              console.error('Error adding predicted dip marker:', e);
            }
          }
          
          // Predicted recovery marker
          if (cyclePrediction.recovery) {
            try {
              const recovery = cyclePrediction.recovery;
              if (recovery && recovery.session != null && recovery.value != null) {
                const recoveryData = new Array(extendedLabels.length).fill(null);
                // recovery.session is already an absolute session number (0-based)
                // Convert to array position - but only if it's within the projected range
                // Find the position in the extended projection array
                let recoveryIdx = null;
                for (let i = 0; i < projectionToUse.length; i++) {
                  if (projectionToUse[i].index === recovery.session) {
                    recoveryIdx = sessions.length + i;
                    break;
                  }
                }
                
                // If not found in projection, try direct conversion (but limit to reasonable range)
                if (recoveryIdx === null && recovery.session >= sessions.length) {
                  const relativeIdx = recovery.session - sessions.length;
                  if (relativeIdx >= 0 && relativeIdx < projectionToUse.length) {
                    recoveryIdx = sessions.length + relativeIdx;
                  }
                }
                
                // Only add marker if we found a valid position within bounds
                if (recoveryIdx !== null && recoveryIdx >= 0 && recoveryIdx < extendedLabels.length) {
                  recoveryData[recoveryIdx] = recovery.value;
                  // Use same colors as actual recoveries: green for Line 4, red for Line 3
                  const recoveryColor = recovery.exceedsBaseline ? '#2ecc71' : '#ff5a5f';
                  datasets.push({
                    label: 'Predicted Recovery (' + recovery.type + ')',
                    data: recoveryData,
                    borderColor: recoveryColor,
                    backgroundColor: recoveryColor,
                    pointRadius: 12,
                    pointHoverRadius: 14,
                    pointStyle: 'triangle', // Triangle shape like actual recoveries
                    borderWidth: 4,
                    showLine: false,
                    order: -1 // Draw on top of other elements
                  });
                }
              }
            } catch (e) {
              console.error('Error adding predicted recovery marker:', e);
            }
          }
          
          // Predicted peak marker
          if (cyclePrediction.peak) {
            try {
              const peak = cyclePrediction.peak;
              if (peak && peak.session != null && peak.value != null) {
                const peakData = new Array(extendedLabels.length).fill(null);
                // peak.session is already an absolute session number (0-based)
                // Find the position in the extended projection array
                let peakIdx = null;
                for (let i = 0; i < projectionToUse.length; i++) {
                  if (projectionToUse[i].index === peak.session) {
                    peakIdx = sessions.length + i;
                    break;
                  }
                }
                
                // If not found in projection, try direct conversion (but limit to reasonable range)
                if (peakIdx === null && peak.session >= sessions.length) {
                  const relativeIdx = peak.session - sessions.length;
                  if (relativeIdx >= 0 && relativeIdx < projectionToUse.length) {
                    peakIdx = sessions.length + relativeIdx;
                  }
                }
                
                if (peakIdx !== null && peakIdx >= 0 && peakIdx < extendedLabels.length) {
                  peakData[peakIdx] = peak.value;
                  datasets.push({
                    label: 'Predicted Peak',
                    data: peakData,
                    borderColor: '#2ecc71',
                    backgroundColor: '#2ecc71',
                    pointRadius: 12,
                    pointHoverRadius: 14,
                    pointStyle: 'star',
                    borderWidth: 3,
                    showLine: false,
                    order: -2 // Draw on top
                  });
                }
              }
            } catch (e) {
              console.error('Error adding predicted peak marker:', e);
            }
          }
        }
        
        // Update labels to include projected dates
        labels.length = 0;
        labels.push(...extendedLabels);
        }
      } catch (e) {
        console.error('Error rendering trajectory predictions:', e);
        // Continue without predictions if there's an error
      }
    }
    
    spiralPlayerChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false, // Disable animations to prevent freezing
        transitions: {
          active: {
            animation: {
              duration: 0
            }
          }
        },
        interaction: {
          mode: 'index',
          intersect: false
        },
        plugins: {
          legend: { 
            display: false // Remove legend - description text explains everything
          },
          tooltip: {
            callbacks: {
              title: function(context) {
                const idx = context[0].dataIndex;
                return sessions[idx] ? sessions[idx].session + ' - ' + labels[idx] : labels[idx];
              },
              label: function(context) {
                const value = context.parsed.y;
                if (value === null) return null;
                return context.dataset.label + ': ' + value.toFixed(2);
              },
              afterBody: function(context) {
                const lines = [];
                const idx = context[0].dataIndex;
                
                // Find which dip this point belongs to
                const dips = data.dips || [];
                const matchingDip = dips.find(d => idx >= d.startIndex && idx <= d.endIndex);
                
                if (matchingDip) {
                  if (matchingDip.type === 'productive' && matchingDip.matchedLearningKeywords && matchingDip.matchedLearningKeywords.length > 0) {
                    lines.push('✓ Learning keywords: ' + matchingDip.matchedLearningKeywords.join(', '));
                  }
                  if (matchingDip.type === 'dangerous' && matchingDip.matchedConcernKeywords && matchingDip.matchedConcernKeywords.length > 0) {
                    lines.push('⚠ Concern keywords: ' + matchingDip.matchedConcernKeywords.join(', '));
                  }
                }
                
                // Find which volatility period this point belongs to
                const volatilityPeriods = data.volatilityPeriods || [];
                const matchingVolatility = volatilityPeriods.find(v => idx >= v.startIndex && idx <= v.endIndex);
                
                if (matchingVolatility) {
                  lines.push('');
                  lines.push('⚠️ Inconsistent Performance');
                  lines.push('Std Dev: ' + matchingVolatility.stdDev.toFixed(2));
                  lines.push('Range: ' + matchingVolatility.minValue.toFixed(2) + ' - ' + matchingVolatility.maxValue.toFixed(2));
                  lines.push('Avg: ' + matchingVolatility.mean.toFixed(2));
                  if (matchingVolatility.isAlternating) {
                    lines.push('Pattern: Alternating highs/lows');
                  }
                  if (matchingVolatility.type === 'volatile-learning' && matchingVolatility.matchedLearningKeywords && matchingVolatility.matchedLearningKeywords.length > 0) {
                    lines.push('✓ Learning keywords: ' + matchingVolatility.matchedLearningKeywords.join(', '));
                  }
                  if (matchingVolatility.type === 'volatile-concern' && matchingVolatility.matchedConcernKeywords && matchingVolatility.matchedConcernKeywords.length > 0) {
                    lines.push('⚠ Concern keywords: ' + matchingVolatility.matchedConcernKeywords.join(', '));
                  }
                }
                
                return lines.length > 0 ? lines : null;
              }
            }
          }
        },
        scales: {
            y: {
              beginAtZero: false,
              min: 1,
              max: 5.4, // Extended to accommodate clip icons at top
              ticks: { 
                color: '#9aa5be',
                stepSize: 0.5
              },
              grid: { color: 'rgba(255,255,255,0.1)' }
            },
            x: {
              ticks: { 
                color: '#9aa5be',
                maxRotation: 45,
                minRotation: 0
              },
              grid: { color: 'rgba(255,255,255,0.05)' }
            }
          }
        }
      });
      
      // Fetch clips asynchronously AFTER chart is created (lazy load)
      if (ENABLE_SPIRAL_CLIPS && data.playerName && sessions.length > 0) {
        const playerKey = data.playerName;
        
        // Prevent duplicate fetches for same player
        if (_fetchingPlayerClips[playerKey]) {
          console.log('[Spiral Clips] Already fetching clips for', playerKey);
          return;
        }
        
        const sessionDates = sessions.map(s => s.date);
        console.log('[Spiral Clips] Fetching clips for', data.playerName, 'dates:', sessionDates.length);
        _fetchingPlayerClips[playerKey] = true;
        
        google.script.run
          .withSuccessHandler(function(clipsByDate) {
            _fetchingPlayerClips[playerKey] = false;
            console.log('[Spiral Clips] Received clips:', clipsByDate, 'Keys:', Object.keys(clipsByDate || {}));
            if (clipsByDate && Object.keys(clipsByDate).length > 0 && spiralPlayerChart) {
              console.log('[Spiral Clips] Adding markers to chart');
              addClipMarkersToChart(spiralPlayerChart, sessions, clipsByDate);
            } else {
              console.log('[Spiral Clips] No clips to add. clipsByDate:', clipsByDate, 'chart exists:', !!spiralPlayerChart);
            }
          })
          .withFailureHandler(function(err) {
            _fetchingPlayerClips[playerKey] = false;
            console.log('[Spiral Clips] Error fetching clips for ' + data.playerName + ':', err);
            // Silently fail - clips are optional
          })
          .getSpiralClipsForSessions(data.playerName, sessionDates);
      }
    }
  
  function renderCurrentStatus(data) {
    const el = document.getElementById('spiralCurrentStatus');
    if (!el) return;
    
    const phase = data.currentPhase || {};
    const lineColors = {
      'Line1': '#79839a',
      'Line2': '#ffb020',
      'Line3': '#ff5a5f',
      'Line4': '#2ecc71'
    };
    
    const lineLabels = {
      'Line1': 'Flat (No Improvement)',
      'Line2': 'Dip (Learning)',
      'Line3': 'Return to Baseline',
      'Line4': 'Spiral Development'
    };
    
    const lineColor = lineColors[phase.line] || '#79839a';
    const lineLabel = lineLabels[phase.line] || phase.line || 'Unknown';
    
    let html = '<div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:16px;">';
    html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px; border-left:3px solid ' + lineColor + ';">';
    html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Current Phase</div>';
    html += '<div style="font-size:16px; font-weight:600; color:#e9edf6;">' + (phase.phase || 'Unknown') + '</div>';
    html += '</div>';
    html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px; border-left:3px solid ' + lineColor + ';">';
    html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Pattern</div>';
    html += '<div style="font-size:16px; font-weight:600; color:' + lineColor + ';">' + lineLabel + '</div>';
    html += '</div>';
    if (phase.currentRating != null) {
      html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px;">';
      html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Current Rating</div>';
      html += '<div style="font-size:16px; font-weight:600; color:#e9edf6;">' + phase.currentRating.toFixed(2) + '</div>';
      html += '</div>';
    }
    html += '</div>';
    if (phase.message) {
      html += '<div style="margin-top:12px; padding:10px; background:rgba(74,168,255,0.08); border-radius:6px; font-size:12px; color:#cfe3ff;">' + escapeHtml(phase.message) + '</div>';
    }
    
    el.innerHTML = html;
  }
  
  function renderSpiralMetrics(data) {
    const el = document.getElementById('spiralMetrics');
    if (!el) return;
    
    const metrics = data.spiralAnalysis || {};
    
    let html = '<div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(180px, 1fr)); gap:16px;">';
    
    if (metrics.spiralScore != null) {
      const scoreColor = metrics.isSpiraling ? '#2ecc71' : '#79839a';
      html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px;">';
      html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Spiral Score</div>';
      html += '<div style="font-size:24px; font-weight:700; color:' + scoreColor + ';">' + metrics.spiralScore + '</div>';
      html += '<div style="font-size:10px; color:#9aa5be; margin-top:2px;">' + (metrics.isSpiraling ? 'Spiraling ✓' : 'Not spiraling') + '</div>';
      html += '</div>';
    }
    
    if (metrics.cyclesCompleted != null) {
      html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px;">';
      html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Cycles Completed</div>';
      html += '<div style="font-size:24px; font-weight:700; color:#e9edf6;">' + metrics.cyclesCompleted + '</div>';
      html += '</div>';
    }
    
    if (metrics.line4Cycles != null) {
      html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px;">';
      html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Line 4 Cycles</div>';
      html += '<div style="font-size:24px; font-weight:700; color:#2ecc71;">' + metrics.line4Cycles + '</div>';
      html += '<div style="font-size:10px; color:#9aa5be; margin-top:2px;">' + (metrics.line4Percentage || 0) + '% of cycles</div>';
      html += '</div>';
    }
    
    if (metrics.nextBaselineTarget) {
      html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px;">';
      html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Next Baseline Target</div>';
      html += '<div style="font-size:24px; font-weight:700; color:#4aa8ff;">' + metrics.nextBaselineTarget + '</div>';
      html += '</div>';
    }
    
    html += '</div>';
    
    if (metrics.message) {
      html += '<div style="margin-top:12px; padding:10px; background:rgba(74,168,255,0.08); border-radius:6px; font-size:12px; color:#cfe3ff;">' + escapeHtml(metrics.message) + '</div>';
    }
    
    el.innerHTML = html;
  }
  
  function renderCycles(data) {
    const el = document.getElementById('spiralCycles');
    if (!el) return;
    
    const cycles = data.cycles || [];
    if (cycles.length === 0) {
      el.innerHTML = '<div class="muted">No cycles detected yet. Need more data.</div>';
      return;
    }
    
    let html = '<div style="display:flex; flex-direction:column; gap:12px;">';
    
    cycles.forEach(function(cycle, idx) {
      const lineColors = {
        'Line1': '#79839a',
        'Line2': '#ffb020',
        'Line3': '#ff5a5f',
        'Line4': '#2ecc71'
      };
      const lineColor = lineColors[cycle.type] || '#79839a';
      
      html += '<div style="padding:12px; background:rgba(74,168,255,0.08); border-radius:8px; border-left:3px solid ' + lineColor + ';">';
      html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">';
      html += '<div style="font-weight:600; color:#e9edf6;">Cycle ' + cycle.cycleNumber + '</div>';
      html += '<div style="padding:4px 10px; background:' + lineColor + '; color:#0b0d10; border-radius:12px; font-size:11px; font-weight:600;">' + (cycle.type || 'Unknown') + '</div>';
      html += '</div>';
      if (cycle.summary) {
        html += '<div style="font-size:12px; color:#cfe3ff; line-height:1.5;">' + escapeHtml(cycle.summary) + '</div>';
      }
      if (cycle.improvement != null) {
        const impColor = cycle.improvement > 0 ? '#2ecc71' : (cycle.improvement < 0 ? '#ff5a5f' : '#79839a');
        html += '<div style="margin-top:8px; font-size:11px; color:' + impColor + ';">Improvement: ' + (cycle.improvement > 0 ? '+' : '') + cycle.improvement.toFixed(2) + '</div>';
      }
      html += '</div>';
    });
    
    html += '</div>';
    el.innerHTML = html;
  }
  
  function renderBaselines(data) {
    const el = document.getElementById('spiralBaselines');
    if (!el) return;
    
    const baselines = data.baselines || [];
    if (baselines.length === 0) {
      el.innerHTML = '<div class="muted">No baselines detected yet. Need more data.</div>';
      return;
    }
    
    let html = '<div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px;">';
    
    baselines.forEach(function(baseline, idx) {
      html += '<div style="padding:12px; background:rgba(74,168,255,0.1); border-radius:8px;">';
      html += '<div style="font-size:11px; color:#9aa5be; margin-bottom:4px;">Baseline ' + baseline.baselineNumber + '</div>';
      html += '<div style="font-size:20px; font-weight:700; color:#4aa8ff;">' + baseline.value.toFixed(2) + '</div>';
      html += '<div style="font-size:10px; color:#9aa5be; margin-top:4px;">' + baseline.sessions + ' sessions</div>';
      if (baseline.period) {
        html += '<div style="font-size:10px; color:#9aa5be; margin-top:2px;">' + escapeHtml(baseline.period) + '</div>';
      }
      html += '</div>';
    });
    
    html += '</div>';
    el.innerHTML = html;
  }
  
  // Helper function
  function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // Tab loader already registered above (outside IIFE)
  
  // Cycles Guide Modal functions
  window.openCyclesGuideModal = function() {
    const modal = document.getElementById('spiralCyclesGuideModal');
    if (modal) {
      modal.style.display = 'flex';
    }
  };
  
  window.closeCyclesGuideModal = function() {
    const modal = document.getElementById('spiralCyclesGuideModal');
    if (modal) {
      modal.style.display = 'none';
    }
  };
  
  // Close modal when clicking outside
  document.addEventListener('click', function(e) {
    const modal = document.getElementById('spiralCyclesGuideModal');
    if (modal && e.target === modal) {
      closeCyclesGuideModal();
    }
  });
  
  function hidePlayerTooltip() {
    const tooltip = document.getElementById('cluster-player-tooltip');
    if (tooltip) {
      tooltip.style.display = 'none';
    }
  }
  
  // Team Overview Modal functions
  window.openTeamOverviewModal = function() {
    const modal = document.getElementById('spiralTeamOverviewModal');
    if (modal) {
      modal.style.display = 'flex';
      // Load team data
      loadTeamOverviewModal();
    }
  };
  
  window.closeTeamOverviewModal = function() {
    const modal = document.getElementById('spiralTeamOverviewModal');
    if (modal) {
      modal.style.display = 'none';
    }
  };
  
  // Load team overview data for modal
  window.loadTeamOverviewModal = function() {
    const contentBox = document.getElementById('teamOverviewModalContent');
    const themeBox = document.getElementById('teamOverviewThemeChips');
    
    if (!contentBox) return;
    
    contentBox.innerHTML = '<div class="muted" style="text-align:center; padding:20px;">Loading...</div>';
    if (themeBox) themeBox.innerHTML = '<div class="muted">Loading themes...</div>';
    
    // Helper function to create card
    const makeCard = function(title, body) {
      const card = document.createElement('div');
      card.className = 'card';
      card.style.padding = '16px';
      card.style.border = '1px solid var(--border)';
      card.style.borderRadius = '12px';
      card.innerHTML = `
        <div class="sectionTitle" style="margin:0 0 12px 0;">${title}</div>
        ${body ? `<div style="line-height:1.6;">${String(body).replace(/\n/g,'<br>')}</div>` : '<div class="muted">—</div>'}
      `;
      return card;
    };
    
    // Helper to format bullets
    const bullets = function(arr) {
      if (!arr || !arr.length) return null;
      return arr.map(x => `• ${x}`).join('\n');
    };
    
    // Fetch team summary data
    google.script.run
      .withSuccessHandler(function(team) {
        contentBox.innerHTML = '';
        if (!team) {
          contentBox.innerHTML = '<div class="muted" style="text-align:center; padding:20px;">No reliable team trend for the last 7 days.</div>';
          return;
        }
        // Only show Summary (exclude Positives, Concerns, Suggested Focus)
        contentBox.appendChild(makeCard('Summary', team.summary || '—'));
      })
      .withFailureHandler(function(err) {
        contentBox.innerHTML = '<div class="muted" style="text-align:center; padding:20px; color:#ff5a5f;">Failed to load team summary: ' + String(err) + '</div>';
      })
      .getTeamTrend();
    
    // Fetch theme frequency
    google.script.run
      .withSuccessHandler(function(themeMap) {
        if (!themeBox) return;
        themeBox.innerHTML = '';
        if (!themeMap || !Object.keys(themeMap).length) {
          themeBox.innerHTML = '<div class="muted">No clip themes in the last 7 days.</div>';
          return;
        }
        Object.keys(themeMap).sort(function(a,b) {
          return themeMap[b] - themeMap[a];
        }).forEach(function(themeName) {
          const tag = document.createElement('span');
          tag.className = 'tag';
          tag.textContent = themeName + ' (' + themeMap[themeName] + ')';
          tag.style.marginRight = '8px';
          tag.style.marginBottom = '8px';
          tag.style.display = 'inline-block';
          themeBox.appendChild(tag);
        });
      })
      .withFailureHandler(function(err) {
        if (themeBox) {
          themeBox.innerHTML = '<div class="muted">Failed to load themes.</div>';
        }
      })
      .getThemeCountsLast7d();
  };
  
  // Close modal when clicking outside
  document.addEventListener('click', function(e) {
    const modal = document.getElementById('spiralTeamOverviewModal');
    if (modal && e.target === modal) {
      closeTeamOverviewModal();
    }
  });
  
  // Initialize when tab is shown
  document.addEventListener('DOMContentLoaded', function() {
    // Watch for tab changes
    const observer = new MutationObserver(function(mutations) {
      const panel = document.getElementById('panel-spiralfeedback');
      if (panel && panel.classList.contains('active')) {
        loadSpiralDashboard();
      }
    });
    
    const panel = document.getElementById('panel-spiralfeedback');
    if (panel) {
      observer.observe(panel, { attributes: true, attributeFilter: ['class'] });
      if (panel.classList.contains('active')) {
        loadSpiralDashboard();
      }
    }
  });
  
  // Also listen for sidebar clicks
  document.addEventListener('click', function(e) {
    const sideItem = e.target.closest('#sideNav .sideItem[data-tab="spiralfeedback"]');
    if (sideItem) {
      setTimeout(loadSpiralDashboard, 100);
    }
  });
})();
    </script>
  </body>
</html>
